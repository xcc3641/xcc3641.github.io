<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java 基础 —— 多线程（读书笔记）「三」 · IM XIE</title><meta name="description" content="Java 基础 —— 多线程（读书笔记）「三」 - 谢三弟"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://imxie.cc/atom.xml" title="IM XIE"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/xcc3641" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/WebLab/" target="_self" class="nav-list-link">WEBLAB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Java 基础 —— 多线程（读书笔记）「三」</h1><div class="post-info">2016年9月29日</div><div class="post-content"><p>前面两章已经了解了很多线程相关的知识，但是当我们需要频繁地创建多个线程进行耗时操作时，每次通过 <code>new Thread</code> 并不是很好的实现方式。</p>
<ul>
<li>新建和销毁对象性能较差</li>
<li>线程缺乏统一管理</li>
<li>可能无限制新建线程，相互竞争，死锁</li>
<li>缺少定时执行，定期执行，线程中断等等</li>
</ul>
<a id="more"></a>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul>
<li><a href="#目录">目录</a></li>
<li><a href="#简介">简介</a></li>
<li><a href="#使用">使用</a><ul>
<li><a href="#ThreadPoolExecutor">ThreadPoolExecutor</a><ul>
<li><a href="#构造函数">构造函数</a></li>
<li><a href="#WorkQueue">WorkQueue</a></li>
<li><a href="#RejectedExecutionHandler">RejectedExecutionHandler</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>线程池简单来说：创建多个线程并且进行管理，提交给线程的任务会被线程池指派给其中的线程执行，通过线程池的统一调度，管理使得多线程的使用更简单，高效。</p>
<p>大致流程图：<br><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f8m936f9a5j21540x0ada.jpg" alt=""></p>
<p>线程池都实现了 ExecutorService 接口，它的实现有 ThreadPoolExecutor 和 ScheduledExecutorService 。ThreadPoolExecutor 也就是我们运用最多的线程池实现，而 ScheduledExecutorService 通过名字我们就可以知道用于<strong>周期性地执行任务</strong>。</p>
<p>通常我们都不会使用 <code>new</code> 的形式来创建线程池，而使用 JDK 给我们封装好了的 Executors 工厂类来简化这个过程。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><p>ThreadPoolExecutor 是线程池的实现之一，它的功能是启动指定数量的线程以及将任务添加到一个队列中，并且将任务分发给空闲线程。</p>
<p>ExecutorService 的生命周期包括三种状态：运行，关闭，终止。<br>创建后便进入运行状态，当调用了 <code>shutdown()</code> 方法时，便进入关闭状态，此时意味着 ExecutorService 不再接受新的任务，但它还在执行已经提交了的任务。当所有已经提交的任务执行完毕后，就变成终止状态。</p>
<p>做了一个图，直观的展示了状态的转换：<br><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f8me14yaucj212a0l2jse.jpg" alt=""></p>
<h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></div><div class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></div><div class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></div><div class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></div><div class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt; corePoolSize ||</div><div class="line">        keepAliveTime &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">    <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们主要对构造函数的参数进行简要说明：</p>
<ul>
<li>corePoolSize 线程池中所保存的核心线程数。</li>
<li>maximumPoolSize 线程池允许创建的最大线程数。</li>
<li>keepAliveTime 当前线程池线程总数大于核心线程数时，终止多余的空闲线程的时间。</li>
<li>Unit keepAliveTime 参数的时间单位，可选值有毫秒，秒，分等。</li>
<li>workQueue 任务队列，如果当前线程池达到核心线程数 corePoolSize ，且当前线程都处于活动状态时，则将新加入的任务放到此队列。</li>
<li>threadFactory 线程工厂，让用户可以定制线程的创建过程，通常不需要设置。</li>
<li>RejectedExecutionHandler 拒绝策略，当线程池与 workQueue 队列都满了的情况下，对新加任务采取的处理策略。</li>
</ul>
<h6 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h6><p>其中 workQueue 有下列几个常用的实现：</p>
<ol>
<li>ArrayBlockingQueue： 基于数组结构的有界队列，此队列按 FIFO 原则对任务进行排序。如果队列满了还有任务进来，则调用拒绝策略。</li>
<li>LinkedBlockingQueue：基于链表结构的无界队列，此队列按 FIFO 原则对任务进行排序。因为它是无界的，根本不会满，所以采用此队列后线程池将忽略拒绝策略 (handler) 参数；同时还将忽略最大线程数 maximumPoolSize 。</li>
<li>SynchronousQueue：直接将任务提交给线程而不是将它加入到队列，实际上此队列是空的。每个插入的操作必须等到另一个调用移除的操作；如果新任务来了线程池没有任何可用线程处理的话，则调用拒绝策略。</li>
<li>PriorityBlockingQueue：具有优先级基于数组结构的有界队列，可以自定义优先级，默认是按照自然排序。</li>
</ol>
<h6 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h6><p>当线程池与 workQueue 队列都满了的情况下，对新加任务采取的处理策略也有几个默认实现：</p>
<ol>
<li>AbortPolicy：拒绝任务，抛出 RejectedExecutionException 异常。线程池默认策略。</li>
<li>CallerRunsPolicy：拒绝新任务进入，如果该线程池还没有被关闭，那么将这个新任务执行在调用线程中。</li>
<li>DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序。</li>
<li>DiscardPolicy： 加不进的任务都被抛弃了，同时没有异常抛出。</li>
</ol>
<h6 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h6><p>Executors 可以构建几种常见的线程池，我们通过实例对比来加深对他们的印象。</p>
<ul>
<li><strong>newCachedThreadPool</strong></li>
</ul>
<p>当线程池中的线程空闲时间超过 60s 则会自动回收该线程，当任务超过线程池的线程数则创建新线程。线程池的大小上限为 Integer.MAX_VALUE，可看做是无限大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        cachedThreadPoolRun();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">produceTasks</span><span class="params">(ExecutorService service)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> finalI = i;</div><div class="line">            service.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    System.out.println(<span class="string">"This Thread is: "</span> + Thread.currentThread().getName() + <span class="string">" &gt;&gt;&gt; Task:"</span> + finalI);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">500</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cachedThreadPoolRun</span><span class="params">()</span> </span>&#123;</div><div class="line">        ExecutorService service = Executors.newCachedThreadPool();</div><div class="line">        produceTasks(service);</div><div class="line">        service.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后控制台输出：</p>
<blockquote>
<p>This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:0<br>This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:1<br>This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:2<br>This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:3<br>This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:4<br>This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:5<br>This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:6<br>This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:7<br>This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:8<br>This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:9</p>
</blockquote>
<p>从结果可以看出，整个过程都在 pool-1-thread-1 中执行，后续任务一直在复用之前线程。</p>
<ul>
<li><strong>newFixedThreadPool</strong></li>
</ul>
<h4 id="总结和参考"><a href="#总结和参考" class="headerlink" title="总结和参考"></a>总结和参考</h4><ul>
<li><a href="http://extremej.itscoder.com/threadpoolexecutor_source/" target="_blank" rel="external">ThreadPoolExecutor 源码学习笔记</a></li>
<li><a href="http://gityuan.com/2016/01/16/thread-pool/" target="_blank" rel="external">Java 线程池分析</a></li>
</ul></div></article></div></section><footer><div class="paginator"></div><div data-thread-key="wait/Review-Java-Thread-3.html" data-title="Java 基础 —— 多线程（读书笔记）「三」" data-url="http://imxie.cc/wait/Review-Java-Thread-3.html" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"imxie"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://www.imxie.cc/js/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2019 做一件值得的事.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-80145821-1",'auto');ga('send','pageview');</script></body></html>