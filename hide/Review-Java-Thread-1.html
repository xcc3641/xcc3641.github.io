<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java 基础 —— 多线程（读书笔记）「一」 · IM XIE</title><meta name="description" content="Java 基础 —— 多线程（读书笔记）「一」 - 谢三弟"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://imxie.cc/atom.xml" title="IM XIE"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/xcc3641" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/WebLab/" target="_self" class="nav-list-link">WEBLAB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Java 基础 —— 多线程（读书笔记）「一」</h1><div class="post-info">2016年9月21日</div><div class="post-content"><p>多线程对于 Android 开发者来说是基础。而且这类知识在计算机里也是很重要的一环，所以很有必要整理一番。</p>
<a id="more"></a>
<blockquote>
<ul>
<li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://github.com/xcc3641" target="_blank" rel="external">谢三弟</a></li>
<li>审阅者：<a href="https://github.com/laobie" target="_blank" rel="external">Jaeger</a></li>
</ul>
</blockquote>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul>
<li><a href="#目录">目录</a></li>
<li><a href="#多线程的实现">多线程的实现</a><ul>
<li><a href="#Thread-源码">Thread 源码</a></li>
<li><a href="#线程的几个重要的函数">线程的几个重要的函数</a></li>
<li><a href="#Wait-的实践">Wait() 的实践</a></li>
<li><a href="#Join-的实践">Join() 的实践</a></li>
<li><a href="#Yield-的实践">Yield() 的实践</a></li>
</ul>
</li>
<li><a href="#总结与参考">总结与参考</a></li>
</ul>
<h4 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h4><p>来上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 最常见的两种方法启动新的线程</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 覆盖 run 方法</span></div><div class="line">    <span class="keyword">new</span> Thread() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 耗时操作</span></div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line"></div><div class="line">    <span class="comment">// 传入 Runnable 对象</span></div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 耗时操作</span></div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实第一个就是在 Thread 里覆写了 <code>run()</code> 函数，第二个是给 Thread 传了一个 Runnable 对象，在 Runnable 对象 <code>run()</code> 方法里进行耗时操作。<br>以前没有怎么考虑过他们两者的关系，今天我们来具体看看到底是什么鬼？</p>
<h5 id="Thread-源码"><a href="#Thread-源码" class="headerlink" title="Thread 源码"></a>Thread 源码</h5><p>进入 Thread 源码我们看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">/* What will be run. */</span></div><div class="line">    <span class="keyword">private</span> Runnable target;</div><div class="line"></div><div class="line">    <span class="comment">/* The group of this thread */</span></div><div class="line">    <span class="keyword">private</span> ThreadGroup group;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</div><div class="line">        init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</div><div class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>源码很长，我进行了一点分割。一点一点的来解析看看。<br>我们首先知道 Thread 也是一个 Runnable ，它实现了 Runnable 接口，并且在 Thread 类中有一个 Runnable 类型的 target 对象。</p>
<p>构造方法里我们都会调用 <code>init()</code> 方法，接下来看看在该方法里做了如何的初始化配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></div><div class="line"><span class="function"><span class="params">                 <span class="keyword">long</span> stackSize)</span> </span>&#123;</div><div class="line">   init(g, target, name, stackSize, <span class="keyword">null</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></div><div class="line"><span class="function"><span class="params">                 <span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</div><div class="line"></div><div class="line">   Thread parent = currentThread();</div><div class="line">   SecurityManager security = System.getSecurityManager();</div><div class="line">   <span class="comment">// group 参数如果为 null ，则获得当前线程的 group（线程组）</span></div><div class="line">   <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</div><div class="line">           g = parent.getThreadGroup();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 代码省略</span></div><div class="line"></div><div class="line">   <span class="keyword">this</span>.group = g;</div><div class="line">   <span class="keyword">this</span>.daemon = parent.isDaemon();</div><div class="line">   <span class="keyword">this</span>.priority = parent.getPriority();</div><div class="line">   <span class="comment">// 设置 target（ Runnable 类型 ）</span></div><div class="line">   <span class="keyword">this</span>.target = target;</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">// 将当前线程加入线程组</span></div><div class="line">   group.add(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">   <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 启动 native 方法启动新的线程</span></div><div class="line">       start0();</div><div class="line">       started = <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// 代码省略</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">       target.run();</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上我们可以明白，最终被线程执行的任务是 Runnable ，Thread 只是对 Runnable 的一个包装，并且通过一些状态对 Thread 进行管理和调度。<br>当启动一个线程时，如果 Thread 的 target 不为空，则会在子线程中执行这个 target 的 <code>run()</code> 函数，否则虚拟机就会执行该线程自身的 <code>run()</code> 函数。</p>
<h5 id="线程的几个重要的函数"><a href="#线程的几个重要的函数" class="headerlink" title="线程的几个重要的函数"></a>线程的几个重要的函数</h5><ul>
<li>wait()<br>  当一个线程执行到 wait() 方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁，使得其他线程可以访问。用户可以使用 notify 、notifyAll 或者指定睡眠时间来唤醒当前等待池中的线程。<br>  注意：<code>wait() notify() notifyAll()</code> 必须放在 <code>synchronized</code> block 中，否则会抛出异常。</li>
<li>sleep()<br>  该函数是 Thread 的静态函数，作用是使调用线程进入睡眠状态。因为 <code>sleep()</code> 是 Thread 类的静态方法，因此他不能改变对象的机锁。所以，当在一个 <code>synchronized</code> 块中调用 <code>sleep()</code> 方法时，线程虽然休眠了，但是对象的机锁并没有被释放，其他线程无法访问这个对象。</li>
<li>join()<br>  等待目标线程执行完成之后继续执行。</li>
<li>yield()<br>  线程礼让。目前线程由运行状态转换为就绪状态，也就是让出执行权限，让其他线程得以优先执行，但其他线程能否优先执行未知。</li>
</ul>
<p>在源码中，查看 Thread 里的 State ，对几种状态解释的很清楚。</p>
<blockquote>
<p>NEW 状态是指线程刚创建，尚未启动</p>
<p>RUNNABLE 状态是线程正在正常运行中，当然可能会有某种耗时计算 / IO 等待的操作 / CPU 时间片切换等, 这个状态下发生的等待一般是其他系统资源, 而不是锁, Sleep 等</p>
<p>BLOCKED  这个状态下，是在多个线程有同步操作的场景, 比如正在等待另一个线程的 synchronized 块的执行释放，或者可重入的 synchronized 块里别人调用 wait() 方法，也就是这时线程在等待进入临界区</p>
<p>WAITING  这个状态下是指线程拥有了某个锁之后，调用了他的 wait 方法，等待其他线程 / 锁拥有者调用 notify / notifyAll 一遍该线程可以继续下一步操作，这里要区分 BLOCKED 和 WATING ，一个是在临界点外面等待进入， 一个是在临界点里面 wait 等待别人 notify ， 线程调用了 join 方法 进入另外的线程的时候, 也会进入 WAITING 状态，等待被他 join 的线程执行结束</p>
<p>TIMED_WAITING  这个状态就是有限的 (时间限制) 的 WAITING， 一般出现在调用 <code>wait(long), join(long)</code> 等情况下，另外，一个线程 sleep 后, 也会进入 TIMED_WAITING 状态</p>
<p>TERMINATED 这个状态下表示 该线程的 run 方法已经执行完毕了, 基本上就等于死亡了 (当时如果线程被持久持有, 可能不会被回收)</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/98641-f529c1608fd10ffe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="Wait-的实践"><a href="#Wait-的实践" class="headerlink" title="Wait() 的实践"></a>Wait() 的实践</h5><p>我们来看一段，<code>wait()</code> 的用途和效果。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitAndNotifyAll</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	System.out.println(<span class="string">"主线程运行"</span>);</div><div class="line"></div><div class="line">	Thread thread = <span class="keyword">new</span> WaitThread();</div><div class="line">	thread.start();</div><div class="line">	<span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">synchronized</span> (sLockOject) &#123;</div><div class="line">			System.out.println(<span class="string">"主线程等待"</span>);</div><div class="line">			sLockOject.wait();</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">long</span> timeMs = System.currentTimeMillis() - startTime;</div><div class="line">	System.out.println(<span class="string">"主线程继续 —-&gt; 等待耗时："</span> + timeMs + <span class="string">" ms"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">synchronized</span> (sLockOject) &#123;</div><div class="line">				System.out.println(<span class="string">"进入子线程"</span>);</div><div class="line">				Thread.sleep(<span class="number">3000</span>);</div><div class="line">				System.out.println(<span class="string">"唤醒主线程"</span>);</div><div class="line">				sLockOject.notifyAll();</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>waitAndNotifyAll()</code> 函数里，会启动一个 WaitThread 线程，在该线程中将会调用 sleep 函数睡眠 3 秒。线程启动之后在主线程调用 sLockOject 的 <code>wait()</code> 函数，使主线程进入等待状态，此时将不会继续执行。等 WaitThread 在 <code>run()</code> 函数沉睡了 3 秒后会调用 sLockOject 的 <code>notifyAll()</code> 函数，此时就会重新唤醒正在等待中的主线程，因此会继续往下执行。</p>
<p>结果如下：</p>
<blockquote>
<p>主线程运行<br>主线程等待<br>进入子线程<br>唤醒主线程<br>主线程继续 —-&gt; 等待耗时：3005 ms</p>
</blockquote>
<p><code>wait()、notify()</code> 机制通常用于等待机制的实现，当条件未满足时调用 wait 进入等待状态，一旦条件满足，调用 <code>notify</code> 或 <code>notifyAll</code> 唤醒等待的线程继续执行。</p>
<div class="tip"><br><br>对于这里细节可能会有一些疑问。<br><br>在子线程启动的时候，<code>run()</code> 函数里面已经持有了该对象锁。<br><br>但是真实环境下，其实是主线程先持有对象锁，然后调用 <code>wait()</code> 进入等待区并且释放锁等待唤醒。<br><br></div>

<p>这个问题涉及到 JNI 代码，目前我只能从理论上来解释这个问题。<br>我们都知道一个线程 <code>start()</code> 并不是马上启动，而是需要 CPU 分配资源的，根据目前运行来看，分配资源的时间大于 Java 虚拟机运行指令的时间，所以主线程比子线程先拿到锁。<br>我们还可以知道一点，控制台打印出的时间是 <strong>3005 ms</strong> ，在代码里我们只等待了 3s 多出来的 5ms （这个数字会浮动）我们可以推断是，子线程获取 CPU 的时间加上唤醒主线程的时间。</p>
<p>上述只是自己的一个猜测，能力还有欠缺，准备深入学习。</p>
<p>不过推荐大家看看这篇文章 <a href="http://www.jianshu.com/p/99ecdbc9c664" target="_blank" rel="external">Synchnornized 在 JVM 下的实现 - 简书</a>。</p>
<h5 id="Join-的实践"><a href="#Join-的实践" class="headerlink" title="Join() 的实践"></a>Join() 的实践</h5><p><code>join()</code> 的注释上面写着：</p>
<blockquote>
<p>Waits for this thread to die.</p>
</blockquote>
<p>意思是，阻塞当前调用 <code>join()</code> 函数所在的线程，直到接收线程执行完毕之后再继续。<br>我们来看看实践代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		joinDemo();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">joinDemo</span><span class="params">()</span> </span>&#123;</div><div class="line">		Worker worker1 = <span class="keyword">new</span> Worker(<span class="string">"work-1"</span>);</div><div class="line">		Worker worker2 = <span class="keyword">new</span> Worker(<span class="string">"work-2"</span>);</div><div class="line">		worker1.start();</div><div class="line">		System.out.println(<span class="string">"启动线程 1 "</span>);</div><div class="line"></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">// 调用 worker1 的 join 函数，主线，程会阻塞直到 woker1 执行完成</span></div><div class="line">			worker1.join();</div><div class="line">			System.out.println(<span class="string">"启动线程 2"</span>);</div><div class="line">			<span class="comment">// 再启动线程 2 ，并且调用线程 2 的 join 函数，主线程会阻塞直到 woker2 执行完成</span></div><div class="line">			worker2.start();</div><div class="line">			worker2.join();</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		System.out.println(<span class="string">"主线程继续执行"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>(name);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">2000</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"></div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			System.out.println(<span class="string">"work in "</span> + getName());</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行之后我们得到：</p>
<blockquote>
<p>启动线程 1<br>work in work-1<br>启动线程 2<br>work in work-2<br>主线程继续执行</p>
</blockquote>
<p>在 <code>joinDemo()</code> 方法里我们创建两个子线程，然后启动了 work1 线程，下一步调用了 woker1 的 <code>join()</code> 函数。此时，主线程会进入阻塞状态，直到 work1 执行完毕之后才开始继续执行。因为 Worker 的 <code>run()</code> 方法里会休眠 2 秒，因此线程每次调用了 <code>join()</code> 方法实际上都会阻塞 2 秒，直到 <code>run()</code> 方法执行完毕再继续。<br>所以，上述代码逻辑其实就是：</p>
<p><strong>启动线程1</strong> —-&gt; <strong>等待线程 1 执行完毕</strong> —-&gt; <strong>启动线程2</strong> —-&gt; <strong>等待线程 2 执行完毕</strong> —-&gt; <strong>继续执行主线程代码</strong></p>
<h5 id="Yield-的实践"><a href="#Yield-的实践" class="headerlink" title="Yield() 的实践"></a>Yield() 的实践</h5><p><code>yield()</code> 是 Thread 的静态方法，注释上说：</p>
<blockquote>
<p>A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.</p>
</blockquote>
<p>大致意思是说：当前线程让出执行时间给其他的线程。<br>我们都知道，线程的执行是有时间片的，每个线程轮流占用 CPU 固定时间，执行周期到了之后让出执行权给其他线程。<br><code>yield()</code> 就是主动让出执行权给其他线程。</p>
<p>来看看我们实践的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldThreadTest</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		YieldTread t1 = <span class="keyword">new</span> YieldTread(<span class="string">"thread-1"</span>);</div><div class="line">		YieldTread t2 = <span class="keyword">new</span> YieldTread(<span class="string">"thread-2"</span>);</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldTread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">YieldTread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>(name);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">				System.out.printf(<span class="string">"%s 优先级为 [%d] -------&gt; %d\n"</span>, <span class="keyword">this</span>.getName(), <span class="keyword">this</span>.getPriority(), i);</div><div class="line">				<span class="comment">// 当 i 为 2 时，调用当前线程的 yield 函数</span></div><div class="line">				<span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</div><div class="line">					Thread.yield();</div><div class="line"></div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 <code>main()</code> 方法里创建了两个 YieldTread 线程，控制台输出结果如下：</p>
<blockquote>
<p>thread-1 优先级为 [5] ——-&gt; 0<br>thread-1 优先级为 [5] ——-&gt; 1<br>thread-1 优先级为 [5] ——-&gt; 2</p>
<p>thread-2 优先级为 [5] ——-&gt; 0<br>thread-2 优先级为 [5] ——-&gt; 1<br>thread-2 优先级为 [5] ——-&gt; 2</p>
<p>thread-1 优先级为 [5] ——-&gt; 3<br>thread-1 优先级为 [5] ——-&gt; 4<br>thread-2 优先级为 [5] ——-&gt; 3<br>thread-2 优先级为 [5] ——-&gt; 4</p>
</blockquote>
<p>通常情况下 t1 首先执行，让 t1 的 <code>run()</code> 函数执行到了 i 等于 2 时让出当前线程的执行时间。所以我们看到前三行都是 t1 在执行，让出执行时间后 t2 开始执行。后面逻辑简单思考下就得知了，这里也不做过多诠释。</p>
<p>因此，调用 <code>yield()</code> 就是让出当前线程的执行权，这样一来让其他线程得到优先执行。</p>
<h4 id="总结与参考"><a href="#总结与参考" class="headerlink" title="总结与参考"></a>总结与参考</h4><p>本章内容属于线程的基础，本系列会更新到线程池相关。<br>这章内容也及其重要，因为它是后面的基础。<br>正确理解才能让我们对各种线程问题有方向和思路。</p>
<p><strong>参考读物</strong>：</p>
<ul>
<li><a href="https://book.douban.com/subject/26744163/" target="_blank" rel="external">Android 开发进阶 — 从小工到专家</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=416915373&amp;idx=1&amp;sn=f80a13b099237534a3ef777d511d831a&amp;scene=0#wechat_redirect" target="_blank" rel="external">我是一个线程</a></li>
</ul></div></article></div></section><footer><div class="paginator"></div><div data-thread-key="hide/Review-Java-Thread-1.html" data-title="Java 基础 —— 多线程（读书笔记）「一」" data-url="http://imxie.cc/hide/Review-Java-Thread-1.html" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"imxie"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://www.imxie.cc/js/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2019 做一件值得的事.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-80145821-1",'auto');ga('send','pageview');</script></body></html>