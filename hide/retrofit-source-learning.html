<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 框架源码 — 简析学习 Retrofit · IM XIE</title><meta name="description" content="框架源码 — 简析学习 Retrofit - 谢三弟"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://imxie.cc/atom.xml" title="IM XIE"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/images/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/xcc3641" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">框架源码 — 简析学习 Retrofit</h1><div class="post-info">2016年8月20日</div><div class="post-content"><p>看过很多篇 Retrofit 的源码分析文章，但是别人一问起来总是讲不清楚到底 Retrofit 是怎么个流程，所以还是得自己亲自去看看源码，一步一步的分析。果然只有亲自动手实践，才有自己的收获。<br>告诫自己，<strong>慢慢来，会很快。</strong></p>
<a id="more"></a>
<blockquote>
<ul>
<li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="http://imxie.cc">谢三弟</a></li>
<li>审阅者：<a href="http://extremej.itscoder.com/" target="_blank" rel="external">Joe</a></li>
</ul>
</blockquote>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#目录">目录</a></li>
<li><a href="#Retrofit-简介">Retrofit 简介</a></li>
<li><a href="#Retrofit-分析">Retrofit 分析</a><ul>
<li><a href="#具体使用">具体使用</a></li>
<li><a href="#工具箱：Retrofit-Builder">工具箱：Retrofit.Builder()</a></li>
<li><a href="#外壳：Create">外壳：Create()</a></li>
<li><a href="#结构：ServiceMethod">结构：ServiceMethod</a></li>
<li><a href="#子弹：xxxFactory">子弹：xxxFactory()</a></li>
<li><a href="#开枪打靶-Call-enqueue">开枪打靶: Call.enqueue()</a></li>
</ul>
</li>
<li><a href="#参考">参考</a></li>
</ul>
<h3 id="Retrofit-简介"><a href="#Retrofit-简介" class="headerlink" title="Retrofit 简介"></a>Retrofit 简介</h3><p>Retrofit 源码开头的解释</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">* Retrofit adapts a Java <span class="class"><span class="keyword">interface</span> <span class="title">to</span> <span class="title">HTTP</span> <span class="title">calls</span> <span class="title">by</span> <span class="title">using</span> <span class="title">annotations</span> <span class="title">on</span> <span class="title">the</span> <span class="title">declared</span> <span class="title">methods</span> <span class="title">to</span></span></div><div class="line"><span class="class">* <span class="title">define</span> <span class="title">how</span> <span class="title">requests</span> <span class="title">are</span> <span class="title">made</span>. <span class="title">Create</span> <span class="title">instances</span> <span class="title">using</span> </span>&#123;<span class="meta">@linkplain</span> Builder</div><div class="line">* the builder&#125; and pass your interface to &#123;@link #create&#125; to generate an implementation.</div></pre></td></tr></table></figure>
<p>Retrofit 利用方法上的注解将接口转化成一个 HTTP 请求。</p>
<p>简单知道是什么了之后，我们对此提出疑问：</p>
<ul>
<li>如何将接口转换为网络请求？</li>
<li>谁去进行网络请求？</li>
</ul>
<p>接下来我们将从 Retrofit 的使用作为入口分析。</p>
<h3 id="Retrofit-分析"><a href="#Retrofit-分析" class="headerlink" title="Retrofit 分析"></a>Retrofit 分析</h3><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><p>首先建立 API 接口类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GankApi</span> </span>&#123;</div><div class="line">    String host = <span class="string">"http://gank.io/api/data/"</span>;</div><div class="line">    <span class="meta">@GET</span>(<span class="string">"Android/10/&#123;page&#125;"</span>)</div><div class="line">    <span class="function">Call&lt;Android&gt; <span class="title">getAndroid</span><span class="params">(@Path(<span class="string">"page"</span>)</span> <span class="keyword">int</span> page)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 创建 Retrofit 实例</span></div><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">    .baseUrl(GankApi.host)</div><div class="line">    .addConverterFactory(GsonConverterFactory.create())</div><div class="line">    .build();</div><div class="line"></div><div class="line"><span class="comment">// 生成接口实现类</span></div><div class="line">GankApi gankApi = retrofit.create(GankApi.class);</div><div class="line"></div><div class="line"><span class="comment">// 调用接口定义的请求方法，并且返回 Call 对象</span></div><div class="line">Call&lt;Android&gt; call = gankApi.getAndroid(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// 调用 Call 对象的异步执行方法</span></div><div class="line">call.enqueue(Callback callback)</div></pre></td></tr></table></figure>
<p>简单的使用就是这样的流程。现在我们开始层层剖析。</p>
<h4 id="工具箱：Retrofit-Builder"><a href="#工具箱：Retrofit-Builder" class="headerlink" title="工具箱：Retrofit.Builder()"></a>工具箱：Retrofit.Builder()</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Platform platform;</div><div class="line"><span class="keyword">private</span> okhttp3.Call.Factory callFactory;</div><div class="line"><span class="keyword">private</span> HttpUrl baseUrl;</div><div class="line"><span class="keyword">private</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">private</span> List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">private</span> Executor callbackExecutor;</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</div></pre></td></tr></table></figure>
<p>创建 Retrofit 的实例，进行一些配置，这里我们不用多说。但是有一个参数必须得讲讲。</p>
<ul>
<li><strong>Platform</strong></li>
</ul>
<p>在构建 Retrofit 的时候，会对当前使用平台进行判断，Java8，Android，iOS。</p>
<p>我们看看 Android 平台的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(Executor callbackExecutor)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">      handler.post(r);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码中我们得知两点：</p>
<ol>
<li>在 Android 里我们默认使用的 CallAdapter 是 <code>ExecutorCallAdapterFactory()</code> 它会返回的是 Call.class。关于 <code>ExecutorCallAdapterFactory()</code> 我们稍后再说，你先知道这是 Android 默认 CallAdapter 就好。</li>
<li>默认的 Callback 是在主线程。</li>
</ol>
<h4 id="外壳：Create"><a href="#外壳：Create" class="headerlink" title="外壳：Create()"></a>外壳：Create()</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 生成接口实现类</span></div><div class="line">GankApi gankApi = retrofit.create(GankApi.class);</div></pre></td></tr></table></figure>
<p>我在源码里写好了注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检查传入的类是否为接口并且无继承</span></div><div class="line">    Utils.validateServiceInterface(service);</div><div class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">      eagerlyValidateMethods(service);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 重点是这里</span></div><div class="line">    <span class="comment">// 首先会返回一个利用代理实现的 GankApi 对象</span></div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line"></div><div class="line">          <span class="comment">// 我们调用该对象的方法都会进入到这里</span></div><div class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></div><div class="line"><span class="function">              <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></div><div class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</div><div class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 解析方法 这里用到了注解（Runtime）这里我们标记下（A）稍后来看看里面具体实现</span></div><div class="line">            ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">            <span class="comment">// 将刚刚解析完毕包装后的具体方法封装成 OkHttpCall ，你可以在该实现类找到 okhttp 请求所需要的参数</span></div><div class="line">            <span class="comment">// 所以它是用来跟 okhttp 对接的。</span></div><div class="line">            OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            <span class="comment">// 将以上我们封装好的 call 返回给上层，这个时候我们就可以执行 call 的同步方法或者异步进行请求。</span></div><div class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>切合我们实际运用来看看顺序：</p>
<p><code>GankApi gankApi = retrofit.create(GankApi.class);</code>—-&gt;<br> <code>return (T) Proxy.newProxyInstance（...）{...}</code>—-&gt;<br> <code>Call&lt;Android&gt; call = gankApi.getAndroid(1);</code> —-&gt;<br>  <code>public Object invoke(...){...}</code> 调用代理类的<code>invoke()</code>。</p>
<p>  直到这里我们已经宏观地了解 Retrofit 是怎样的一个流程。<br>  达成 <strong>初窥门径</strong> 成就。</p>
<p>千万别骄傲，为了以后走的更远更稳，我们得好好筑基，上面我们用到的是动态代理，强烈建议认真阅读两篇文章。</p>
<ul>
<li><a href="http://www.jianshu.com/p/a56c61da55dd" target="_blank" rel="external">Retrofit2源码分析[动态代理]</a></li>
<li><a href="http://blog.csdn.net/giserstone/article/details/17199755" target="_blank" rel="external">Java静态代理和动态代理</a></li>
</ul>
<h4 id="结构：ServiceMethod"><a href="#结构：ServiceMethod" class="headerlink" title="结构：ServiceMethod"></a>结构：ServiceMethod</h4><p>Retrofit 有一个双链表用来缓存方法<br><code>private final Map&lt;Method, ServiceMethod&gt; serviceMethodCache = new LinkedHashMap&lt;&gt;();</code><br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="function">ServiceMethod <span class="title">loadServiceMethod</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">  ServiceMethod result;</div><div class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</div><div class="line">      <span class="comment">// 从缓存中获取该方法</span></div><div class="line">    result = serviceMethodCache.get(method);</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 没有就进行创建并且存入链表缓存</span></div><div class="line">      result = <span class="keyword">new</span> ServiceMethod.Builder(<span class="keyword">this</span>, method).build();</div><div class="line">      serviceMethodCache.put(method, result);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们发现主要的方法是 <code>new ServiceMethod.Builder(this, method).build();</code> ，所以接下来我们深入看看如何 <strong>解析注解</strong> 以及 <strong>构建请求方法</strong> 。</p>
<ul>
<li>初始化一些参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.retrofit = retrofit;</div><div class="line">  <span class="keyword">this</span>.method = method;</div><div class="line">  <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</div><div class="line">  <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</div><div class="line">  <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>build()</code></li>
</ul>
<p>这里的源码很长，做了很多异常处理，我截取重点来分析下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">callAdapter = createCallAdapter();</div><div class="line">responseConverter = createResponseConverter();</div></pre></td></tr></table></figure>
<p>一个是用来发送请求的 client ，一个是结果的转换器（Gson，FastJson …）之类，后面我们再讲这个。<br>上层配置就是当我们调用 Retrofit 的 <code>addConverterFactory()</code>和 <code>addCallAdapterFactory()</code>，内部会自动使用我们定义的组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</div><div class="line">  parseMethodAnnotation(annotation);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里可以看到遍历我们使用方法的注解，并且解析他们。<code>parseMethodAnnotation()</code> 内部就是解析好 HTTP 的请求方式。</p>
<p>为了篇幅大小，可以在 <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit2/ServiceMethod.java" target="_blank" rel="external">源码</a> 里看看具体的操作。</p>
<p>同时也可以看看 http 包下注解用到的接口，你会发现 <code>@Retention(RUNTIME)</code> 所以，从这里我们就可以明白，Retrofit 是在在运行期通过反射访问到这些注解的。</p>
<ul>
<li><code>return Call</code></li>
</ul>
<p>请求方法参数，请求客户端，返回值转换，我们都定义好了之后，便完成最后一步，构建好适合请求客户端的请求方法，Retrofit 默认的是 okhttpCall 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line"><span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div></pre></td></tr></table></figure>
<p>最后将 call 返回给上层，用户调用方法进行请求。</p>
<ul>
<li>总结</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** Adapts an invocation of an interface method into an HTTP call. */</span></div></pre></td></tr></table></figure>
<p>ServiceMethod 类开头注释已经很清楚的说明了作用，将接口方法改变成一个 HTTP call 。它对于 Retrofit 是很重要的存在，整个枪支内部都是由它来支撑起来。</p>
<h4 id="子弹：xxxFactory"><a href="#子弹：xxxFactory" class="headerlink" title="子弹：xxxFactory()"></a>子弹：xxxFactory()</h4><p>Retrofit 给我们最大的便利就是自身框架优雅的设计，只需要很小的改动，便可以优雅的适应不同的需求。所以很需要我们再补充点额外知识，了解什么是<a href="http://blog.csdn.net/zhangjg_blog/article/details/18735243" target="_blank" rel="external">适配器模式</a>，然后回到这里看看 Retrofit 是如何应用的。</p>
<p>在构建 <code>ServiceMethod</code> 对象的时候，有三个方法可以单独说说</p>
<ol>
<li><code>build()</code> 中 <code>createCallAdapter()</code> —-&gt; <code>retrofit.callAdapter()</code></li>
<li>解析接口方法内注解时<code>parseParameterAnnotation()</code>调用到的<code>retrofit.requestBodyConverter()</code></li>
<li><code>build()</code> 中 <code>createResponseConverter()</code> —-&gt; <code>retrofit.responseBodyConverter()</code></li>
</ol>
<blockquote>
<p>callAdapter()</p>
</blockquote>
<p>最终会调用到 <code>nextCallAdapter()</code> 该方法主要是从 callAdapterFactories 中获取新的 CallAdapter，它会跳过 skipPast，以及 skipPast 之前的 Factory，然后找到与 returnType 和 annotations 都匹配的 CallAdapterFactory 。</p>
<blockquote>
<p>requestBodyConverter() &amp; responseBodyConverter()</p>
</blockquote>
<p>最终会调用到 <code>nextRequestBodyConverter()/nextResponseBodyConverter</code>利用 converterFactories 创建一个与 RequestBody/ResponseBody 对应的 Converter 对象。</p>
<p>所以在这里我们就可以装填我们需要的子弹类型了。</p>
<p><strong>进入实战，为我们的 Retrofit 添加 RxJava 和 Gson。</strong></p>
<ul>
<li>Rxjava:</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/006tNbRwgw1f71shdblvjj30wi08igms.jpg" alt="23:33:50.jpg"></p>
<p> <strong>adapter-rxjava</strong> 我们重点看 RxJavaCallAdapterFactory 即可，它是实现了 CallAdapter.Factory 并在对应方法里将 Call 包装成 Observable.class 返回。<br> 然后给 Retrofit 对象加上 <code>.addCallAdapterFactory(RxJavaCallAdapterFactory.create())</code>，这样我们才可以优雅的使用 Retrofit + RxJava 。</p>
<ul>
<li>Gson:</li>
</ul>
<p><img src="http://ww3.sinaimg.cn/large/006tNbRwgw1f71si9z928j30x607adh0.jpg" alt="23:34:46.jpg"></p>
<p>我相信通过类名我们就可以知道每个类是用来做什么的，我在这里太过深入到具体实现反而一叶障目，<br>如果我们需要自定义数据转换格式，也是同样这样做。<br>继承 <code>Converter.Factory</code> 类作为适配类，同时创建两个实现 <code>Converter</code> 的类包装请求和响应的数据形式。</p>
<h4 id="开枪打靶-Call-enqueue"><a href="#开枪打靶-Call-enqueue" class="headerlink" title="开枪打靶: Call.enqueue()"></a>开枪打靶: Call.enqueue()</h4><div class="tip"><br>注意：我这里只列举一个默认状态下的情况<br></div>

<p>还记得我工具箱里我们提到的 <code>ExecutorCallbackCall</code> 吗？<br>这里的 Call 是对应我们选择的 call ，而此时是默认的 <code>ExecutorCallbackCall</code> 。如果还要问我为什么，请去看看 <a href="#工具箱：Retrofit-Builder">工具箱：Retrofit.Builder()</a> 里 Android 平台的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">final</span> Executor callbackExecutor;</div><div class="line">  <span class="keyword">final</span> Call&lt;T&gt; delegate;</div><div class="line"></div><div class="line">  ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</div><div class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</div><div class="line">    <span class="keyword">this</span>.delegate = delegate;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"callback == null"</span>);</div><div class="line"></div><div class="line">    delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</div><div class="line">        callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (delegate.isCanceled()) &#123;</div><div class="line">              <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></div><div class="line">              callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 delegate 对应的就是 okhttp 的 call ，不禁有疑问了，这里调用的是异步请求，但是我们的回调是怎么回到主线程的呢？</p>
<p>带着疑问我们来看看。<br>首先回调是在 <code>callbackExecutor.execute()</code> 我们从这里入手。<br>我们发现在 Retrofit 的 <code>build()</code> 方法里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</div><div class="line"><span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">  callbackExecutor = platform.defaultCallbackExecutor();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>平台默认的回调调度器，连忙回到工具箱看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(Executor callbackExecutor)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">      handler.post(r);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们发现，Android 默认的调度器是主线程的 Handler ，<code>execute()</code>方法也只是 <code>mainHandler.post()</code> 。</p>
<p>所以这下就可以解决我们的疑问了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (delegate.isCanceled()) &#123;</div><div class="line">      <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></div><div class="line">      callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这段代码我们就可以改写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mainHandler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (delegate.isCanceled()) &#123;</div><div class="line">      <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></div><div class="line">      callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果看到这，还不理解为什么那就得好好补补 handler 的知识啦！</p>
<p>我这里推荐 melo 写的这篇，风趣易懂 <a href="http://www.jianshu.com/p/fad4e2ae32f5" target="_blank" rel="external">带着这篇去通关所有Handler的提问</a> 。</p>
<p>最后放上两张<a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit" target="_blank" rel="external">开源社区</a>画的流程图，我觉得特别清晰：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNbRwgw1f75954laycj30qo0k0aas.jpg" alt="23:27:17.jpg"></p>
<p><img src="http://ww3.sinaimg.cn/large/006tNbRwgw1f7595w93nej30l70e6t9l.jpg" alt="23:28:01.jpg"></p>
<p><strong>以上。〃´∀`)</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.jianshu.com/p/a56c61da55dd" target="_blank" rel="external">Retrofit2源码分析[动态代理]</a></li>
<li><a href="http://blog.csdn.net/giserstone/article/details/17199755" target="_blank" rel="external">Java静态代理和动态代理</a></li>
<li><a href="http://blog.csdn.net/zhangjg_blog/article/details/18735243" target="_blank" rel="external">一个示例让你明白适配器模式</a></li>
<li><a href="http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Retrofit分析-漂亮的解耦套路</a></li>
<li><a href="http://blog.fangjie.info/2016/07/14/%E6%88%91%E5%AF%B9Retrofit%E7%9A%84%E8%AE%A4%E8%AF%86/" target="_blank" rel="external">我对Retrofit的认识</a></li>
<li><a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit" target="_blank" rel="external">Retrofit 源码分析</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/java-reflection/java-at.html" target="_blank" rel="external">Java 注解</a></li>
</ul></div></article></div></section><footer><div class="paginator"></div><div data-thread-key="hide/retrofit-source-learning.html" data-title="框架源码 — 简析学习 Retrofit" data-url="http://imxie.cc/hide/retrofit-source-learning.html" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"imxie"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://www.imxie.cc/js/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2019 做一件值得的事.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-80145821-1",'auto');ga('send','pageview');</script></body></html>