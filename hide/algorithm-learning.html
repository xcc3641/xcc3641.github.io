<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 数据结构和算法的个人路程 · IM XIE</title><meta name="description" content="数据结构和算法的个人路程 - 谢三弟"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://imxie.cc/atom.xml" title="IM XIE"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/xcc3641" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/WebLab/" target="_self" class="nav-list-link">WEBLAB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">数据结构和算法的个人路程</h1><div class="post-info">2016年5月17日</div><div class="post-content"><p>数据结构和算法一直都是自己的一个痛点。但是当自己沉下心，慢慢去学习或者复习的时候，反而开始体会到其中的一二乐趣。<br>我并不怎么聪慧，所以一点一点的开始学习。很多解法肯定不是最优的，以后功力足够再进行<strong>优化</strong>。</p>
<p>这篇是自己的学习算法的路程。<br>最基本的我不会过多阐述，一些思路和过程会通过注释的形式写出。</p>
<p>书籍阅读：</p>
<ul>
<li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="external">算法（第四版）</a></li>
<li><a href="https://book.douban.com/subject/6966465/" target="_blank" rel="external">剑指 Offer</a></li>
<li><a href="https://book.douban.com/subject/6424904/" target="_blank" rel="external">大话数据结构</a></li>
</ul>
<a id="more"></a>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><!-- toc -->
<ul>
<li><a href="#目录">目录</a></li>
<li><a href="#基本算法">基本算法</a><ul>
<li><a href="#二分查找">二分查找</a></li>
<li><a href="#简单选择排序">简单选择排序</a></li>
<li><a href="#直接插入排序">直接插入排序</a></li>
<li><a href="#快速排序">快速排序</a></li>
</ul>
</li>
<li><a href="#题目">题目</a><ul>
<li><a href="#在-o1-时间删除链表结点">在 O(1) 时间删除链表结点</a></li>
<li><a href="#调整数组顺序使奇数位于偶数前面">调整数组顺序使奇数位于偶数前面</a></li>
<li><a href="#链表中倒数第k个结点">链表中倒数第k个结点</a></li>
<li><a href="#逆序链表">逆序链表</a></li>
<li><a href="#反转链表">反转链表</a></li>
<li><a href="#合并两个有序链表形成一个有序链表">合并两个有序链表形成一个有序链表</a></li>
</ul>
</li>
<li><a href="#高质量代码">高质量代码</a><ul>
<li><a href="#规范性">规范性</a></li>
<li><a href="#完整性">完整性</a></li>
<li><a href="#鲁棒性">鲁棒性</a></li>
</ul>
</li>
<li><a href="#额外读物">额外读物</a></li>
</ul>
<!-- tocstop -->
<h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边开始的 index</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边最后的 index</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> object 需要查找的数字</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> array 该数字容器</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> object, <span class="keyword">int</span> array[])</span> </span>&#123;</div><div class="line">    <span class="comment">// 找到这个数组中间 index</span></div><div class="line">    <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span> (array[middle] == object) &#123;</div><div class="line">        System.out.println(<span class="string">"找到这个数字的位置在:"</span> + middle);</div><div class="line">        <span class="comment">// array[middle] 大于需要查找的值</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[middle] &gt; object) &#123;</div><div class="line">        <span class="comment">// 故该值在 0 —-&gt; middle 这个区间</span></div><div class="line">        right = middle - <span class="number">1</span>;</div><div class="line">        <span class="comment">// 递归</span></div><div class="line">        find(<span class="number">0</span>, right, object, array);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 否则该值在 middle —-&gt; 最右 这个区间,递归</span></div><div class="line">        find(middle, right, object, array);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><ul>
<li><a href="(https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">维基百科</a>)</li>
</ul>
<blockquote>
<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</blockquote>
<p><img src="http://ww3.sinaimg.cn/large/72f96cbagw1f7m8q9nfhcg202s0ab755.gif" alt=""></p>
<ul>
<li>代码实现如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> size = data.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        <span class="keyword">int</span> min = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</div><div class="line">            <span class="comment">// 交换位置</span></div><div class="line">            <span class="keyword">if</span> (data[j] &lt; data[min]) &#123;</div><div class="line">                <span class="keyword">int</span> temp = data[j];</div><div class="line">                data[j] = data[min];</div><div class="line">                data[min] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">维基百科</a><blockquote>
<p><strong>插入排序</strong>（英语：Insertion Sort）是一种简单直观的<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="external">排序算法</a>。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<strong>插入排序</strong> 在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
</blockquote>
</li>
</ul>
<p>一般来说，<strong>插入排序</strong> 都采用in-place在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<p>如果<em>比较操作</em>的代价比<em>交换操作</em>大的话，可以采用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95" target="_blank" rel="external">二分查找法</a>来减少<em>比较操作</em>的数目。该算法可以认为是<strong>插入排序</strong>的一个变种，称为<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&amp;action=edit&amp;redlink=1" target="_blank" rel="external">二分查找插入排序</a>。</p>
<p><img src="http://ww4.sinaimg.cn/large/72f96cbagw1f7mfuov7c6g208c050q55.gif" alt=""></p>
<ul>
<li>代码实现如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">( <span class="keyword">int</span>[] arr )</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++ ) &#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j=i+<span class="number">1</span>; j&gt;<span class="number">0</span>; j-- ) &#123;</div><div class="line">            <span class="keyword">if</span>( arr[j-<span class="number">1</span>] &lt;= arr[j] )</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">int</span> temp = arr[j];</div><div class="line">            arr[j] = arr[j-<span class="number">1</span>];</div><div class="line">            arr[j-<span class="number">1</span>] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>算法概述 / 思路<br>快速排序一般基于递归实现。其思路是这样的：</p>
<ol>
<li>选定一个合适的值（理想情况中值最好，但实现中一般使用数组第一个值）, 称为 “枢轴”(pivot)。</li>
<li>基于这个值，将数组分为两部分，较小的分在左边，较大的分在右边。</li>
<li>可以肯定，如此一轮下来，这个枢轴的位置一定在最终位置上。</li>
<li>对两个子数组分别重复上述过程，直到每个数组只有一个元素。</li>
<li>排序完成。</li>
</ol>
<p><img src="http://ww1.sinaimg.cn/large/801b780agw1f7np89e4bfj207s05y0sy.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    qsort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (low &lt; high)&#123;</div><div class="line">        <span class="keyword">int</span> pivot=partition(arr, low, high);        <span class="comment">//将数组分为两部分</span></div><div class="line">        qsort(arr, low, pivot-<span class="number">1</span>);                   <span class="comment">//递归排序左子数组</span></div><div class="line">        qsort(arr, pivot+<span class="number">1</span>, high);                  <span class="comment">//递归排序右子数组</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> pivot = arr[low];     <span class="comment">//枢轴记录</span></div><div class="line">    <span class="keyword">while</span> (low&lt;high)&#123;</div><div class="line">        <span class="keyword">while</span> (low&lt;high &amp;&amp; arr[high]&gt;=pivot) --high;</div><div class="line">        arr[low]=arr[high];             <span class="comment">//交换比枢轴小的记录到左端</span></div><div class="line">        <span class="keyword">while</span> (low&lt;high &amp;&amp; arr[low]&lt;=pivot) ++low;</div><div class="line">        arr[high] = arr[low];           <span class="comment">//交换比枢轴小的记录到右端</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//扫描完成，枢轴到位</span></div><div class="line">    arr[low] = pivot;</div><div class="line">    <span class="comment">//返回的是枢轴的位置</span></div><div class="line">    <span class="keyword">return</span> low;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个快速排序算法可以说是最基本的快速排序，因为它并没有考虑任何输入数据。但是，我们很容易发现这个算法的缺陷：这就是在我们输入数据基本有序甚至完全有序的时候，这算法退化为冒泡排序，不再是 O(n㏒n)，而是 O(n^2) 了。</p>
<ul>
<li>更多可以参考<a href="http://flyingcat2013.blog.51cto.com/7061638/1281614" target="_blank" rel="external">用 Java 写算法之五：快速排序</a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3></li>
</ul>
<h4 id="在-O-1-时间删除链表结点"><a href="#在-O-1-时间删除链表结点" class="headerlink" title="在 O(1) 时间删除链表结点"></a>在 O(1) 时间删除链表结点</h4><blockquote>
<p>给定单向链表的头指针和一个结点指针，定义一个函数在 O(1) 时间删除该结点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deletNode</span><span class="params">(Node head, Node target)</span> </span>&#123;</div><div class="line">        <span class="comment">// 先判空</span></div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || target == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不能为空"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 如果要删除的不是尾结点 此时时间复杂度 O(1)</span></div><div class="line">        <span class="comment">// 我觉得这里的思路很好，直接把下一个结点内容覆盖目标结点，不用遍历</span></div><div class="line">        <span class="keyword">if</span> (target.next != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 找到 target 结点的下一个结点 next</span></div><div class="line">            Node next = target.next;</div><div class="line">            <span class="comment">// 将 next 的值和指向都赋值给 target</span></div><div class="line">            target.value = next.value;</div><div class="line">            target.next = next.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 链表只有一个结点 删除头结点(同样是尾结点)</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (head == target) &#123;</div><div class="line">            <span class="comment">// 这里在 Java 引用传递的原因，如果要删除这种情况下的结点，需要有返回值。</span></div><div class="line">            <span class="comment">// 先这样的思路即可</span></div><div class="line">            head = target = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 多个结点 删除尾部结点</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            Node temp = head;</div><div class="line">            <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// 在当前结点的下一个结点是 target 的时候</span></div><div class="line">                <span class="keyword">if</span> (temp.next == target) &#123;</div><div class="line">                    <span class="comment">// 将当前结点的 next 指向 null 即可删除 target</span></div><div class="line">                    temp.next = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">                temp = temp.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h4><blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reOrderArray(<span class="keyword">int</span>[] array) &#123;</div><div class="line">    <span class="comment">// 这个方法比较笨</span></div><div class="line">    ArrayList&lt;Integer&gt; oddList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">    ArrayList&lt;Integer&gt; evenList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> anArray : array) &#123;</div><div class="line">        <span class="keyword">if</span> (anArray % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// 偶数</span></div><div class="line">            evenList.add(anArray);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 奇数</span></div><div class="line">            oddList.add(anArray);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"奇数:"</span>+oddList.size());</div><div class="line">    System.out.println(<span class="string">"偶数:"</span>+evenList.size());</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oddList.size(); i++) &#123;</div><div class="line">        array[i] = oddList.get(i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oddList.size(); i &lt; evenList.size() + oddList.size(); i++)&#123;</div><div class="line">        array[i] = evenList.get(i-oddList.size());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h4><blockquote>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="comment">// 利用栈的先进后出特性</span></div><div class="line">    Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</div><div class="line">    <span class="comment">// 判空</span></div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="comment">// 依次入栈</span></div><div class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">        stack.push(head);</div><div class="line">        head = head.next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 判断临界值</span></div><div class="line">    <span class="keyword">if</span> (k &gt; stack.size()) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</div><div class="line">        stack.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> stack.pop();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接受老司机指导，推荐用快慢指针（记住这个经典的方法）来做这个问题，自己下来用代码实现了下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findKthToTail2</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="comment">// 两个指针的经典问题 找到倒数第 K 个 我们可以将 after 指针慢 first K 个结点</span></div><div class="line">    <span class="comment">// 当 first == null 的时候 此时 after 就是倒数第 K 个了</span></div><div class="line">    ListNode first;</div><div class="line">    ListNode after = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    first = head;</div><div class="line">    <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;</div><div class="line">        count++;</div><div class="line">        <span class="keyword">if</span> (count &gt;= k) &#123;</div><div class="line">            after = head;</div><div class="line">            head = head.next;</div><div class="line">        &#125;</div><div class="line">        first = first.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> after;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="逆序链表"><a href="#逆序链表" class="headerlink" title="逆序链表"></a>逆序链表</h4><blockquote>
<p>输入一个链表的头结点，从尾到头打印每个结点的值</p>
</blockquote>
<p>最开始我很容易想到是用栈。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (listNode == <span class="keyword">null</span>) <span class="keyword">return</span>;</div><div class="line">	Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</div><div class="line">	<span class="comment">// 尾巴就是 node.next == null</span></div><div class="line">	<span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</div><div class="line">		stack.push(listNode.val);</div><div class="line">		listNode = listNode.next;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span> (!stack.isEmpty()) &#123;</div><div class="line">		System.out.println(stack.pop());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>后来想了下，递归的本质就是栈的结构，所以可以用递归来：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printListFromTailToHead2</span><span class="params">(ListNode listNode)</span></span>&#123;</div><div class="line">	<span class="comment">// 递归的方式</span></div><div class="line">	<span class="keyword">if</span> (listNode!=<span class="keyword">null</span>)&#123;</div><div class="line">		<span class="keyword">if</span> (listNode.next!=<span class="keyword">null</span>)&#123;</div><div class="line">			printListFromTailToHead2(listNode.next);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	System.out.println(listNode.val);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><blockquote>
<p>输入一个链表，反转链表后，输出链表的所有元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">    <span class="comment">//当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点</span></div><div class="line">    <span class="comment">// pre --&gt; head --&gt; next1 --&gt; next2</span></div><div class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    ListNode pre = <span class="keyword">null</span>;</div><div class="line">    ListNode next = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 先暂存 当前结点(head) 的下一个结点 next</span></div><div class="line">        next = head.next;</div><div class="line">        <span class="comment">// 然后将 当前结点(head) 的下一个结点指向上一个结点 pre</span></div><div class="line">        head.next = pre;</div><div class="line">        <span class="comment">// 因为遍历,下一轮中的结点的上一个结点就是当前结点</span></div><div class="line">        pre = head;</div><div class="line">        <span class="comment">// 然后把暂存的结点赋值给当前结点,让遍历继续</span></div><div class="line">        head = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pre;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="合并两个有序链表形成一个有序链表"><a href="#合并两个有序链表形成一个有序链表" class="headerlink" title="合并两个有序链表形成一个有序链表"></a>合并两个有序链表形成一个有序链表</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">merge</span><span class="params">(Node list1, Node list2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (list1 == <span class="keyword">null</span>) <span class="keyword">return</span> list2;</div><div class="line">    <span class="keyword">if</span> (list2 == <span class="keyword">null</span>) <span class="keyword">return</span> list1;</div><div class="line">    Node mergeHead = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (list1.value &lt; list2.value) &#123;</div><div class="line">        mergeHead = list1;</div><div class="line">        mergeHead.next = merge(list1.next, list2);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mergeHead = list2;</div><div class="line">        mergeHead.next = merge(list1, list2.next);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mergeHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里用到了递归，首先我们会找到一个头结点，进行同样的判断递归合并排序。</p>
<h3 id="高质量代码"><a href="#高质量代码" class="headerlink" title="高质量代码"></a>高质量代码</h3><h4 id="规范性"><a href="#规范性" class="headerlink" title="规范性"></a>规范性</h4><ul>
<li>书写清晰</li>
<li>布局清晰</li>
<li>命名合理</li>
</ul>
<h4 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h4><ul>
<li>完成基本功能</li>
<li>考虑边界条件</li>
<li>做好错误处理</li>
</ul>
<h4 id="鲁棒性"><a href="#鲁棒性" class="headerlink" title="鲁棒性"></a>鲁棒性</h4><ul>
<li>采取防御式编程</li>
<li>处理无效的输入</li>
</ul>
<h3 id="额外读物"><a href="#额外读物" class="headerlink" title="额外读物"></a>额外读物</h3><ul>
<li><a href="http://www.jianshu.com/p/99bac69fdd97" target="_blank" rel="external">算法时间复杂度计算</a></li>
</ul></div></article></div></section><footer><div class="paginator"></div><div data-thread-key="hide/algorithm-learning.html" data-title="数据结构和算法的个人路程" data-url="http://imxie.cc/hide/algorithm-learning.html" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"imxie"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://www.imxie.cc/js/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2019 做一件值得的事.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-80145821-1",'auto');ga('send','pageview');</script></body></html>