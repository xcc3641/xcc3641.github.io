<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> RxJava 线程切换源码的一些体会和思考 · IM XIE</title><meta name="description" content="RxJava 线程切换源码的一些体会和思考 - 谢三弟"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://imxie.cc/atom.xml" title="IM XIE"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/xcc3641" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/WebLab/" target="_self" class="nav-list-link">WEBLAB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">RxJava 线程切换源码的一些体会和思考</h1><div class="post-info">2016年12月25日</div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>RxJava 是在今年年初的时候上的车，接触也快要满一年了。从最初只知道几个操作符，写写 Demo ，或者跟着别人的项目和经验依葫芦画瓢，到目前终于有点初窥门径的地步。</p>
<p>RxJava 对于 Android 来说，最直观地便利就在于线程切换。所以本篇内容就是学习 <strong>RxJava 是如何实现切换线程</strong>。</p>
<p><strong>希望读者阅读此篇文章，是有用过 RxJava 的童鞋。</strong></p>
<blockquote>
<p>本章内容基于源码版本</p>
<p><strong>RxJava: 1.2.4</strong></p>
</blockquote>
<a id="more"></a>
<blockquote>
<ul>
<li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li>
<li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li>
<li>作者：<a href="https://github.com/xcc3641" target="_blank" rel="external">谢三弟</a></li>
<li>审阅者：<ul>
<li><a href="https://github.com/yongyu0102" target="_blank" rel="external">用语</a></li>
<li><a href="https://github.com/jasonim" target="_blank" rel="external">JasonThink</a></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#目录">目录</a></li>
<li><a href="#前言">前言</a></li>
<li><a href="#切换">切换</a><ul>
<li><a href="#SubscribeOn">SubscribeOn</a></li>
<li><a href="#ObserveOn">ObserveOn</a></li>
<li><a href="#共用时各自的作用域">共用时各自的作用域</a></li>
</ul>
</li>
<li><a href="#思考">思考</a></li>
<li><a href="#参考">参考</a></li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>答案我会放在文章末尾</strong></p>
<p>先来一道开胃菜：</p>
<p>指出下列程序操作符所运行的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable.just() <span class="comment">//1</span></div><div class="line">          .subscribeOn(Schedulers.newThread())</div><div class="line">          .map() <span class="comment">//2</span></div><div class="line">          .subscribeOn(Schedulers.io())</div><div class="line">          .map() <span class="comment">//3</span></div><div class="line">          .observeOn(Schedulers.computation())</div><div class="line">          .map() <span class="comment">//4</span></div><div class="line">          .observeOn(Schedulers.newThread())</div><div class="line">          .subscribe() <span class="comment">//5</span></div></pre></td></tr></table></figure>
<hr>
<p>开胃菜就到上面结束，如果你能够清楚明白每个操作运行的线程，说明对于 RxJava 的线程切换的理解很正确。</p>
<p>再具体分析 RxJava 是如何线程切换的，希望能清楚以下几个 RxJava 中名词的意思。</p>
<ul>
<li>Create()</li>
<li>OnSubscribe</li>
<li>Operator</li>
</ul>
<p><em>如果你特别明白这几个 RxJava 类/方法的作用，可以直接跳过看<a href="#切换">切换</a>这部分。</em></p>
<ol>
<li><p>Create()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns an Observable that will execute the specified function when a &#123;<span class="doctag">@link</span> Subscriber&#125; subscribes to</span></div><div class="line"><span class="comment"> * it.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法注释上说明，当订阅者订阅之后，该函数会返回将会执行具体功能的流。<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Operators.html" target="_blank" rel="external">操作符</a>进入源码会发现他们最终都会调用到 <code>create()</code> 函数。</p>
</li>
<li><p>OnSubscribe</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Invoked when Observable.subscribe is called.</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the output value type</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action1</span>&lt;<span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>首先我们知道这是一个继承 <code>Action1</code> 的接口，并且是在 <code>Observable.subscribe</code> 流进行订阅操作后回调。而且回顾刚刚 <code>create()</code> 源码中也发现参数就是这个 <code>OnSubscribe</code> 。 <code>Action</code> 的作用就是执行其中的 <code>call()</code> 方法。</p>
<p><strong>Observable.OnSubscribe</strong> 有点像 Todo List ，里面都是一个一个待处理的事务，并且这个 List 是有序的（这个很关键）。</p>
</li>
<li><p>Operator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operator</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Func1</span>&lt;<span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">R</span>&gt;, <span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line">  <span class="comment">// cover for generics insanity</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单来说它的职责就是将一个 <code>Subscriber</code> 变成另外一个 <code>Subscriber</code>。</p>
</li>
</ol>
<h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>上面知识点是一些小铺垫，因为后面的内容核心其实就是上面几个类的作用。</p>
<h4 id="SubscribeOn"><a href="#SubscribeOn" class="headerlink" title="SubscribeOn"></a>SubscribeOn</h4><p>追踪这个方法，核心是在这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Scheduler scheduler;</div><div class="line">    <span class="keyword">final</span> Observable&lt;T&gt; source;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatorSubscribeOn</span><span class="params">(Observable&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.scheduler = scheduler;</div><div class="line">        <span class="keyword">this</span>.source = source;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我先贴出这个类的，构造方法和成员变量，因为很重要，我们先把<strong>前因</strong>弄清楚。</p>
<p>首先我们发现这个类是实现了 <code>OnSubscribe</code> 接口，之前复习到这个的作用就是在该流被订阅之后执行 <code>call()</code> 方法，这里面就是<strong>后果</strong>，待会我们来看。</p>
<p>前因其实很简单，就是传入两个参数：</p>
<ol>
<li><p>一个是 <code>Scheduler</code> ，调度器，它的具体实现在 <code>Schedulers</code> 里。</p>
</li>
<li><p><code>Observable&lt;T&gt; source</code> 这个其实就是当前这个流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</div><div class="line">    <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> create(<span class="keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>接下来看看 <code>call()</code> 核心代码里做的事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 因为是 OnSubscribe 类，这里 call() 中传入的参数是 Observable.subscribe(s) 中的 s</span></div><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">     	<span class="comment">// 根据传入的调度器，创建一个 Worker 对象 inner</span></div><div class="line">       <span class="keyword">final</span> Worker inner = scheduler.createWorker();</div><div class="line">       subscriber.add(inner);</div><div class="line"></div><div class="line">     	<span class="comment">// 在 Worker 对象 inner 中执行（意思就是，在我们指定的调度器创建的线程中运行）</span></div><div class="line">       inner.schedule(<span class="keyword">new</span> Action0() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">final</span> Thread t = Thread.currentThread();</div><div class="line"></div><div class="line">             	<span class="comment">// 对订阅者包装</span></div><div class="line">               Subscriber&lt;T&gt; s = <span class="keyword">new</span> Subscriber&lt;T&gt;(subscriber) &#123;</div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                       subscriber.onNext(t);</div><div class="line">                   &#125;</div><div class="line">                   ······</div><div class="line">               &#125;;</div><div class="line"></div><div class="line">             	<span class="comment">// 这一句位置很关键</span></div><div class="line">             	<span class="comment">// 首先 source 是之前传入的流（也就是当前流），在 Worker 内部进行了订阅操作，所以该流所有操作都执行在其中</span></div><div class="line">               source.unsafeSubscribe(s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>通过我们指定的调度器，创建好 Worker ，之前传入的流在 Worker 内部，对重新包裹的 subscriber 进行订阅操作。</p>
<p>所以 <code>SubscribeOn()</code>最关键的地方其实是因为这行代码在调度器创建的 Worker 的 <code>call()</code> 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">source.unsafeSubscribe(s);</div></pre></td></tr></table></figure>
<p>总结：</p>
<blockquote>
<p><code>subscribeOn</code> 其实是改变了调用前序列所运行的线程。</p>
</blockquote>
<h4 id="ObserveOn"><a href="#ObserveOn" class="headerlink" title="ObserveOn"></a>ObserveOn</h4><p>同样的方法来分析，最终的回调会到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</div><div class="line">    <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> lift(<span class="keyword">new</span> OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实看到关键字 lift 和 operator 就大约可以猜到是做什么的了。</p>
<p>接下来我们进入到 <code>OperatorObserveOn</code> 类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Operator</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler scheduler;</div><div class="line">  	<span class="comment">// 省略不必要的代码</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(Subscriber&lt;? <span class="keyword">super</span> T&gt; child) &#123;</div><div class="line">        	<span class="comment">// 省略 ···</span></div><div class="line">            ObserveOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);</div><div class="line">            parent.init();</div><div class="line">            <span class="keyword">return</span> parent;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们首先会注意到它是一个 <code>Operator</code> ，并且没有对上层 Observale 做任何修改和包装。那么它的作用就是将一个 <code>Subscriber</code> 变成另外一个 <code>Subscriber</code>。所以接下来我们的首要任务就是看转换后的 <code>Subscriber</code> 做了什么改变。</p>
<p>关键代码在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ObserveOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);</div><div class="line">parent.init();</div></pre></td></tr></table></figure>
<p><strong>child</strong> 是改变前的 <code>Subscriber</code> ，最后返回了 <strong>parent</strong> 。</p>
<p>我们发现 <code>ObserveOnSubscriber</code> 同样也是一个 <code>Subscriber</code> 类，所以肯定含有 <code>onNext/onError/onComplete</code> 这三个标准方法，重要的肯定是 <code>onNext</code> ，所以我只贴上了该类三个有关函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">    Subscriber&lt;? <span class="keyword">super</span> T&gt; localChild = child;</div><div class="line"></div><div class="line">    localChild.setProducer(<span class="keyword">new</span> Producer() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0L</span>) &#123;</div><div class="line">                BackpressureUtils.getAndAddRequest(requested, n);</div><div class="line">              	<span class="comment">// 执行</span></div><div class="line">                schedule();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// recursiveScheduler 这个是构造函数时传入调度器创建的 worker</span></div><div class="line">    localChild.add(recursiveScheduler);</div><div class="line">    localChild.add(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (isUnsubscribed() || finished) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 条件判断里先将之前流的结果缓存进队列</span></div><div class="line">  <span class="keyword">if</span> (!queue.offer(on.next(t))) &#123;</div><div class="line">    onError(<span class="keyword">new</span> MissingBackpressureException());</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 执行</span></div><div class="line">  schedule();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (counter.getAndIncrement() == <span class="number">0</span>) &#123;</div><div class="line">      	<span class="comment">// 在当前 worker 上执行该类的 call 方法</span></div><div class="line">		recursiveScheduler.schedule(<span class="keyword">this</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>call()</code> 方法有点冗长，做的事情其实很简单，就是取出我们缓存之前流的所有值，然后在 Worker 工作线程中传下去。</p>
<p>总结：</p>
<blockquote>
<ol>
<li>ObserveOn 不会关心之前的流的线程</li>
<li>ObserveOn 会先将之前的流的值缓存起来，然后再在指定的线程上，将缓存推送给后面的 <code>Subscriber</code></li>
</ol>
</blockquote>
<h4 id="共用时各自的作用域"><a href="#共用时各自的作用域" class="headerlink" title="共用时各自的作用域"></a>共用时各自的作用域</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable.just() <span class="comment">//1</span></div><div class="line">           .subscribeOn(Schedulers.newThread())</div><div class="line">           .map() <span class="comment">//2</span></div><div class="line">           .map() <span class="comment">//3</span></div><div class="line">           .observeOn(Schedulers.computation())</div><div class="line">           .map() <span class="comment">//4</span></div><div class="line">           .observeOn(Schedulers.newThread())</div><div class="line">           .subscribe() <span class="comment">//5</span></div></pre></td></tr></table></figure>
<p>如果分析这个流各个操作符的执行线程，我们先把第一个 <code>subscribeOn()</code> 之前和第一个 <code>observeOn()</code> 之前的 Todo Items 找出来然后求并集：</p>
<p>得到的结果就是 <code>subscribeOn()</code> 的作用域。</p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVagw1fb80zs48yrj30yc0fcwg4.jpg" alt=""></p>
<p>之后的线程切换简单了，遇到 <code>observeOn()</code> 就切换一次。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="为什么subscribeOn-只有第一次调用生效？"><a href="#为什么subscribeOn-只有第一次调用生效？" class="headerlink" title="为什么subscribeOn 只有第一次调用生效？"></a>为什么<code>subscribeOn</code> 只有第一次调用生效？</h4><p>我的理解如下：</p>
<p><code>subscribeOn</code> 的作用域就是调用前序列中所有的 <strong>Todo List 任务清单</strong>（Observable.OnSubscribe），当我们执行 <code>subscribe()</code> 时，这些任务清单就会执行在 <code>subscribeOn</code>  指定的工作线程，而第二个 <code>subscribeOn</code> 早就没有任务可做了，所以无法生效。</p>
<hr>
<p><em>知乎里这段说的比我专业：</em></p>
<blockquote>
<p>正像 StackOverflow 上那段描述的，整个 Observable 数据流工作起来是分为两个阶段（或者说是两个 lifecycle）：upstream 的 subscription-time 和 downstream 的 runtime。</p>
<p>subscription-time 的阶段，是为了发起和驱动数据流的启动，在内部实现上体现为 OnSubscribe 向上游的逐级调用（控制流向上游传递）。支持 backpressure 的 producer request 也属于这个阶段。除了 producer request 的情况之外，subscription-time 阶段一般就是从下游到上游调用一次就结束了，最终到达生产者（以最上游的那个 OnSubscribe 来体现）。接下来数据流就开始向下游流动了。</p>
</blockquote>
<p><a href="https://www.zhihu.com/question/41779170" target="_blank" rel="external">Rxjava 中， subscribeOn 及 observeOn 方法切换线程发生的位置为什么设计为不同的？ - 知乎</a></p>
<h4 id="doOnSubscribe-的例外"><a href="#doOnSubscribe-的例外" class="headerlink" title="doOnSubscribe 的例外"></a>doOnSubscribe 的例外</h4><p>我们再改动下开胃菜的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable.just() <span class="comment">//1</span></div><div class="line">          .subscribeOn(Schedulers.newThread())</div><div class="line">          .map() <span class="comment">//2</span></div><div class="line">          .subscribeOn(Schedulers.io())</div><div class="line">          .map() <span class="comment">//3</span></div><div class="line">          .observeOn(Schedulers.computation())</div><div class="line">          .map() <span class="comment">//4</span></div><div class="line">          .doOnSubscribe() <span class="comment">//6</span></div><div class="line">          .observeOn(Schedulers.newThread())</div><div class="line">          .subscribe() <span class="comment">//5</span></div></pre></td></tr></table></figure>
<p>只添加了一行<code>.doOnSubscribe() //6</code> ，也是探讨这个操作符执行的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorDoOnSubscribe</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Operator</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Action0 subscribe;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatorDoOnSubscribe</span><span class="params">(Action0 subscribe)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.subscribe = subscribe;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; child) &#123;</div><div class="line">        <span class="comment">// 执行我们的 Action</span></div><div class="line">        subscribe.call();</div><div class="line">        <span class="comment">// Wrap 里面是包装成一个新的 Subscriber 返回，不对这个流做任何改变</span></div><div class="line">        <span class="keyword">return</span> Subscribers.wrap(child);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>doOnSubscribe 执行的线程其实就是 <code>subscribe.call();</code> 所在的线程。这里触发的时机就是，当我们进行 <code>Observable.subscribe()</code> 时，如果我们没有在紧接之后<code>SubscribeOn</code> 指定线程，那么它就会运行在默认线程，然后返回一个新的流。</p>
<hr>
<p><strong>关于 <code>doOnSubscribe()</code> 留一个问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable.just()</div><div class="line">          .doOnSubscribe() <span class="comment">// 1</span></div><div class="line">          .doOnSubscribe() <span class="comment">// 2</span></div><div class="line">          .subscribe()</div></pre></td></tr></table></figure>
<blockquote>
<p>问题是，对于 1 和 2 的执行顺序？</p>
</blockquote>
<p>在开发中，我们肯定不会像问题那样写代码，只是自己在看 doOnSubscribe 源码的时候，在问自己为什么它在其他操作符之前，拓展到了 RxJava 流的一个执行顺序，也是自己想要明白的地方。所以下次准备探讨学习。</p>
<blockquote>
<p>对了，老司机说 RxJava 很像洋葱，一层一层。</p>
</blockquote>
<p>进行分析学习的时候可以类比帮助理解。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://tomstechnicalblog.blogspot.jp/2016/02/rxjava-understanding-observeon-and.html" target="_blank" rel="external">Thomas Nield: RxJava- Understanding observeOn() and subscribeOn()</a></p>
<p><a href="http://blog.piasy.com/AdvancedRxJava/2016/09/16/subscribeon-and-observeon/" target="_blank" rel="external">SubscribeOn 和 ObserveOn |Piasy Blog</a></p>
<blockquote>
<p>答案：</p>
<p>1 newThread</p>
<p>2 newThread</p>
<p>3 newThread</p>
<p>4 computation</p>
<p>5 newThread</p>
</blockquote></div></article></div></section><footer><div class="paginator"><a href="/2016/12/31/the_end_of_2016/" class="prev">上一篇</a><a href="/2016/12/04/how_to_upload_your_project_to_jitpack/" class="next">下一篇</a></div><div data-thread-key="2016/12/25/how_the_rxjava_thread_work/" data-title="RxJava 线程切换源码的一些体会和思考" data-url="http://imxie.cc/2016/12/25/how_the_rxjava_thread_work/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"imxie"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://www.imxie.cc/js/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2019 做一件值得的事.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-80145821-1",'auto');ga('send','pageview');</script></body></html>