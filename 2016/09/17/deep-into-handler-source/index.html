<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 细致一点地看看 Handler 和它的伙伴们 · IM XIE</title><meta name="description" content="细致一点地看看 Handler 和它的伙伴们 - 谢三弟"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://imxie.cc/atom.xml" title="IM XIE"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/xcc3641" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/WebLab/" target="_self" class="nav-list-link">WEBLAB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">细致一点地看看 Handler 和它的伙伴们</h1><div class="post-info">2016年9月17日</div><div class="post-content"><p>Handler 对于 Android 开发来说简直就是家常便饭，它的原理自然都很熟悉，这篇文章不会宏观地去介绍它的原理，而是细节深入到各个组成。</p>
<a id="more"></a>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><!-- toc -->
<ul>
<li><a href="#目录">目录</a></li>
<li><a href="#关系">关系</a></li>
<li><a href="#分析">分析</a><ul>
<li><a href="#0x01">0x01</a></li>
<li><a href="#0x02">0x02</a></li>
<li><a href="#0x03">0x03</a></li>
<li><a href="#0x04">0x04</a></li>
</ul>
</li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考">参考</a></li>
</ul>
<!-- tocstop -->
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>开始深入细节的时候，我们可以先复习下 Handler 、Looper 和 MessageQueue 三者的关系。</p>
<ol>
<li>Handler 必须在 <code>Looper.prepare()</code> 之后才能创建使用</li>
<li>Looper 与当前线程关联，并且管理着一个 MessageQueue</li>
<li>Message 是实现 Parcelable 接口的类</li>
<li>以一个线程为基准，他们的数量级关系是：<br>Handler(N) <strong>:</strong> Looper(1) <strong>:</strong> MessageQueue(1) <strong>:</strong> Thread(1)</li>
</ol>
<p>他们的调用关系可以参考这张图：<br><img src="http://ww1.sinaimg.cn/large/7853084cgw1f7x2g6lzkbj20k60b9t9j.jpg" alt=""></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">    <span class="comment">// 代码省略</span></div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从 Handler 默认的构造函数我们可以看到，Handler 内部会通过 <code>Looper.myLooper()</code> 来获取 Looper 对象，从而与之关联。</p>
<h5 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h5><p>我们之前已经知道 Looper 管理着消息队列，从这里深入进去看看是如何跟 MessageQueue 建立联系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">        &#125;</div><div class="line">        sMainLooper = myLooper();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>Looper.myLooper()</code> 里我们看到，Looper 是通过 <code>sThreadLocal.get()</code> 来获取，那么我们又是何时将 Looper 设置给 sThreadLocal 的呢？答案就在 <code>prepare()</code> 方法里。<br>我们看到 <code>sThreadLocal.set(new Looper(quitAllowed));</code> 实例化了一个 Looper 对象给 sThreadLocal 并且一个线程只有一个 Looper 。</p>
<p>同时我也贴出了 <code>prepareMainLooper()</code> 方法，根据名字大家都可以猜到，这个方法就是在 Android 主线程(UI)线程调用的方法，而在这个方法里也调用了 <code>prepare(false)</code> 我们看到这里传入的是 false ，表明主线程这里的 Looper 是无法执行 <code>quit()</code> 方法。<br>我在这里贴出 ActivityThread 的 <code>Main()</code> 方法的部分代码，这也是我们程序的入口：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 代码省略</span></div><div class="line"></div><div class="line">    Looper.prepareMainLooper(); <span class="comment">// 创建消息循环 Looper</span></div><div class="line"></div><div class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">    thread.attach(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">        sMainThreadHandler = thread.getHandler(); <span class="comment">// UI 线程的 Handler</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</div><div class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></div><div class="line">                LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</div><div class="line">    &#125;</div><div class="line">    Looper.loop(); <span class="comment">// 执行消息循环</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里我们更清楚了为什么可以直接在主线程创建 Handler ，而不会发生异常。</p>
<p>以上，我们明白了 Looper 是通过 <code>prepare()</code> 方法与线程建立联系，同时不同线程是无法访问对方的消息队列。</p>
<blockquote>
<p>为什么 Handler 要在主线程创建才能更新 UI 呢？</p>
</blockquote>
<p>因为 Handler 要与主线程的消息队列关联上，这样 <code>handleMessage()</code> 才会执行在 UI 线程。</p>
<h5 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h5><p>Looper 的核心其实是它循环取出消息的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    <span class="comment">// 死循环</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/// Handler msg.target</span></div><div class="line">        msg.target.dispatchMessage(msg); <span class="comment">// 派发消息</span></div><div class="line"></div><div class="line">        <span class="comment">// 代码省略</span></div><div class="line"></div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面代码我们可以看到，Looper 在 <code>loop()</code> 方法里建立了一个死循环，通过消息队列里不断的取出消息，交给 Handler 去处理。</p>
<p>这个时候你可能会有一个问题：</p>
<blockquote>
<p>Android 中为什么主线程不会因为 Looper.loop() 里的死循环卡死？</p>
</blockquote>
<p>我比较推荐 <a href="https://www.zhihu.com/question/34652589/answer/90344494" target="_blank" rel="external">Gityuan 的回答</a></p>
<p>回到我们这里，在循环中是通过 <code>msg.target.dispatchMessage(msg);</code>  派发消息。其中 msg 是 Message 类型，简单看看它的成员：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</div><div class="line">    Handler target;</div><div class="line">    Runnable callback;</div><div class="line">    Message next;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Object obj;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg1;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg2;</div><div class="line"></div><div class="line">    <span class="comment">// 代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以知道消息队列是链表实现的，并且 target 是 Handler 类型。</p>
<p>现在就可以连通了，通过 Handler 将 Message 投递给消息队列（链表），<code>Looper.loop()</code> 循环从消息队列里取出消息，又将消息分发给 Handler 去处理。通过这个 target 我们也可以知道一个小细节，Handler 只能处理自己所发出的消息。</p>
<h5 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h5><p>理解清楚之后我们跟着顺序，看看 Handler 是如何处理和分发消息的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 处理消息方法，交给子类复写</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">    message.callback.run();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到 <code>dispatchMessage()</code> 只是一个分发方法，如果 Runnable 类型的 callback 为空，则执行 <code>handleMessage(msg)</code> 处理信息，该方法为空，是交给子类进行复写，并且执行线程是在 Handler 所创建的线程。<br>如果 callback 不为空，则会执行 <code>handleCallback(msg)</code> 来处理信息，该方法会调用 callback 的 <code>run()</code> 方法。</p>
<p>其实说简单一点，就是 Handler 的两种分发类型。<br>一种是 <code>post(r)</code> 另一种是 <code>sendMessage(msg)</code>。</p>
<p>我们具体看看这两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</div><div class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span></span>&#123;</div><div class="line">    Message m = Message.obtain();</div><div class="line">    m.callback = r;</div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">        delayMillis = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>; <span class="comment">// 与当前 Handler 绑定</span></div><div class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>做了一个导图，方便理解下：<br><img src="http://ww4.sinaimg.cn/large/7853084cgw1f7xsolnxzmj21kw0ihdh4.jpg" alt=""></p>
<p>从中我们可以看到，在 <code>post(r)</code> 时，会将 Runnable 包装成 Message 对象，并且赋值给 Message 的 callback 字段，最后跟 <code>sendMessage(msg)</code>  方法一样将消息插入队列。</p>
<p>根据代码和导图，无论是 <code>post(r)</code> 还是 <code>sendMessage(msg)</code> 都会最终调用 <code>sendMessageAtTime(msg,time)</code></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Handler 最终将消息追加到 MessageQueue 中，而 Looper 不断的从 MessageQueue 中读取消息，并且调用 Handler 的 dispatchMessage 分发消息，最后交给上层处理消息。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://book.douban.com/subject/26744163/" target="_blank" rel="external">Android 开发进阶 从小工到专家</a></li>
<li><a href="https://book.douban.com/subject/26599538/" target="_blank" rel="external">Android 开发艺术探索</a></li>
</ul></div></article></div></section><footer><div class="paginator"><a href="/2016/09/21/Review-Java-Thread-1/" class="prev">上一篇</a><a href="/2016/09/14/let-s-practise-custom-view/" class="next">下一篇</a></div><div data-thread-key="2016/09/17/deep-into-handler-source/" data-title="细致一点地看看 Handler 和它的伙伴们" data-url="http://imxie.cc/2016/09/17/deep-into-handler-source/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"imxie"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://www.imxie.cc/js/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2019 做一件值得的事.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-80145821-1",'auto');ga('send','pageview');</script></body></html>