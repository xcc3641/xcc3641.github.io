<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java 基础 —— 多线程（读书笔记）「二」 · IM XIE</title><meta name="description" content="Java 基础 —— 多线程（读书笔记）「二」 - 谢三弟"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="short icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://imxie.cc/atom.xml" title="IM XIE"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/xcc3641" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/WebLab/" target="_self" class="nav-list-link">WEBLAB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Java 基础 —— 多线程（读书笔记）「二」</h1><div class="post-info">2016年9月29日</div><div class="post-content"><p>第二章内容讲讲与多线程相关的方法—— Callable ， Future  和 FutureTask</p>
<a id="more"></a>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul>
<li><a href="#目录">目录</a></li>
<li><a href="#三个类的介绍">三个类的介绍</a><ul>
<li><a href="#Callable">Callable</a></li>
<li><a href="#Future">Future</a></li>
<li><a href="#FutureTask">FutureTask</a></li>
</ul>
</li>
<li><a href="#实例演示">实例演示</a></li>
<li><a href="#总结与参考">总结与参考</a></li>
</ul>
<h4 id="三个类的介绍"><a href="#三个类的介绍" class="headerlink" title="三个类的介绍"></a>三个类的介绍</h4><h5 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h5><p>Callable 与  Runnable 的功能大致相似，不同的是 Callable 是泛型接口，它有一个泛型参数 V ，该接口中有一个返回值「类型为 V 」的 <code>call()</code> 函数，而 Runnable 的 <code>run()</code> 函数是没有返回参数的。</p>
<p>Callable 的声明如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 泛型返回结果</span></div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h5><p>书中比喻 Runnable 与 Callable 就像『脱缰的野马』，无法控制。对于应用开发，我们需要『战马』，Future 就是这类『战马』的标准。</p>
<p>Future 为线程池制定了一个可管理的任务标准。提供了对 Runnable 或者 Callable 任务的执行结果进行取消，查询是否完成，获取结果，设置结果操作。</p>
<p>Future 的声明如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</div><div class="line">    <span class="comment">// 该任务是否被取消</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 该任务是否完成</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 获取结果，如果任务未完成，则等待，直到完成，因此该函数会阻塞</span></div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</div><div class="line">    <span class="comment">// 获取结果，如果任务未完成，则等待，直到 timeout 或者返回结果，该函数会阻塞</span></div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h5><p>Future 只是定义了一些规范的接口，而 FutureTask 是它的实现类。FutureTask 实现了 RunnableFuture<v> ，而 RunnableFuture 实现了 Runnable, Future<v> ，因此 FutureTask 具备了它们的能力。</v></v></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RunnableFuture 的定义如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>FutureTask 会像 Thread 一样对 Runnable 那样对 Runnable 和 Callable<v> 进行包装，是在 FutureTask 构造函数里注入：</v></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.callable = callable;</div><div class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</div><div class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面代码我们可以知道，如果传入的是 Runnable 会被 <code>Executors.callable()</code> 方法转化成 Callable 类型，可知， FutureTask 最终都是执行 Callable 类型的任务。</p>
<p>我们进入 <code>Executors.callable()</code> 函数，看看是如何适配转换的：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</div><div class="line">&#125;</div><div class="line"><span class="comment">// Runnable 的适配器，将 Runnable 转换成 Callable </span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> Runnable task;</div><div class="line">    <span class="keyword">final</span> T result;</div><div class="line">    RunnableAdapter(Runnable task, T result) &#123;</div><div class="line">        <span class="keyword">this</span>.task = task;</div><div class="line">        <span class="keyword">this</span>.result = result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        task.run();</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为 FutureTask 实现了 Runnable 接口，因此它可以通过 Thread 包装执行，也可以提交给 ExecuteService 来执行。<br>并且还可以直接通过<a href="#Future"> <code>get()</code> 方法</a>获取执行结果，该方法会阻塞，直到结果返回。<br>所以可以这样理解 <strong>FutureTask</strong> ： 既是 Runnable 又是 Future ，同时也包装了 Callable (如果是 Runnable 最终会转化成 Callable )。</p>
<h4 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</div><div class="line">	<span class="comment">// 线程池</span></div><div class="line">	<span class="keyword">static</span> ExecutorService mExecutorService = Executors.newSingleThreadExecutor();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			futureWithRunnable();</div><div class="line">			futureWithCallable();</div><div class="line">			futureTask();</div><div class="line">			</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 向线程池中提交 Runnable 对象</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureWithRunnable</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">		Future&lt;?&gt; rFuture = mExecutorService.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				fibc(<span class="number">20</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		System.out.println(<span class="string">"future result from runnable : "</span> + rFuture.get());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 提交 Callable 对象，</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureWithCallable</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">		Future&lt;Integer&gt; rFuture2 = mExecutorService.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">				<span class="keyword">return</span> fibc(<span class="number">20</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">		System.out.println(<span class="string">"future result from Callable : "</span> + rFuture2.get());</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 提交 FutureTask 对象</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">		FutureTask&lt;Integer&gt; mTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">				<span class="keyword">return</span> fibc(<span class="number">20</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		mExecutorService.submit(mTask);</div><div class="line"></div><div class="line">		System.out.println(<span class="string">"future result from futureTask : "</span> + mTask.get());</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 斐波那契数列 模拟耗时操作</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibc</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> fibc(num - <span class="number">1</span>) + fibc(num - <span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行之后，控制台的输出如下：</p>
<blockquote>
<p>future result from runnable : null<br>future result from Callable : 6765<br>future result from futureTask : 6765</p>
</blockquote>
<p><code>futureWithRunnable()</code> 方法中提交了一个 Runnable 对象，在 <code>run()</code> 方法里直接操作计算，这个方法没有返回值，所以 Future 对象 <code>get()</code> 拿到的值是 Null 。</p>
<p><code>futureWithCallable()</code> 方法里提交的是一个 Callable 对象<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</div></pre></td></tr></table></figure></p>
<p>Callable 实现的是 <code>V call()</code> 方法，最后会返回一个 Future 对象。</p>
<p><code>futureTask()</code>  则是一个  RunnableFuture<v> 既实现了 Runnable 又实现了 Future<v> 这两个接口。提交给 ExecutorService 执行后，可以通过返回的 Future 对象 <code>get()</code> 方法得到执行结果。</v></v></p>
<h4 id="总结与参考"><a href="#总结与参考" class="headerlink" title="总结与参考"></a>总结与参考</h4><p>本章内容是作为铺垫，了解和实践了会用到线程池中的三个类。之前我很少接触到，所以写了这篇文章用来加深印象和笔记翻阅。</p>
<ul>
<li><a href="https://book.douban.com/subject/26744163/" target="_blank" rel="external">Android 开发进阶 — 从小工到专家</a></li>
</ul></div></article></div></section><footer><div class="paginator"><a href="/2016/11/08/jike_Immersive_project/" class="prev">上一篇</a><a href="/2016/09/21/Review-Java-Thread-1/" class="next">下一篇</a></div><div data-thread-key="2016/09/29/Review-Java-Thread-2/" data-title="Java 基础 —— 多线程（读书笔记）「二」" data-url="http://imxie.cc/2016/09/29/Review-Java-Thread-2/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"imxie"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://www.imxie.cc/js/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2019 做一件值得的事.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-80145821-1",'auto');ga('send','pageview');</script></body></html>