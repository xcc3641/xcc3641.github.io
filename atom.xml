<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IM XIE</title>
  <icon>https://www.gravatar.com/avatar/9037e455789f91f6525e66dac3475e80</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://imxie.cc/"/>
  <updated>2017-08-11T03:02:07.000Z</updated>
  <id>http://imxie.cc/</id>
  
  <author>
    <name>谢三弟</name>
    <email>Hugo3641@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The End Of 2016</title>
    <link href="http://imxie.cc/2016/12/31/the_end_of_2016/"/>
    <id>http://imxie.cc/2016/12/31/the_end_of_2016/</id>
    <published>2016-12-31T15:23:23.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>因为自己的生日还蛮接近过年的，所以每次写年终，刚好是一个年岁。</p><p>今年开端那段时间是留在学校开发校园说吧，最后一天去公司撸了猫写了需求。有始有终还是挺好的。<br>重邮一月大家都寒假回家，团队留在学校开发，第一次踩在真正的雪上，南方孩子蛮容易因为这个幸福感动的吧。<br>记得那个时候自己的工位还是双屏，新垣结衣占据了一个大屏。<br>开学自己搬出去住了，在顶楼，是房东在屋顶花园改造的房子。所以，晚上的雨滴和飞禽的落脚都听得一清二楚。不过，一直都有的热水，不断电的电脑，不用再害怕晚归，还有一个大大的衣柜，比在寝室确实要自由很多。<br>窗台还养了多肉，生命力顽强的生物不用操心就长得不错。重庆春夏，雨季绵绵，得随时关窗，顶楼没有遮雨的棚子。现在回想才明白，生活的一些细节，是因为遭遇过，才知道。<br>还很喜欢出租屋的阳台，因为顶楼的关系，少有的高度看南山的天空，有时候蛮想变成天上半明半暗的云。<br>那里视野不错，拍下过最多的应该是黄昏时分，但不知道分享给谁，所以也删掉了很多。</p><p>从暑假开始到10月，蛮影响自己的人生轨迹吧，毕竟是对应届毕业生很重要的阶段。那段时间的故事其实在知乎回答 <a href="https://www.zhihu.com/question/34862853/answer/125319286" target="_blank" rel="external">21 岁的你在干嘛？找到了人生奋斗的目标了吗？</a> 写的差不多了。想要感叹的是，一直以来，觉得很幸运的是，所有都是自己的选择，所有的决定自己没有后悔。</p><p>来到上海后，没有再在哥哥那里借住，找了一个在浦东新区合租房，离公司的话，过了一个下穿后还是感觉蛮近的，唯一缺点是离地铁站有点两个公交站，不是很方便。如果可能的话，毕业后搬家吧。<br>房子里设备还是蛮新的，家电全齐，自己的单间中双人床和一个蛮大的衣柜，网上买了地毯和坐垫靠枕加上一个落地灯，组了一个角落，回来就可以窝在那里看书，觉得好赞，稍微有点生活的样子，以后会更好吧。</p><p>上海原来印象就是中国地图中右边沿海的一个城市，不至于大到哪里，踩在这片土地上后才知道，自己有多可笑。几个月下来，有点可惜的是，还不知道这个城市真正的魅力，自己才丈量了这座城市的十方一里。</p><p>还需要更多的时间，感受这张虚构的藏宝图。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>这年来，感觉最大的改变是学会了表达自己的感受和减少争论。</p><p>「做人不能太怂，把你的真诚，你的感受，你的想法一定要传达到。别犹豫不决，别傻逼怂蛋。」<br>言表是最难的事情，逃避只能让你的想法确实成为空想。<br>因为见过太多次对自己说的「算了吧」，向自己妥协与躲在自己的舒适区真是要了命。</p><blockquote><p>「去除头脑里的宗教，偏激，仇恨和鄙视。每次仇恨一个东西，你就失去了向它学习的机会。」</p></blockquote><p>这句话是王垠很久前的一篇文章说的，自己并非热衷粉丝或者抵触他的人。但这句话确实对我有所影响。大概我并不是那种偏执的人，所以会认可这句话。也是从这出发，开始明白和理解各有各的不同，毕竟世间没有万般通用的法子，生活中每个选择，都有当下的缘故。</p><p>之于感情，感触最深的是10月要去上海的时候，跟妹妹吃饭。她看着我说，「突然想起来，下次见你和图图都要用手数着日子了」。<br>内心一揪。</p><p>其实也明白这些情感越长大就越会习惯。但目前我只明白，二十来岁的自己，最难受的事情就是去拥抱再见，最害怕的还是去跨越搁在你我的时间。</p><p>但「一约既定，万山无阻」。</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>「如果你开发的应用你自己不经常用，那么你几乎不可能把它做好。」</p><p>其实在暑假后回校，这句话感觉就一直种下了。因为在根本不知道去做和该做什么的时候，这颗种子明确了自己的目标。<br>我想写个好的应用，去认真做好一个产品，去认识更多优秀的有理想的人，剩下的能争取到的就努力争取，即使争取不到，这个应用是你的人生中的一个勋章，它是你一段时间的故事，可以讲给别人听，你高兴的时候可以打开它，它一直存在；挫折沮丧的时候，可以看看用户们鼓励和支持的评论。<br>其实因为你的开发，已经对别人生活产生了细微的影响，这些都是你自己的成就和证明你存在意义的直观感受。</p><p>所以，一定要去开发自己喜欢的应用，让它变得更好，让越来越多的人喜欢。暗爽的同时一定要坚持。<br>毕竟正好年轻，正好自己可以尽微薄的能力，去做一些自己认为有价值的事情，不会后悔。</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>说一些对明年自己的期望。</p><p>16年觉得自己太过冷漠，什么都放得下又什么都不放不下。<br>人不应该沉溺于过去，但也最好不要太过豁达和释然。</p><p>看不惯自我怜悯，但是现今又觉得只有这个年龄还好意思拥有垂帘的悲情。<br>所以下次，我肯定会多抱一会。</p><p>得再相信自己是屠龙的勇士，左手有光，右手有剑，燃烧自己，让血沸腾。<br>即使没有公主，血别凉，心别死。</p><p>很多时候，欲速则不达，只要走在一条正确的路上，那就够了。<br>慢慢来，会很快。</p><p>要学会赚钱，钱不是俗物，是实现梦想的一个必需品。<br>但不能只知道赚钱，要看书，买了 Kindle 得利用。</p><p>踏实一点，永远不要失去好奇心。<br>想要的，都会有的。</p><p>永远得向前看，人生漫长，还有太多值得拥抱的事物等在前面。<br>在这璀璨人间。</p><p>最后还有提交代码之前，再想想看。(๑˙ー˙๑)。</p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1fbab9upsa7j31kw1kw4qp.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/large/006y8lVajw1fbb0e1w31jj316e0bg76s.jpg" alt=""></p><p>去岁一别，久疏问候。<br><strong>平安喜乐，万事胜意。</strong></p><p>再见，2016.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h2&gt;&lt;p&gt;因为自己的生日还蛮接近过年的，所以每次写年终，刚好是一个年岁。&lt;/p&gt;
&lt;p&gt;今年开端那段时间是留在学校开发校园说吧，最后一天去公司撸了猫写了需求。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RxJava 线程切换源码的一些体会和思考</title>
    <link href="http://imxie.cc/2016/12/25/how_the_rxjava_thread_work/"/>
    <id>http://imxie.cc/2016/12/25/how_the_rxjava_thread_work/</id>
    <published>2016-12-25T08:02:31.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>RxJava 是在今年年初的时候上的车，接触也快要满一年了。从最初只知道几个操作符，写写 Demo ，或者跟着别人的项目和经验依葫芦画瓢，到目前终于有点初窥门径的地步。</p><p>RxJava 对于 Android 来说，最直观地便利就在于线程切换。所以本篇内容就是学习 <strong>RxJava 是如何实现切换线程</strong>。</p><p><strong>希望读者阅读此篇文章，是有用过 RxJava 的童鞋。</strong></p><blockquote><p>本章内容基于源码版本</p><p><strong>RxJava: 1.2.4</strong></p></blockquote><a id="more"></a><blockquote><ul><li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li><li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li><li>作者：<a href="https://github.com/xcc3641" target="_blank" rel="external">谢三弟</a></li><li>审阅者：<ul><li><a href="https://github.com/yongyu0102" target="_blank" rel="external">用语</a></li><li><a href="https://github.com/jasonim" target="_blank" rel="external">JasonThink</a></li></ul></li></ul></blockquote><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#目录">目录</a></li><li><a href="#前言">前言</a></li><li><a href="#切换">切换</a><ul><li><a href="#SubscribeOn">SubscribeOn</a></li><li><a href="#ObserveOn">ObserveOn</a></li><li><a href="#共用时各自的作用域">共用时各自的作用域</a></li></ul></li><li><a href="#思考">思考</a></li><li><a href="#参考">参考</a></li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>答案我会放在文章末尾</strong></p><p>先来一道开胃菜：</p><p>指出下列程序操作符所运行的线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable.just() <span class="comment">//1</span></div><div class="line">          .subscribeOn(Schedulers.newThread())</div><div class="line">          .map() <span class="comment">//2</span></div><div class="line">          .subscribeOn(Schedulers.io())</div><div class="line">          .map() <span class="comment">//3</span></div><div class="line">          .observeOn(Schedulers.computation())</div><div class="line">          .map() <span class="comment">//4</span></div><div class="line">          .observeOn(Schedulers.newThread())</div><div class="line">          .subscribe() <span class="comment">//5</span></div></pre></td></tr></table></figure><hr><p>开胃菜就到上面结束，如果你能够清楚明白每个操作运行的线程，说明对于 RxJava 的线程切换的理解很正确。</p><p>再具体分析 RxJava 是如何线程切换的，希望能清楚以下几个 RxJava 中名词的意思。</p><ul><li>Create()</li><li>OnSubscribe</li><li>Operator</li></ul><p><em>如果你特别明白这几个 RxJava 类/方法的作用，可以直接跳过看<a href="#切换">切换</a>这部分。</em></p><ol><li><p>Create()</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns an Observable that will execute the specified function when a &#123;<span class="doctag">@link</span> Subscriber&#125; subscribes to</span></div><div class="line"><span class="comment"> * it.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>方法注释上说明，当订阅者订阅之后，该函数会返回将会执行具体功能的流。<a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Operators.html" target="_blank" rel="external">操作符</a>进入源码会发现他们最终都会调用到 <code>create()</code> 函数。</p></li><li><p>OnSubscribe</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Invoked when Observable.subscribe is called.</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the output value type</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Action1</span>&lt;<span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;&#125;</div></pre></td></tr></table></figure><p>首先我们知道这是一个继承 <code>Action1</code> 的接口，并且是在 <code>Observable.subscribe</code> 流进行订阅操作后回调。而且回顾刚刚 <code>create()</code> 源码中也发现参数就是这个 <code>OnSubscribe</code> 。 <code>Action</code> 的作用就是执行其中的 <code>call()</code> 方法。</p><p><strong>Observable.OnSubscribe</strong> 有点像 Todo List ，里面都是一个一个待处理的事务，并且这个 List 是有序的（这个很关键）。</p></li><li><p>Operator</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operator</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Func1</span>&lt;<span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">R</span>&gt;, <span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line">  <span class="comment">// cover for generics insanity</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>简单来说它的职责就是将一个 <code>Subscriber</code> 变成另外一个 <code>Subscriber</code>。</p></li></ol><h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>上面知识点是一些小铺垫，因为后面的内容核心其实就是上面几个类的作用。</p><h4 id="SubscribeOn"><a href="#SubscribeOn" class="headerlink" title="SubscribeOn"></a>SubscribeOn</h4><p>追踪这个方法，核心是在这个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Scheduler scheduler;</div><div class="line">    <span class="keyword">final</span> Observable&lt;T&gt; source;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatorSubscribeOn</span><span class="params">(Observable&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.scheduler = scheduler;</div><div class="line">        <span class="keyword">this</span>.source = source;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我先贴出这个类的，构造方法和成员变量，因为很重要，我们先把<strong>前因</strong>弄清楚。</p><p>首先我们发现这个类是实现了 <code>OnSubscribe</code> 接口，之前复习到这个的作用就是在该流被订阅之后执行 <code>call()</code> 方法，这里面就是<strong>后果</strong>，待会我们来看。</p><p>前因其实很简单，就是传入两个参数：</p><ol><li><p>一个是 <code>Scheduler</code> ，调度器，它的具体实现在 <code>Schedulers</code> 里。</p></li><li><p><code>Observable&lt;T&gt; source</code> 这个其实就是当前这个流。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</div><div class="line">    <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> create(<span class="keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>接下来看看 <code>call()</code> 核心代码里做的事情：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 因为是 OnSubscribe 类，这里 call() 中传入的参数是 Observable.subscribe(s) 中的 s</span></div><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">     <span class="comment">// 根据传入的调度器，创建一个 Worker 对象 inner</span></div><div class="line">       <span class="keyword">final</span> Worker inner = scheduler.createWorker();</div><div class="line">       subscriber.add(inner);</div><div class="line"></div><div class="line">     <span class="comment">// 在 Worker 对象 inner 中执行（意思就是，在我们指定的调度器创建的线程中运行）</span></div><div class="line">       inner.schedule(<span class="keyword">new</span> Action0() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">final</span> Thread t = Thread.currentThread();</div><div class="line"></div><div class="line">             <span class="comment">// 对订阅者包装</span></div><div class="line">               Subscriber&lt;T&gt; s = <span class="keyword">new</span> Subscriber&lt;T&gt;(subscriber) &#123;</div><div class="line">                   <span class="meta">@Override</span></div><div class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                       subscriber.onNext(t);</div><div class="line">                   &#125;</div><div class="line">                   ······</div><div class="line">               &#125;;</div><div class="line"></div><div class="line">             <span class="comment">// 这一句位置很关键</span></div><div class="line">             <span class="comment">// 首先 source 是之前传入的流（也就是当前流），在 Worker 内部进行了订阅操作，所以该流所有操作都执行在其中</span></div><div class="line">               source.unsafeSubscribe(s);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>通过我们指定的调度器，创建好 Worker ，之前传入的流在 Worker 内部，对重新包裹的 subscriber 进行订阅操作。</p><p>所以 <code>SubscribeOn()</code>最关键的地方其实是因为这行代码在调度器创建的 Worker 的 <code>call()</code> 中</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">source.unsafeSubscribe(s);</div></pre></td></tr></table></figure><p>总结：</p><blockquote><p><code>subscribeOn</code> 其实是改变了调用前序列所运行的线程。</p></blockquote><h4 id="ObserveOn"><a href="#ObserveOn" class="headerlink" title="ObserveOn"></a>ObserveOn</h4><p>同样的方法来分析，最终的回调会到：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</div><div class="line">    <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> lift(<span class="keyword">new</span> OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实看到关键字 lift 和 operator 就大约可以猜到是做什么的了。</p><p>接下来我们进入到 <code>OperatorObserveOn</code> 类中：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorObserveOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Operator</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Scheduler scheduler;</div><div class="line">  <span class="comment">// 省略不必要的代码</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(Subscriber&lt;? <span class="keyword">super</span> T&gt; child) &#123;</div><div class="line">        <span class="comment">// 省略 ···</span></div><div class="line">            ObserveOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);</div><div class="line">            parent.init();</div><div class="line">            <span class="keyword">return</span> parent;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们首先会注意到它是一个 <code>Operator</code> ，并且没有对上层 Observale 做任何修改和包装。那么它的作用就是将一个 <code>Subscriber</code> 变成另外一个 <code>Subscriber</code>。所以接下来我们的首要任务就是看转换后的 <code>Subscriber</code> 做了什么改变。</p><p>关键代码在</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ObserveOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);</div><div class="line">parent.init();</div></pre></td></tr></table></figure><p><strong>child</strong> 是改变前的 <code>Subscriber</code> ，最后返回了 <strong>parent</strong> 。</p><p>我们发现 <code>ObserveOnSubscriber</code> 同样也是一个 <code>Subscriber</code> 类，所以肯定含有 <code>onNext/onError/onComplete</code> 这三个标准方法，重要的肯定是 <code>onNext</code> ，所以我只贴上了该类三个有关函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">    Subscriber&lt;? <span class="keyword">super</span> T&gt; localChild = child;</div><div class="line"></div><div class="line">    localChild.setProducer(<span class="keyword">new</span> Producer() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (n &gt; <span class="number">0L</span>) &#123;</div><div class="line">                BackpressureUtils.getAndAddRequest(requested, n);</div><div class="line">              <span class="comment">// 执行</span></div><div class="line">                schedule();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// recursiveScheduler 这个是构造函数时传入调度器创建的 worker</span></div><div class="line">    localChild.add(recursiveScheduler);</div><div class="line">    localChild.add(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (isUnsubscribed() || finished) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 条件判断里先将之前流的结果缓存进队列</span></div><div class="line">  <span class="keyword">if</span> (!queue.offer(on.next(t))) &#123;</div><div class="line">    onError(<span class="keyword">new</span> MissingBackpressureException());</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 执行</span></div><div class="line">  schedule();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (counter.getAndIncrement() == <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// 在当前 worker 上执行该类的 call 方法</span></div><div class="line">recursiveScheduler.schedule(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>call()</code> 方法有点冗长，做的事情其实很简单，就是取出我们缓存之前流的所有值，然后在 Worker 工作线程中传下去。</p><p>总结：</p><blockquote><ol><li>ObserveOn 不会关心之前的流的线程</li><li>ObserveOn 会先将之前的流的值缓存起来，然后再在指定的线程上，将缓存推送给后面的 <code>Subscriber</code></li></ol></blockquote><h4 id="共用时各自的作用域"><a href="#共用时各自的作用域" class="headerlink" title="共用时各自的作用域"></a>共用时各自的作用域</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable.just() <span class="comment">//1</span></div><div class="line">           .subscribeOn(Schedulers.newThread())</div><div class="line">           .map() <span class="comment">//2</span></div><div class="line">           .map() <span class="comment">//3</span></div><div class="line">           .observeOn(Schedulers.computation())</div><div class="line">           .map() <span class="comment">//4</span></div><div class="line">           .observeOn(Schedulers.newThread())</div><div class="line">           .subscribe() <span class="comment">//5</span></div></pre></td></tr></table></figure><p>如果分析这个流各个操作符的执行线程，我们先把第一个 <code>subscribeOn()</code> 之前和第一个 <code>observeOn()</code> 之前的 Todo Items 找出来然后求并集：</p><p>得到的结果就是 <code>subscribeOn()</code> 的作用域。</p><p><img src="http://ww1.sinaimg.cn/large/006y8lVagw1fb80zs48yrj30yc0fcwg4.jpg" alt=""></p><p>之后的线程切换简单了，遇到 <code>observeOn()</code> 就切换一次。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="为什么subscribeOn-只有第一次调用生效？"><a href="#为什么subscribeOn-只有第一次调用生效？" class="headerlink" title="为什么subscribeOn 只有第一次调用生效？"></a>为什么<code>subscribeOn</code> 只有第一次调用生效？</h4><p>我的理解如下：</p><p><code>subscribeOn</code> 的作用域就是调用前序列中所有的 <strong>Todo List 任务清单</strong>（Observable.OnSubscribe），当我们执行 <code>subscribe()</code> 时，这些任务清单就会执行在 <code>subscribeOn</code>  指定的工作线程，而第二个 <code>subscribeOn</code> 早就没有任务可做了，所以无法生效。</p><hr><p><em>知乎里这段说的比我专业：</em></p><blockquote><p>正像 StackOverflow 上那段描述的，整个 Observable 数据流工作起来是分为两个阶段（或者说是两个 lifecycle）：upstream 的 subscription-time 和 downstream 的 runtime。</p><p>subscription-time 的阶段，是为了发起和驱动数据流的启动，在内部实现上体现为 OnSubscribe 向上游的逐级调用（控制流向上游传递）。支持 backpressure 的 producer request 也属于这个阶段。除了 producer request 的情况之外，subscription-time 阶段一般就是从下游到上游调用一次就结束了，最终到达生产者（以最上游的那个 OnSubscribe 来体现）。接下来数据流就开始向下游流动了。</p></blockquote><p><a href="https://www.zhihu.com/question/41779170" target="_blank" rel="external">Rxjava 中， subscribeOn 及 observeOn 方法切换线程发生的位置为什么设计为不同的？ - 知乎</a></p><h4 id="doOnSubscribe-的例外"><a href="#doOnSubscribe-的例外" class="headerlink" title="doOnSubscribe 的例外"></a>doOnSubscribe 的例外</h4><p>我们再改动下开胃菜的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable.just() <span class="comment">//1</span></div><div class="line">          .subscribeOn(Schedulers.newThread())</div><div class="line">          .map() <span class="comment">//2</span></div><div class="line">          .subscribeOn(Schedulers.io())</div><div class="line">          .map() <span class="comment">//3</span></div><div class="line">          .observeOn(Schedulers.computation())</div><div class="line">          .map() <span class="comment">//4</span></div><div class="line">          .doOnSubscribe() <span class="comment">//6</span></div><div class="line">          .observeOn(Schedulers.newThread())</div><div class="line">          .subscribe() <span class="comment">//5</span></div></pre></td></tr></table></figure><p>只添加了一行<code>.doOnSubscribe() //6</code> ，也是探讨这个操作符执行的线程。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorDoOnSubscribe</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Operator</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Action0 subscribe;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatorDoOnSubscribe</span><span class="params">(Action0 subscribe)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.subscribe = subscribe;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; child) &#123;</div><div class="line">        <span class="comment">// 执行我们的 Action</span></div><div class="line">        subscribe.call();</div><div class="line">        <span class="comment">// Wrap 里面是包装成一个新的 Subscriber 返回，不对这个流做任何改变</span></div><div class="line">        <span class="keyword">return</span> Subscribers.wrap(child);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>doOnSubscribe 执行的线程其实就是 <code>subscribe.call();</code> 所在的线程。这里触发的时机就是，当我们进行 <code>Observable.subscribe()</code> 时，如果我们没有在紧接之后<code>SubscribeOn</code> 指定线程，那么它就会运行在默认线程，然后返回一个新的流。</p><hr><p><strong>关于 <code>doOnSubscribe()</code> 留一个问题</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Observable.just()</div><div class="line">          .doOnSubscribe() <span class="comment">// 1</span></div><div class="line">          .doOnSubscribe() <span class="comment">// 2</span></div><div class="line">          .subscribe()</div></pre></td></tr></table></figure><blockquote><p>问题是，对于 1 和 2 的执行顺序？</p></blockquote><p>在开发中，我们肯定不会像问题那样写代码，只是自己在看 doOnSubscribe 源码的时候，在问自己为什么它在其他操作符之前，拓展到了 RxJava 流的一个执行顺序，也是自己想要明白的地方。所以下次准备探讨学习。</p><blockquote><p>对了，老司机说 RxJava 很像洋葱，一层一层。</p></blockquote><p>进行分析学习的时候可以类比帮助理解。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://tomstechnicalblog.blogspot.jp/2016/02/rxjava-understanding-observeon-and.html" target="_blank" rel="external">Thomas Nield: RxJava- Understanding observeOn() and subscribeOn()</a></p><p><a href="http://blog.piasy.com/AdvancedRxJava/2016/09/16/subscribeon-and-observeon/" target="_blank" rel="external">SubscribeOn 和 ObserveOn |Piasy Blog</a></p><blockquote><p>答案：</p><p>1 newThread</p><p>2 newThread</p><p>3 newThread</p><p>4 computation</p><p>5 newThread</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;RxJava 是在今年年初的时候上的车，接触也快要满一年了。从最初只知道几个操作符，写写 Demo ，或者跟着别人的项目和经验依葫芦画瓢，到目前终于有点初窥门径的地步。&lt;/p&gt;
&lt;p&gt;RxJava 对于 Android 来说，最直观地便利就在于线程切换。所以本篇内容就是学习 &lt;strong&gt;RxJava 是如何实现切换线程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;希望读者阅读此篇文章，是有用过 RxJava 的童鞋。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本章内容基于源码版本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RxJava: 1.2.4&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JitPack 指南</title>
    <link href="http://imxie.cc/2016/12/04/how_to_upload_your_project_to_jitpack/"/>
    <id>http://imxie.cc/2016/12/04/how_to_upload_your_project_to_jitpack/</id>
    <published>2016-12-04T08:02:31.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最初发布一些 lib 是用的 jCenter ，但是每次上传都跟玄学一样，就算我全局或者指定代理还是凭运气，后来问了老司机，结识了 <a href="https://jitpack.io/" target="_blank" rel="external">JitPack</a> ，体验更加方便和易懂。</p><a id="more"></a><blockquote><ul><li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li><li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li><li>作者：<a href="https://github.com/xcc3641" target="_blank" rel="external">谢三弟</a></li><li>审阅者：<a href="https://github.com/JoeSteven" target="_blank" rel="external">JoeSteven</a></li></ul></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="账号"><a href="#账号" class="headerlink" title="账号"></a>账号</h4><ol><li>首先进入网页我们看到是：</li></ol><p><img src="http://ww2.sinaimg.cn/large/006y8lVagw1faer45z2g0j31kw12542t.jpg" alt=""></p><p>然后我们进行账号登陆，默认是跟 Github 绑定的。</p><ol><li>成功之后网站会读取你的 repo 显示在左侧：</li></ol><p><img src="http://ww4.sinaimg.cn/large/006y8lVagw1faer6xve2gj31kw10itbq.jpg" alt=""></p><h4 id="Gradle-配置"><a href="#Gradle-配置" class="headerlink" title="Gradle 配置"></a>Gradle 配置</h4><ol><li>首先在你的 root build.gradle 添加：</li></ol><figure class="highlight gradle"><table><tr><td class="code"><pre><div class="line"><span class="keyword">buildscript</span> &#123;</div><div class="line">    <span class="keyword">repositories</span> &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">dependencies</span> &#123;</div><div class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:2.2.2'</span></div><div class="line">        <span class="keyword">classpath</span> <span class="string">'com.github.dcendents:android-maven-gradle-plugin:1.5'</span> <span class="comment">// 这一栏</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>接下来在你的 Lib build.gradle 添加：</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">group = &apos;com.github.&lt;username&gt;&apos; // 最好是你的 github 名字</div><div class="line"></div><div class="line">// 指定编码</div><div class="line">tasks.withType(JavaCompile) &#123;</div><div class="line">    options.encoding = &quot;UTF-8&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 打包源码</div><div class="line">task sourcesJar(type: Jar) &#123;</div><div class="line">    from android.sourceSets.main.java.srcDirs</div><div class="line">    classifier = &apos;sources&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">artifacts &#123;</div><div class="line">    archives sourcesJar</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>配置完成后，将你的项目 push 到 github</li><li>点击 Releases 编写好之后发布，回到 JitPack</li></ol><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><ol><li>根据你的 group/Lib 搜索你的裤子。</li></ol><p><img src="http://ww3.sinaimg.cn/large/006y8lVagw1faerh75xvtj30yu0o8ta9.jpg" alt=""></p><ol><li>点击 <strong>get it</strong></li></ol><p><img src="http://ww2.sinaimg.cn/large/006y8lVagw1faerhpbkemj318u0v0gpe.jpg" alt=""></p><p>别人就可以用到你写的裤子了 (๑•̀ㅂ•́) ✧</p><ol><li>更新裤子</li></ol><p>更新你的裤子，用上述同样的方法。</p><p>不过在你完成发布新版的时候，最好删除原来的 Tag 。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>全文以 <a href="https://github.com/xcc3641/Watcher" target="_blank" rel="external">Watcher: Help to watch the fps and used memory of your app</a> 为实践，如果有疑问可以参考该项目模仿配置。</p><ul><li><a href="https://jitpack.io" target="_blank" rel="external">JitPack</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最初发布一些 lib 是用的 jCenter ，但是每次上传都跟玄学一样，就算我全局或者指定代理还是凭运气，后来问了老司机，结识了 &lt;a href=&quot;https://jitpack.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JitPack&lt;/a&gt; ，体验更加方便和易懂。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>沉浸式适配个人总结</title>
    <link href="http://imxie.cc/2016/11/08/jike_Immersive_project/"/>
    <id>http://imxie.cc/2016/11/08/jike_Immersive_project/</id>
    <published>2016-11-08T08:02:31.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结适配项目中遇到的沉浸式的坑和个人的解决方案。</p><a id="more"></a><blockquote><ul><li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li><li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li><li>作者：<a href="https://github.com/xcc3641" target="_blank" rel="external">谢三弟</a></li><li>审阅者：<a href="https://github.com/laobie" target="_blank" rel="external">Jaeger</a></li></ul></blockquote><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#目录">目录</a></li><li><a href="#前言">前言</a></li><li><a href="#适配">适配</a><ul><li><a href="#标志">标志</a></li><li><a href="#布局">布局</a></li><li><a href="#修补">修补</a></li><li><a href="#坑">坑</a></li></ul></li><li><a href="#源码">源码</a><ul><li><a href="#状态栏工具部分核心代码">状态栏工具部分核心代码</a></li><li><a href="#环境工具类部分核心代码">环境工具类部分核心代码</a></li><li><a href="#修复全屏输入框工具类">修复全屏输入框工具类</a></li></ul></li><li><a href="#总结">总结</a></li><li><a href="#参考">参考</a></li></ul><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>本篇文章环境是</p><ul><li>主色调：<strong>白色</strong></li><li>右滑返回：<strong>需要</strong></li></ul></blockquote><p>在做沉浸式之前，得知道下面几个问题：</p><ol><li>什么是沉浸式</li><li>Android 系统对沉浸式的支持</li></ol><p>首先第一个问题，推荐阅读这篇 <a href="http://www.jianshu.com/p/f3683e27fd94" target="_blank" rel="external">Android 沉浸式 UI 实现及原理</a> ，作者对照哔哩哔哩进行分析「个人也认为 B 站在国内 Android 应用里算规范」。</p><p>第二个问题，也是个人在适配沉浸式过程中遇到的版本坑，大致总结如下：</p><ul><li>Android 4.4（19）以下</li><li>Android 4.4（19）</li><li>「小米 MIUI V4 」和「魅族 Flyme 4.0」以上</li><li>Android 5.0 （21）</li><li>Android 6.0+（23+）</li></ul><p>因为 Android 是从 4.4 开始引入 <code>android:windowTranslucentStatus</code> 标签，所以理论上 4.4 以上都可以实现沉浸式，而本方案也是基于 4.4 开始。</p><p>因为<strong>即刻</strong>的主色调是<strong>纯白色</strong>，在 Android 里纯白是 BUG 的存在，适配需要做更多对于<strong>状态栏 icon 颜色</strong>的处理。<br>收集资料可以参考：</p><ul><li><a href="http://www.jianshu.com/p/2756d41e9697" target="_blank" rel="external">Android 状态栏黑色字体</a></li><li><a href="http://blog.isming.me/2016/01/09/chang-android-statusbar-text-color/" target="_blank" rel="external">Android 系统更改状态栏字体颜色</a></li><li><a href="http://www.jianshu.com/p/7f5a9969be53" target="_blank" rel="external">白底黑字！Android 浅色状态栏黑色字体模式</a></li><li><a href="http://open-wiki.flyme.cn/index.php?title=Flyme%E7%B3%BB%E7%BB%9FAPI" target="_blank" rel="external">Flyme 系统 API-沉浸式状态栏</a></li></ul><p>按照刚才列出的版本，整理注意的细节如图：</p><p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f9jzc1kxcwj31kw0e5n01.jpg" alt=""></p><p>关于小米 OS 和魅族 OS 可以参考维基百科：</p><ul><li><a href="https://zh.wikipedia.org/wiki/Flyme_OS" target="_blank" rel="external">Flyme OS - 维基百科，自由的百科全书</a></li><li><a href="https://zh.wikipedia.org/wiki/MIUI" target="_blank" rel="external">MIUI - 维基百科，自由的百科全书</a></li></ul><h3 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h3><h4 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h4><p>适配中用到的 Flag 有：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">View.SYSTEM_UI_FLAG_LAYOUT_STABLE</div><div class="line">View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</div><div class="line">View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</div></pre></td></tr></table></figure><p>在 4.4(API 19) 中还引入了 <code>WindowManager.LayoutParams.FLAG_TRANSUCENT_STATUS</code> 和<code>WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION</code> 用于控制 <code>System UI</code> 变透明，这两个 Flag 分别对应于 <code>windowTranslucentStatus</code> 和<code>windowTranslucentNavigation</code> 两个 attr，并同时提供了相应的 Theme（这些 Theme 都没有 ActionBar），当使用这两个 Flag 时，<code>SYSTEM_UI_FLAG_LAYOUT_STABLE、SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN和SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</code> 会被自动添加。</p><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>从 4.4 开始，所以在 style-19 里所有父级主题增加：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"JikeTheme.SystemUi"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowTranslucentStatus"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p><p>在业务基类 <strong>BaseActivity</strong>  <code>onCreate()</code> 中加入了对沉浸式的一些判断和处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">isSuccessStatusIcons = <span class="keyword">true</span>; <span class="comment">// 默认认为可以设置状态栏 Icon 颜色</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">  StatusBarUtil.setImmersiveStatusBar(<span class="keyword">this</span>);</div><div class="line">  <span class="comment">// 适配状态栏字体颜色</span></div><div class="line">  <span class="keyword">if</span> (needStatusIconsBlack()) &#123;</div><div class="line">    isSuccessStatusIcons = StatusBarUtil.setStatusBarDarkIcon(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (!isSuccessStatusIcons &amp;&amp; ImmersiveUtil.supportImmersiveStatusBar()) &#123;</div><div class="line">    <span class="keyword">if</span> (needAddColorStatusView()) &#123;</div><div class="line">      StatusBarUtil.addColorStatusView(<span class="keyword">this</span>, R.color.black);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      StatusBarUtil.addTranslucentView(<span class="keyword">this</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里有四个方法：</p><ul><li>StatusBarUtil.setImmersiveStatusBar(this);  // 添加全屏/透明状态栏的 Flag</li><li>StatusBarUtil.setStatusBarDarkIcon(this); // 设置状态栏 Icon 为黑色</li><li>StatusBarUtil.addColorStatusView(this, R.color.very_dark_grayish_blue_26); // 添加一个带颜色的矩形块</li><li>StatusBarUtil.addTranslucentView(this, 0); // 添加一个透明状态栏</li></ul><p>主要是这里的逻辑需要说明</p><blockquote><p><code>if (!isSuccessStatusIcons &amp;&amp; StatusBarUtil.supportImmersiveStatusBar())</code></p></blockquote><p>前面已经说了 5.x 的非小米魅族 Rom 无法更改状态栏 icon 颜色，所以我进行适配的方法是，isSuccessStatusIcons 来标识是不是非（魅族，小米） 的其他 Rom，然后加入一个与状态栏等高的带颜色的矩形 View ，也就是<code>StatusBarUtil.addColorStatusView(this, R.color.very_dark_grayish_blue_26);</code> 方法做的事情，同时通过 <code>needAddColorStatusView()</code>标志是否需要添加。</p><p>这样说可能不好理解， 一个具体的场景是这样：</p><p><img src="http://ww3.sinaimg.cn/large/006y8lVajw1f9k09xq8k9j30vf0sek07.jpg" alt=""></p><p>可以看到，在 5.x 首页状态栏是一个黑条，也就是我们手动加上去的矩形，但在有图片的 activity 是透明，这也就是 <code>needAddColorStatusView</code> 标识的作用。</p><p>接下来适配 Toolbar ：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initToolbar</span><span class="params">(@NonNull Toolbar toolbar)</span> </span>&#123;</div><div class="line">  <span class="comment">// other code</span></div><div class="line">  StatusBarUtil.setImmersiveStatusBarToolbar(toolbar, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 统一适配 toolbar</span></div><div class="line"><span class="comment"> * 设置 toolbar 高度为 ?attr/actionBarSize + statusBarHeight 并且设置 padding 布局还原</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImmersiveStatusBarToolbar</span><span class="params">(Toolbar toolbar, Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (ImmersiveUtil.supportImmersiveStatusBar()) &#123;</div><div class="line">        ViewGroup.MarginLayoutParams toolLayoutParams = (ViewGroup.MarginLayoutParams) toolbar.getLayoutParams();</div><div class="line">        toolLayoutParams.height = EnvUtil.getStatusBarHeight() + EnvUtil.getActionBarSize(context);</div><div class="line">        toolbar.setLayoutParams(toolLayoutParams);</div><div class="line">        setImmersiveStatusToolbarOnlyPadding(toolbar, <span class="number">0</span>, EnvUtil.getStatusBarHeight(), <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>主要做的事情就是，将 Toolbar 的高度增加一个状态栏高度，且设置 paddingTop。</p><p>这样在 BaseActivity 里就把状态栏和 Toolbar 都适配好了。</p><p>接下来就是给内容详情增加正确的 margin 值。</p><p>其实以上大部分都跟具体的界面编写有关，所以这里只提供一个思路。</p><h4 id="修补"><a href="#修补" class="headerlink" title="修补"></a>修补</h4><p>适配之后整个页面看着是可行的，但是得额外注意一些具体场景：</p><ol><li><p>需要输入法</p></li><li><p>与状态栏有关的遮挡交互动画</p></li></ol><p><strong>第一个</strong> 比较特殊性。为了适配沉浸式，我们使用了<code>View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</code> 标签，该标签下，adjustResize 会失效，adjustPan 效果很差。为了实现输入法弹出效果，写了一个 FullscreenInputModeUtil 工具类兼容实现，主要逻辑是动态计算可见高度来得到输入法高度，从而改变布局整个高度（输入栏框是始终在布局最底部）实现 adjustResize 效果。</p><p>具体可以参考  <a href="https://code.google.com/p/android/issues/detail?id=5497" target="_blank" rel="external">code.google.com</a></p><p><strong>第二个</strong> 是这样的：</p><p><img src="http://ww3.sinaimg.cn/large/006tNc79gw1f9xpphob6wg30di0o11kx.gif" alt=""></p><p>原本是 CoordinatorLayout Behavior 实现 Toolbar 上滑隐藏效果， BUG 是上滑应该隐藏在状态栏后的 Title 并没有消失。<br>所以现有的解决方案是在 layout 里写一个背景是白色高度是0的 View 并在代码里根据 sdk 修改高度：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 增加一个实体白色 View 在状态栏下，复原滑动效果</span></div><div class="line"><span class="keyword">if</span> (ImmersiveUtil.supportImmersiveStatusBar()) &#123;</div><div class="line">  mTrickStatusBar.getLayoutParams().height = EnvUtil.getStatusBarHeight();</div><div class="line">  mTrickStatusBar.requestLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h4><ul><li>ROM 坑</li></ul><p>根据手机厂商判断 Rom 是不行的，因为会有小米手机但是刷了其他 Rom 的情况，所以我们得找到正确判断 Rom 的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getRomProperty</span><span class="params">(String prop)</span> </span>&#123;</div><div class="line">    String line = <span class="string">""</span>;</div><div class="line">    BufferedReader reader = <span class="keyword">null</span>;</div><div class="line">    Process process = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        process = Runtime.getRuntime().exec(<span class="string">"getprop "</span> + prop);</div><div class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream()), <span class="number">1024</span>);</div><div class="line">        line = reader.readLine();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        IOUtil.close(reader);</div><div class="line">        <span class="keyword">if</span> (process != <span class="keyword">null</span>) &#123;</div><div class="line">            process.destroy();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> line;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该方法主要是执行命令行，去获取 <strong>build.prop</strong> 文件的信息，里面记录了系统的设置和属性，相当于 Windows 系统注册表的文件。当然包括了该手机使用的 Rom 信息，上层我们只需要判断是否含有特殊适配的 Rom 字段即可。这样就可以准确适配不同手机不同系统。</p><ul><li>虚拟导航栏是否存在</li></ul><p>这里大部分的场景是需要输入栏的页面——因为大多输入栏的布局都会是<code>layout_alignParentBottom=true</code>。因为即刻中采取的沉浸式方案是全屏，有输入栏的页面，会设置一个虚拟导航栏的 padding 值，这样才能保证输入栏不会被虚拟导航栏遮挡。</p><p><strong>所以这里的关键就是判断该手机是否有虚拟导航栏。</strong></p><p>最开始的时候，我们是通过判断是否有硬件按钮（菜单键，返回键），来直接一刀决定是否有虚拟导航栏。但是在 Android 机型复杂的环境下，该方法并不能保证所有适配。所以换了一种方案：</p><p>用 Display 来帮助，该类中有个方法：</p><blockquote><p>Gets display metrics based on the real size of this display.<br>The size is adjusted based on the current rotation of the display.<br>The real size may be smaller than the physical size of the screen when the window manager is emulating a smaller display (using adb shell am display-size).</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> More ...getRealMetrics(DisplayMetrics outMetrics) &#123;</div><div class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">updateDisplayInfoLocked();</div><div class="line">mDisplayInfo.getLogicalMetrics(outMetrics,</div><div class="line">CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO,</div><div class="line">mDisplayAdjustments.getActivityToken());</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上诉方法我们可以得到一个近似于手机物理屏幕的尺寸，这里我们认为是 realSize .</p><blockquote><p>Gets display metrics that describe the size and density of this display.<br>The size is adjusted based on the current rotation of the display.<br>The size returned by this method does not necessarily represent the actual raw size (native resolution) of the display. The returned size may be adjusted to exclude certain system decor elements that are always visible. It may also be scaled to provide compatibility with older applications that were originally designed for smaller displays.</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> More ...getMetrics(DisplayMetrics outMetrics) &#123;</div><div class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">updateDisplayInfoLocked();</div><div class="line">mDisplayInfo.getAppMetrics(outMetrics, mDisplayAdjustments);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>同时通过该方法获取可见视图的尺寸。接下来的事情，就是分别比较长宽大小来判断是否有导航栏。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="状态栏工具部分核心代码"><a href="#状态栏工具部分核心代码" class="headerlink" title="状态栏工具部分核心代码"></a>状态栏工具部分核心代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatusBarUtil</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 透明状态栏 让布局延伸到状态栏</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImmersiveStatusBar</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ImmersiveUtil.supportImmersiveStatusBar()) &#123;</div><div class="line">            <span class="keyword">if</span> (SdkUtil.sdkVersionGe21()) &#123;</div><div class="line">                activity.getWindow().setStatusBarColor(Color.TRANSPARENT);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (SdkUtil.sdkVersionEq(<span class="number">19</span>)) &#123;</div><div class="line">                activity.getWindow().setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS,</div><div class="line">                        WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</div><div class="line">            &#125;</div><div class="line">            activity.getWindow()</div><div class="line">                    .getDecorView()</div><div class="line">                    .setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 统一适配 toolbar</span></div><div class="line"><span class="comment">     * 设置 toolbar 高度为 ?attr/actionBarSize + statusBarHeight 并且设置 padding 布局还原</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImmersiveStatusBarToolbar</span><span class="params">(@NonNull Toolbar toolbar, Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ImmersiveUtil.supportImmersiveStatusBar()) &#123;</div><div class="line">            ViewGroup.MarginLayoutParams toolLayoutParams = (ViewGroup.MarginLayoutParams) toolbar.getLayoutParams();</div><div class="line">            toolLayoutParams.height = EnvUtil.getStatusBarHeight() + EnvUtil.getActionBarSize(context);</div><div class="line">            toolbar.setLayoutParams(toolLayoutParams);</div><div class="line">            setImmersiveStatusToolbarOnlyPadding(toolbar, <span class="number">0</span>, EnvUtil.getStatusBarHeight(), <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 为沉浸式抽离设置 toolbar padding 值的方法</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImmersiveStatusToolbarOnlyPadding</span><span class="params">(@NonNull Toolbar toolbar, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (SdkUtil.sdkVersionGe21()) &#123;</div><div class="line">            toolbar.setPadding(left, top, right, bottom);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SdkUtil.sdkVersionGe19()) &#123;</div><div class="line">            toolbar.setPadding(left, top - DensityUtil.dimenPixelSize(R.dimen.shadow_size), right, bottom);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            toolbar.setPadding(left, <span class="number">0</span>, right, bottom);</div><div class="line">        &#125;</div><div class="line">        toolbar.requestLayout();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 给内容页设置正确的 margin 值</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> includeActionBar true： Height = StatusBar + ActionBar false： Height = StatusBar</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImmersiveStatusBarContent</span><span class="params">(@NonNull View view, <span class="keyword">boolean</span> includeActionBar)</span> </span>&#123;</div><div class="line"></div><div class="line">        ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) view.getLayoutParams();</div><div class="line">        <span class="keyword">if</span> (ImmersiveUtil.supportImmersiveStatusBar()) &#123;</div><div class="line">            <span class="keyword">if</span> (includeActionBar) &#123;</div><div class="line">                params.topMargin = EnvUtil.getStatusBarHeight() + EnvUtil.getActionBarSize(view.getContext());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                params.topMargin = EnvUtil.getStatusBarHeight();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (includeActionBar) &#123;</div><div class="line">                params.topMargin = EnvUtil.getActionBarSize(view.getContext()) + DensityUtil.dimenPixelSize(R.dimen.shadow_size) * <span class="number">2</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        view.setLayoutParams(params);</div><div class="line">        view.requestLayout();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 给需要弹出输入法的页面设置弹出效果和正确的 padding 值</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImmersiveNeedInputView</span><span class="params">(@NonNull Activity activity, @NonNull ViewGroup viewGroup)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ImmersiveUtil.supportImmersiveStatusBar()) &#123;</div><div class="line">            FullscreenInputModeUtil.attachActivity(activity, viewGroup);</div><div class="line">            viewGroup.setPadding(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, EnvUtil.getNavigationBarHeight());</div><div class="line">            viewGroup.requestLayout();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 添加颜色矩形条</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addColorStatusView</span><span class="params">(@NonNull Activity activity, @ColorRes <span class="keyword">int</span> color)</span> </span>&#123;</div><div class="line">        ViewGroup contentView =</div><div class="line">                (ViewGroup) activity.findViewById(Window.ID_ANDROID_CONTENT);</div><div class="line">        <span class="keyword">if</span> (contentView.getChildCount() &gt; <span class="number">1</span>) &#123;</div><div class="line">            contentView.getChildAt(<span class="number">1</span>).setBackgroundColor(ContextCompat.getColor(activity, color));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            contentView.addView(createColorStatusBarView(activity, color));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 添加半透明矩形条</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addTranslucentView</span><span class="params">(@NonNull Activity activity, <span class="keyword">int</span> statusBarAlpha)</span> </span>&#123;</div><div class="line">        ViewGroup contentView = (ViewGroup) activity.findViewById(Window.ID_ANDROID_CONTENT);</div><div class="line">        <span class="keyword">if</span> (contentView.getChildCount() &gt; <span class="number">1</span>) &#123;</div><div class="line">            contentView.getChildAt(<span class="number">1</span>).setBackgroundColor(Color.argb(statusBarAlpha, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            contentView.addView(createTranslucentStatusBarView(activity, statusBarAlpha));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建半透明矩形 View</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> View <span class="title">createTranslucentStatusBarView</span><span class="params">(@NonNull Activity activity, <span class="keyword">int</span> alpha)</span> </span>&#123;</div><div class="line">        <span class="comment">// 绘制一个和状态栏一样高的矩形</span></div><div class="line">        View statusBarView = <span class="keyword">new</span> View(activity);</div><div class="line">        LinearLayout.LayoutParams params =</div><div class="line">                <span class="keyword">new</span> LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, EnvUtil.getStatusBarHeight());</div><div class="line">        statusBarView.setLayoutParams(params);</div><div class="line">        statusBarView.setBackgroundColor(Color.argb(alpha, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</div><div class="line">        <span class="keyword">return</span> statusBarView;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建一个带颜色矩形 View</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> View <span class="title">createColorStatusBarView</span><span class="params">(@NonNull Activity activity, @ColorRes <span class="keyword">int</span> color)</span> </span>&#123;</div><div class="line">        <span class="comment">// 绘制一个和状态栏一样高的矩形</span></div><div class="line">        View statusBarView = <span class="keyword">new</span> View(activity);</div><div class="line">        LinearLayout.LayoutParams params =</div><div class="line">                <span class="keyword">new</span> LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, EnvUtil.getStatusBarHeight());</div><div class="line">        statusBarView.setLayoutParams(params);</div><div class="line">        statusBarView.setBackgroundColor(ContextCompat.getColor(activity, color));</div><div class="line">        <span class="keyword">return</span> statusBarView;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 是否设置颜色成功</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setStatusBarDarkIcon</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!ImmersiveUtil.supportImmersiveStatusBar()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (EnvUtil.isMeizu()) &#123;</div><div class="line">                StatusBarUtil.setMeizuStatusBarDarkIcon(activity, <span class="keyword">true</span>);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EnvUtil.isXiaomi()) &#123;</div><div class="line">                StatusBarUtil.setMiuiStatusBarDarkIcon(activity, <span class="keyword">true</span>);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (EnvUtil.isZuk()) &#123;</div><div class="line">                <span class="comment">// Zuk 的 rom 无法修改状态栏 icon 颜色</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SdkUtil.sdkVersionGe23()) &#123;</div><div class="line">                activity.getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 修改魅族状态栏字体颜色 Flyme 4.0</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setMeizuStatusBarDarkIcon</span><span class="params">(@NonNull Activity activity, <span class="keyword">boolean</span> dark)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ImmersiveUtil.supportImmersiveStatusBar()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                WindowManager.LayoutParams lp = activity.getWindow().getAttributes();</div><div class="line">                Field darkFlag = WindowManager.LayoutParams.class</div><div class="line">                        .getDeclaredField(<span class="string">"MEIZU_FLAG_DARK_STATUS_BAR_ICON"</span>);</div><div class="line">                Field meizuFlags = WindowManager.LayoutParams.class</div><div class="line">                        .getDeclaredField(<span class="string">"meizuFlags"</span>);</div><div class="line">                darkFlag.setAccessible(<span class="keyword">true</span>);</div><div class="line">                meizuFlags.setAccessible(<span class="keyword">true</span>);</div><div class="line">                <span class="keyword">int</span> bit = darkFlag.getInt(<span class="keyword">null</span>);</div><div class="line">                <span class="keyword">int</span> value = meizuFlags.getInt(lp);</div><div class="line">                <span class="keyword">if</span> (dark) &#123;</div><div class="line">                    value |= bit;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    value &amp;= ~bit;</div><div class="line">                &#125;</div><div class="line">                meizuFlags.setInt(lp, value);</div><div class="line">                activity.getWindow().setAttributes(lp);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                JLog.e(e, e.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 修改 MIUI V6  以上状态栏颜色</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setMiuiStatusBarDarkIcon</span><span class="params">(@NonNull Activity activity, <span class="keyword">boolean</span> dark)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (ImmersiveUtil.supportImmersiveStatusBar()) &#123;</div><div class="line">            Class&lt;? extends Window&gt; clazz = activity.getWindow().getClass();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Class&lt;?&gt; layoutParams = Class.forName(<span class="string">"android.view.MiuiWindowManager$LayoutParams"</span>);</div><div class="line">                Field field = layoutParams.getField(<span class="string">"EXTRA_FLAG_STATUS_BAR_DARK_MODE"</span>);</div><div class="line">                <span class="keyword">int</span> darkModeFlag = field.getInt(layoutParams);</div><div class="line">                Method extraFlagField = clazz.getMethod(<span class="string">"setExtraFlags"</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</div><div class="line">                extraFlagField.invoke(activity.getWindow(), dark ? darkModeFlag : <span class="number">0</span>, darkModeFlag);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                JLog.e(e, e.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="环境工具类部分核心代码"><a href="#环境工具类部分核心代码" class="headerlink" title="环境工具类部分核心代码"></a>环境工具类部分核心代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnvUtil</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkDeviceHasNavigationBar</span><span class="params">(Activity activity)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (sHasNavigationBar != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        WindowManager windowManager = activity.getWindowManager();</div><div class="line">        Display display = windowManager.getDefaultDisplay();</div><div class="line">        DisplayMetrics realDisplayMetrics = <span class="keyword">new</span> DisplayMetrics();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (SdkUtil.sdkVersionGe(<span class="number">17</span>)) &#123;</div><div class="line">            display.getRealMetrics(realDisplayMetrics);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> realHeight = realDisplayMetrics.heightPixels;</div><div class="line">        <span class="keyword">int</span> realWidth = realDisplayMetrics.widthPixels;</div><div class="line"></div><div class="line">        DisplayMetrics displayMetrics = <span class="keyword">new</span> DisplayMetrics();</div><div class="line">        display.getMetrics(displayMetrics);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> displayHeight = displayMetrics.heightPixels;</div><div class="line">        <span class="keyword">int</span> displayWidth = displayMetrics.widthPixels;</div><div class="line"></div><div class="line">        sHasNavigationBar = (realWidth - displayWidth) &gt; <span class="number">0</span> || (realHeight - displayHeight) &gt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isXiaomi</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> MIUI.equalsIgnoreCase(getRomInfo());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMeizu</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> FLYME.equalsIgnoreCase(getRomInfo());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isZuk</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> ZUK.equalsIgnoreCase(getRomInfo());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String romInfo = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MIUI = <span class="string">"miui"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLYME = <span class="string">"flyme"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZUK = <span class="string">"zuk"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UNKNOWN = <span class="string">"unknown"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RUNTIME_MIUI = <span class="string">"ro.miui.ui.version.name"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RUNTIME_DISPLAY = <span class="string">"ro.build.display.id"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RUNTIME_ZUK = <span class="string">"ro.com.zui.version"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRomInfo</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(romInfo)) &#123;</div><div class="line">            <span class="keyword">return</span> romInfo;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(getRomProperty(RUNTIME_MIUI))) &#123;</div><div class="line">            romInfo = MIUI;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!TextUtils.isEmpty(getRomProperty(RUNTIME_ZUK))) &#123;</div><div class="line">            romInfo = ZUK;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getRomProperty(RUNTIME_DISPLAY).toLowerCase().contains(FLYME)) &#123;</div><div class="line">            romInfo = FLYME;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            romInfo = UNKNOWN;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> romInfo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getRomProperty</span><span class="params">(String prop)</span> </span>&#123;</div><div class="line">        String line = <span class="string">""</span>;</div><div class="line">        BufferedReader reader = <span class="keyword">null</span>;</div><div class="line">        Process process = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            process = Runtime.getRuntime().exec(<span class="string">"getprop "</span> + prop);</div><div class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getInputStream()), <span class="number">1024</span>);</div><div class="line">            line = reader.readLine();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            IOUtil.close(reader);</div><div class="line">            <span class="keyword">if</span> (process != <span class="keyword">null</span>) &#123;</div><div class="line">                process.destroy();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> line;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="修复全屏输入框工具类"><a href="#修复全屏输入框工具类" class="headerlink" title="修复全屏输入框工具类"></a>修复全屏输入框工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullscreenInputModeUtil</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attachActivity</span><span class="params">(Activity activity, ViewGroup group)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> FullscreenInputModeUtil(activity, group);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> View mChildOfContent;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> usableHeightPrevious;</div><div class="line">    <span class="keyword">private</span> FrameLayout.LayoutParams mChildLayoutParams;</div><div class="line">    <span class="keyword">private</span> ViewGroup mInputParentView;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FullscreenInputModeUtil</span><span class="params">(Activity activity, ViewGroup viewGroup)</span> </span>&#123;</div><div class="line">        FrameLayout content = (FrameLayout) activity.findViewById(Window.ID_ANDROID_CONTENT);</div><div class="line">        mInputParentView = viewGroup;</div><div class="line">        mInputParentView.setBackgroundColor(Color.WHITE);</div><div class="line">        mChildOfContent = content.getChildAt(<span class="number">0</span>);</div><div class="line">        mChildOfContent.getViewTreeObserver().addOnGlobalLayoutListener(() -&gt; &#123;</div><div class="line">            <span class="comment">// 当在一个视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变时，所要调用的回调函数的接口类</span></div><div class="line">            resizeChildOfContent();</div><div class="line">        &#125;);</div><div class="line">        mChildLayoutParams = (FrameLayout.LayoutParams) mChildOfContent.getLayoutParams();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 重置 content 布局，通过计算可见范围的变化值，确定输入框的高度（兼容一个状态栏高度）</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resizeChildOfContent</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> visibleHeightNow = ViewUtil.getVisibleHeightInLayout(mChildOfContent);</div><div class="line">        <span class="keyword">if</span> (visibleHeightNow != usableHeightPrevious) &#123;</div><div class="line">            <span class="keyword">int</span> visibleHeightSansKeyboard = mChildOfContent.getRootView().getHeight();</div><div class="line">            <span class="keyword">int</span> heightDifference = visibleHeightSansKeyboard - visibleHeightNow;</div><div class="line">            <span class="keyword">if</span> (heightDifference &gt; (visibleHeightSansKeyboard / <span class="number">4</span>)) &#123;</div><div class="line">                <span class="comment">// 输入法出现</span></div><div class="line">                mChildLayoutParams.height = visibleHeightSansKeyboard - heightDifference + EnvUtil.getStatusBarHeight();</div><div class="line">                mInputParentView.setPadding(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 输入法消失</span></div><div class="line">                mChildLayoutParams.height = visibleHeightSansKeyboard;</div><div class="line">                mInputParentView.setPadding(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, EnvUtil.getNavigationBarHeight());</div><div class="line">            &#125;</div><div class="line">            mChildOfContent.requestLayout();</div><div class="line">            usableHeightPrevious = visibleHeightNow;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文主要是提供一个具体可行方案和开发中遇到的一些坑的解决方案提供出来。如果你的应用主色调不是纯白色，那么理论上可以完全适配到 4.4 (19) 。</p><p>对于沉浸式，众说纷纭，但是唯一的目的，就是提高用户体验。</p><p>如果还有什么遗漏的地方，欢迎补充。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://jaeger.itscoder.com/android/2016/02/15/status-bar-demo.html" target="_blank" rel="external">Android App 沉浸式状态栏解决方案</a></li><li><a href="http://angeldevil.me/2014/09/02/About-Status-Bar-and-Navigation-Bar/" target="_blank" rel="external">与 Status Bar 和 Navigation Bar 相关的一些东西</a></li><li><a href="http://stackoverflow.com/questions/7417123/android-how-to-adjust-layout-in-full-screen-mode-when-softkeyboard-is-visible" target="_blank" rel="external">Android How to adjust layout in Full Screen Mode when softkeyboard is visible</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结适配项目中遇到的沉浸式的坑和个人的解决方案。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 基础 —— 多线程（读书笔记）「二」</title>
    <link href="http://imxie.cc/2016/09/29/Review-Java-Thread-2/"/>
    <id>http://imxie.cc/2016/09/29/Review-Java-Thread-2/</id>
    <published>2016-09-29T08:02:31.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>第二章内容讲讲与多线程相关的方法—— Callable ， Future  和 FutureTask</p><a id="more"></a><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><a href="#目录">目录</a></li><li><a href="#三个类的介绍">三个类的介绍</a><ul><li><a href="#Callable">Callable</a></li><li><a href="#Future">Future</a></li><li><a href="#FutureTask">FutureTask</a></li></ul></li><li><a href="#实例演示">实例演示</a></li><li><a href="#总结与参考">总结与参考</a></li></ul><h4 id="三个类的介绍"><a href="#三个类的介绍" class="headerlink" title="三个类的介绍"></a>三个类的介绍</h4><h5 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h5><p>Callable 与  Runnable 的功能大致相似，不同的是 Callable 是泛型接口，它有一个泛型参数 V ，该接口中有一个返回值「类型为 V 」的 <code>call()</code> 函数，而 Runnable 的 <code>run()</code> 函数是没有返回参数的。</p><p>Callable 的声明如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 泛型返回结果</span></div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h5 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h5><p>书中比喻 Runnable 与 Callable 就像『脱缰的野马』，无法控制。对于应用开发，我们需要『战马』，Future 就是这类『战马』的标准。</p><p>Future 为线程池制定了一个可管理的任务标准。提供了对 Runnable 或者 Callable 任务的执行结果进行取消，查询是否完成，获取结果，设置结果操作。</p><p>Future 的声明如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</div><div class="line">    <span class="comment">// 该任务是否被取消</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 该任务是否完成</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 获取结果，如果任务未完成，则等待，直到完成，因此该函数会阻塞</span></div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</div><div class="line">    <span class="comment">// 获取结果，如果任务未完成，则等待，直到 timeout 或者返回结果，该函数会阻塞</span></div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h5 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h5><p>Future 只是定义了一些规范的接口，而 FutureTask 是它的实现类。FutureTask 实现了 RunnableFuture<v> ，而 RunnableFuture 实现了 Runnable, Future<v> ，因此 FutureTask 具备了它们的能力。</v></v></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>RunnableFuture 的定义如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>FutureTask 会像 Thread 一样对 Runnable 那样对 Runnable 和 Callable<v> 进行包装，是在 FutureTask 构造函数里注入：</v></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.callable = callable;</div><div class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</div><div class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上面代码我们可以知道，如果传入的是 Runnable 会被 <code>Executors.callable()</code> 方法转化成 Callable 类型，可知， FutureTask 最终都是执行 Callable 类型的任务。</p><p>我们进入 <code>Executors.callable()</code> 函数，看看是如何适配转换的：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</div><div class="line">&#125;</div><div class="line"><span class="comment">// Runnable 的适配器，将 Runnable 转换成 Callable </span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> Runnable task;</div><div class="line">    <span class="keyword">final</span> T result;</div><div class="line">    RunnableAdapter(Runnable task, T result) &#123;</div><div class="line">        <span class="keyword">this</span>.task = task;</div><div class="line">        <span class="keyword">this</span>.result = result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        task.run();</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为 FutureTask 实现了 Runnable 接口，因此它可以通过 Thread 包装执行，也可以提交给 ExecuteService 来执行。<br>并且还可以直接通过<a href="#Future"> <code>get()</code> 方法</a>获取执行结果，该方法会阻塞，直到结果返回。<br>所以可以这样理解 <strong>FutureTask</strong> ： 既是 Runnable 又是 Future ，同时也包装了 Callable (如果是 Runnable 最终会转化成 Callable )。</p><h4 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</div><div class="line"><span class="comment">// 线程池</span></div><div class="line"><span class="keyword">static</span> ExecutorService mExecutorService = Executors.newSingleThreadExecutor();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">futureWithRunnable();</div><div class="line">futureWithCallable();</div><div class="line">futureTask();</div><div class="line"></div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 向线程池中提交 Runnable 对象</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureWithRunnable</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">Future&lt;?&gt; rFuture = mExecutorService.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">fibc(<span class="number">20</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">System.out.println(<span class="string">"future result from runnable : "</span> + rFuture.get());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 提交 Callable 对象，</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureWithCallable</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">Future&lt;Integer&gt; rFuture2 = mExecutorService.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">return</span> fibc(<span class="number">20</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"future result from Callable : "</span> + rFuture2.get());</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 提交 FutureTask 对象</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">FutureTask&lt;Integer&gt; mTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">return</span> fibc(<span class="number">20</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">mExecutorService.submit(mTask);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"future result from futureTask : "</span> + mTask.get());</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 斐波那契数列 模拟耗时操作</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibc</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> fibc(num - <span class="number">1</span>) + fibc(num - <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行之后，控制台的输出如下：</p><blockquote><p>future result from runnable : null<br>future result from Callable : 6765<br>future result from futureTask : 6765</p></blockquote><p><code>futureWithRunnable()</code> 方法中提交了一个 Runnable 对象，在 <code>run()</code> 方法里直接操作计算，这个方法没有返回值，所以 Future 对象 <code>get()</code> 拿到的值是 Null 。</p><p><code>futureWithCallable()</code> 方法里提交的是一个 Callable 对象<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</div></pre></td></tr></table></figure></p><p>Callable 实现的是 <code>V call()</code> 方法，最后会返回一个 Future 对象。</p><p><code>futureTask()</code>  则是一个  RunnableFuture<v> 既实现了 Runnable 又实现了 Future<v> 这两个接口。提交给 ExecutorService 执行后，可以通过返回的 Future 对象 <code>get()</code> 方法得到执行结果。</v></v></p><h4 id="总结与参考"><a href="#总结与参考" class="headerlink" title="总结与参考"></a>总结与参考</h4><p>本章内容是作为铺垫，了解和实践了会用到线程池中的三个类。之前我很少接触到，所以写了这篇文章用来加深印象和笔记翻阅。</p><ul><li><a href="https://book.douban.com/subject/26744163/" target="_blank" rel="external">Android 开发进阶 — 从小工到专家</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章内容讲讲与多线程相关的方法—— Callable ， Future  和 FutureTask&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 基础 —— 多线程（读书笔记）「一」</title>
    <link href="http://imxie.cc/2016/09/21/Review-Java-Thread-1/"/>
    <id>http://imxie.cc/2016/09/21/Review-Java-Thread-1/</id>
    <published>2016-09-21T14:51:32.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>多线程对于 Android 开发者来说是基础。而且这类知识在计算机里也是很重要的一环，所以很有必要整理一番。</p><a id="more"></a><blockquote><ul><li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li><li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li><li>作者：<a href="https://github.com/xcc3641" target="_blank" rel="external">谢三弟</a></li><li>审阅者：<a href="https://github.com/laobie" target="_blank" rel="external">Jaeger</a></li></ul></blockquote><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><a href="#目录">目录</a></li><li><a href="#多线程的实现">多线程的实现</a><ul><li><a href="#Thread-源码">Thread 源码</a></li><li><a href="#线程的几个重要的函数">线程的几个重要的函数</a></li><li><a href="#Wait-的实践">Wait() 的实践</a></li><li><a href="#Join-的实践">Join() 的实践</a></li><li><a href="#Yield-的实践">Yield() 的实践</a></li></ul></li><li><a href="#总结与参考">总结与参考</a></li></ul><h4 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h4><p>来上代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 最常见的两种方法启动新的线程</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 覆盖 run 方法</span></div><div class="line">    <span class="keyword">new</span> Thread() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 耗时操作</span></div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line"></div><div class="line">    <span class="comment">// 传入 Runnable 对象</span></div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 耗时操作</span></div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实第一个就是在 Thread 里覆写了 <code>run()</code> 函数，第二个是给 Thread 传了一个 Runnable 对象，在 Runnable 对象 <code>run()</code> 方法里进行耗时操作。<br>以前没有怎么考虑过他们两者的关系，今天我们来具体看看到底是什么鬼？</p><h5 id="Thread-源码"><a href="#Thread-源码" class="headerlink" title="Thread 源码"></a>Thread 源码</h5><p>进入 Thread 源码我们看看：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">/* What will be run. */</span></div><div class="line">    <span class="keyword">private</span> Runnable target;</div><div class="line"></div><div class="line">    <span class="comment">/* The group of this thread */</span></div><div class="line">    <span class="keyword">private</span> ThreadGroup group;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</div><div class="line">        init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</div><div class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>源码很长，我进行了一点分割。一点一点的来解析看看。<br>我们首先知道 Thread 也是一个 Runnable ，它实现了 Runnable 接口，并且在 Thread 类中有一个 Runnable 类型的 target 对象。</p><p>构造方法里我们都会调用 <code>init()</code> 方法，接下来看看在该方法里做了如何的初始化配置。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></div><div class="line"><span class="function"><span class="params">                 <span class="keyword">long</span> stackSize)</span> </span>&#123;</div><div class="line">   init(g, target, name, stackSize, <span class="keyword">null</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></div><div class="line"><span class="function"><span class="params">                 <span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</div><div class="line"></div><div class="line">   Thread parent = currentThread();</div><div class="line">   SecurityManager security = System.getSecurityManager();</div><div class="line">   <span class="comment">// group 参数如果为 null ，则获得当前线程的 group（线程组）</span></div><div class="line">   <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</div><div class="line">           g = parent.getThreadGroup();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 代码省略</span></div><div class="line"></div><div class="line">   <span class="keyword">this</span>.group = g;</div><div class="line">   <span class="keyword">this</span>.daemon = parent.isDaemon();</div><div class="line">   <span class="keyword">this</span>.priority = parent.getPriority();</div><div class="line">   <span class="comment">// 设置 target（ Runnable 类型 ）</span></div><div class="line">   <span class="keyword">this</span>.target = target;</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">// 将当前线程加入线程组</span></div><div class="line">   group.add(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">   <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</div><div class="line">   <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">// 启动 native 方法启动新的线程</span></div><div class="line">       start0();</div><div class="line">       started = <span class="keyword">true</span>;</div><div class="line">   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">// 代码省略</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">       target.run();</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从上我们可以明白，最终被线程执行的任务是 Runnable ，Thread 只是对 Runnable 的一个包装，并且通过一些状态对 Thread 进行管理和调度。<br>当启动一个线程时，如果 Thread 的 target 不为空，则会在子线程中执行这个 target 的 <code>run()</code> 函数，否则虚拟机就会执行该线程自身的 <code>run()</code> 函数。</p><h5 id="线程的几个重要的函数"><a href="#线程的几个重要的函数" class="headerlink" title="线程的几个重要的函数"></a>线程的几个重要的函数</h5><ul><li>wait()<br>  当一个线程执行到 wait() 方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁，使得其他线程可以访问。用户可以使用 notify 、notifyAll 或者指定睡眠时间来唤醒当前等待池中的线程。<br>  注意：<code>wait() notify() notifyAll()</code> 必须放在 <code>synchronized</code> block 中，否则会抛出异常。</li><li>sleep()<br>  该函数是 Thread 的静态函数，作用是使调用线程进入睡眠状态。因为 <code>sleep()</code> 是 Thread 类的静态方法，因此他不能改变对象的机锁。所以，当在一个 <code>synchronized</code> 块中调用 <code>sleep()</code> 方法时，线程虽然休眠了，但是对象的机锁并没有被释放，其他线程无法访问这个对象。</li><li>join()<br>  等待目标线程执行完成之后继续执行。</li><li>yield()<br>  线程礼让。目前线程由运行状态转换为就绪状态，也就是让出执行权限，让其他线程得以优先执行，但其他线程能否优先执行未知。</li></ul><p>在源码中，查看 Thread 里的 State ，对几种状态解释的很清楚。</p><blockquote><p>NEW 状态是指线程刚创建，尚未启动</p><p>RUNNABLE 状态是线程正在正常运行中，当然可能会有某种耗时计算 / IO 等待的操作 / CPU 时间片切换等, 这个状态下发生的等待一般是其他系统资源, 而不是锁, Sleep 等</p><p>BLOCKED  这个状态下，是在多个线程有同步操作的场景, 比如正在等待另一个线程的 synchronized 块的执行释放，或者可重入的 synchronized 块里别人调用 wait() 方法，也就是这时线程在等待进入临界区</p><p>WAITING  这个状态下是指线程拥有了某个锁之后，调用了他的 wait 方法，等待其他线程 / 锁拥有者调用 notify / notifyAll 一遍该线程可以继续下一步操作，这里要区分 BLOCKED 和 WATING ，一个是在临界点外面等待进入， 一个是在临界点里面 wait 等待别人 notify ， 线程调用了 join 方法 进入另外的线程的时候, 也会进入 WAITING 状态，等待被他 join 的线程执行结束</p><p>TIMED_WAITING  这个状态就是有限的 (时间限制) 的 WAITING， 一般出现在调用 <code>wait(long), join(long)</code> 等情况下，另外，一个线程 sleep 后, 也会进入 TIMED_WAITING 状态</p><p>TERMINATED 这个状态下表示 该线程的 run 方法已经执行完毕了, 基本上就等于死亡了 (当时如果线程被持久持有, 可能不会被回收)</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/98641-f529c1608fd10ffe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="Wait-的实践"><a href="#Wait-的实践" class="headerlink" title="Wait() 的实践"></a>Wait() 的实践</h5><p>我们来看一段，<code>wait()</code> 的用途和效果。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitAndNotifyAll</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">System.out.println(<span class="string">"主线程运行"</span>);</div><div class="line"></div><div class="line">Thread thread = <span class="keyword">new</span> WaitThread();</div><div class="line">thread.start();</div><div class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">synchronized</span> (sLockOject) &#123;</div><div class="line">System.out.println(<span class="string">"主线程等待"</span>);</div><div class="line">sLockOject.wait();</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">long</span> timeMs = System.currentTimeMillis() - startTime;</div><div class="line">System.out.println(<span class="string">"主线程继续 —-&gt; 等待耗时："</span> + timeMs + <span class="string">" ms"</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">synchronized</span> (sLockOject) &#123;</div><div class="line">System.out.println(<span class="string">"进入子线程"</span>);</div><div class="line">Thread.sleep(<span class="number">3000</span>);</div><div class="line">System.out.println(<span class="string">"唤醒主线程"</span>);</div><div class="line">sLockOject.notifyAll();</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 <code>waitAndNotifyAll()</code> 函数里，会启动一个 WaitThread 线程，在该线程中将会调用 sleep 函数睡眠 3 秒。线程启动之后在主线程调用 sLockOject 的 <code>wait()</code> 函数，使主线程进入等待状态，此时将不会继续执行。等 WaitThread 在 <code>run()</code> 函数沉睡了 3 秒后会调用 sLockOject 的 <code>notifyAll()</code> 函数，此时就会重新唤醒正在等待中的主线程，因此会继续往下执行。</p><p>结果如下：</p><blockquote><p>主线程运行<br>主线程等待<br>进入子线程<br>唤醒主线程<br>主线程继续 —-&gt; 等待耗时：3005 ms</p></blockquote><p><code>wait()、notify()</code> 机制通常用于等待机制的实现，当条件未满足时调用 wait 进入等待状态，一旦条件满足，调用 <code>notify</code> 或 <code>notifyAll</code> 唤醒等待的线程继续执行。</p><div class="tip"><br><br>对于这里细节可能会有一些疑问。<br><br>在子线程启动的时候，<code>run()</code> 函数里面已经持有了该对象锁。<br><br>但是真实环境下，其实是主线程先持有对象锁，然后调用 <code>wait()</code> 进入等待区并且释放锁等待唤醒。<br><br></div><p>这个问题涉及到 JNI 代码，目前我只能从理论上来解释这个问题。<br>我们都知道一个线程 <code>start()</code> 并不是马上启动，而是需要 CPU 分配资源的，根据目前运行来看，分配资源的时间大于 Java 虚拟机运行指令的时间，所以主线程比子线程先拿到锁。<br>我们还可以知道一点，控制台打印出的时间是 <strong>3005 ms</strong> ，在代码里我们只等待了 3s 多出来的 5ms （这个数字会浮动）我们可以推断是，子线程获取 CPU 的时间加上唤醒主线程的时间。</p><p>上述只是自己的一个猜测，能力还有欠缺，准备深入学习。</p><p>不过推荐大家看看这篇文章 <a href="http://www.jianshu.com/p/99ecdbc9c664" target="_blank" rel="external">Synchnornized 在 JVM 下的实现 - 简书</a>。</p><h5 id="Join-的实践"><a href="#Join-的实践" class="headerlink" title="Join() 的实践"></a>Join() 的实践</h5><p><code>join()</code> 的注释上面写着：</p><blockquote><p>Waits for this thread to die.</p></blockquote><p>意思是，阻塞当前调用 <code>join()</code> 函数所在的线程，直到接收线程执行完毕之后再继续。<br>我们来看看实践代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">joinDemo();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">joinDemo</span><span class="params">()</span> </span>&#123;</div><div class="line">Worker worker1 = <span class="keyword">new</span> Worker(<span class="string">"work-1"</span>);</div><div class="line">Worker worker2 = <span class="keyword">new</span> Worker(<span class="string">"work-2"</span>);</div><div class="line">worker1.start();</div><div class="line">System.out.println(<span class="string">"启动线程 1 "</span>);</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">// 调用 worker1 的 join 函数，主线，程会阻塞直到 woker1 执行完成</span></div><div class="line">worker1.join();</div><div class="line">System.out.println(<span class="string">"启动线程 2"</span>);</div><div class="line"><span class="comment">// 再启动线程 2 ，并且调用线程 2 的 join 函数，主线程会阻塞直到 woker2 执行完成</span></div><div class="line">worker2.start();</div><div class="line">worker2.join();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">System.out.println(<span class="string">"主线程继续执行"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name)</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(<span class="number">2000</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">System.out.println(<span class="string">"work in "</span> + getName());</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>运行之后我们得到：</p><blockquote><p>启动线程 1<br>work in work-1<br>启动线程 2<br>work in work-2<br>主线程继续执行</p></blockquote><p>在 <code>joinDemo()</code> 方法里我们创建两个子线程，然后启动了 work1 线程，下一步调用了 woker1 的 <code>join()</code> 函数。此时，主线程会进入阻塞状态，直到 work1 执行完毕之后才开始继续执行。因为 Worker 的 <code>run()</code> 方法里会休眠 2 秒，因此线程每次调用了 <code>join()</code> 方法实际上都会阻塞 2 秒，直到 <code>run()</code> 方法执行完毕再继续。<br>所以，上述代码逻辑其实就是：</p><p><strong>启动线程1</strong> —-&gt; <strong>等待线程 1 执行完毕</strong> —-&gt; <strong>启动线程2</strong> —-&gt; <strong>等待线程 2 执行完毕</strong> —-&gt; <strong>继续执行主线程代码</strong></p><h5 id="Yield-的实践"><a href="#Yield-的实践" class="headerlink" title="Yield() 的实践"></a>Yield() 的实践</h5><p><code>yield()</code> 是 Thread 的静态方法，注释上说：</p><blockquote><p>A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.</p></blockquote><p>大致意思是说：当前线程让出执行时间给其他的线程。<br>我们都知道，线程的执行是有时间片的，每个线程轮流占用 CPU 固定时间，执行周期到了之后让出执行权给其他线程。<br><code>yield()</code> 就是主动让出执行权给其他线程。</p><p>来看看我们实践的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldThreadTest</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">YieldTread t1 = <span class="keyword">new</span> YieldTread(<span class="string">"thread-1"</span>);</div><div class="line">YieldTread t2 = <span class="keyword">new</span> YieldTread(<span class="string">"thread-2"</span>);</div><div class="line">t1.start();</div><div class="line">t2.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldTread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">YieldTread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>(name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">System.out.printf(<span class="string">"%s 优先级为 [%d] -------&gt; %d\n"</span>, <span class="keyword">this</span>.getName(), <span class="keyword">this</span>.getPriority(), i);</div><div class="line"><span class="comment">// 当 i 为 2 时，调用当前线程的 yield 函数</span></div><div class="line"><span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</div><div class="line">Thread.yield();</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在 <code>main()</code> 方法里创建了两个 YieldTread 线程，控制台输出结果如下：</p><blockquote><p>thread-1 优先级为 [5] ——-&gt; 0<br>thread-1 优先级为 [5] ——-&gt; 1<br>thread-1 优先级为 [5] ——-&gt; 2</p><p>thread-2 优先级为 [5] ——-&gt; 0<br>thread-2 优先级为 [5] ——-&gt; 1<br>thread-2 优先级为 [5] ——-&gt; 2</p><p>thread-1 优先级为 [5] ——-&gt; 3<br>thread-1 优先级为 [5] ——-&gt; 4<br>thread-2 优先级为 [5] ——-&gt; 3<br>thread-2 优先级为 [5] ——-&gt; 4</p></blockquote><p>通常情况下 t1 首先执行，让 t1 的 <code>run()</code> 函数执行到了 i 等于 2 时让出当前线程的执行时间。所以我们看到前三行都是 t1 在执行，让出执行时间后 t2 开始执行。后面逻辑简单思考下就得知了，这里也不做过多诠释。</p><p>因此，调用 <code>yield()</code> 就是让出当前线程的执行权，这样一来让其他线程得到优先执行。</p><h4 id="总结与参考"><a href="#总结与参考" class="headerlink" title="总结与参考"></a>总结与参考</h4><p>本章内容属于线程的基础，本系列会更新到线程池相关。<br>这章内容也及其重要，因为它是后面的基础。<br>正确理解才能让我们对各种线程问题有方向和思路。</p><p><strong>参考读物</strong>：</p><ul><li><a href="https://book.douban.com/subject/26744163/" target="_blank" rel="external">Android 开发进阶 — 从小工到专家</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=416915373&amp;idx=1&amp;sn=f80a13b099237534a3ef777d511d831a&amp;scene=0#wechat_redirect" target="_blank" rel="external">我是一个线程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多线程对于 Android 开发者来说是基础。而且这类知识在计算机里也是很重要的一环，所以很有必要整理一番。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>细致一点地看看 Handler 和它的伙伴们</title>
    <link href="http://imxie.cc/2016/09/17/deep-into-handler-source/"/>
    <id>http://imxie.cc/2016/09/17/deep-into-handler-source/</id>
    <published>2016-09-17T09:48:06.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Handler 对于 Android 开发来说简直就是家常便饭，它的原理自然都很熟悉，这篇文章不会宏观地去介绍它的原理，而是细节深入到各个组成。</p><a id="more"></a><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><!-- toc --><ul><li><a href="#目录">目录</a></li><li><a href="#关系">关系</a></li><li><a href="#分析">分析</a><ul><li><a href="#0x01">0x01</a></li><li><a href="#0x02">0x02</a></li><li><a href="#0x03">0x03</a></li><li><a href="#0x04">0x04</a></li></ul></li><li><a href="#总结">总结</a></li><li><a href="#参考">参考</a></li></ul><!-- tocstop --><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>开始深入细节的时候，我们可以先复习下 Handler 、Looper 和 MessageQueue 三者的关系。</p><ol><li>Handler 必须在 <code>Looper.prepare()</code> 之后才能创建使用</li><li>Looper 与当前线程关联，并且管理着一个 MessageQueue</li><li>Message 是实现 Parcelable 接口的类</li><li>以一个线程为基准，他们的数量级关系是：<br>Handler(N) <strong>:</strong> Looper(1) <strong>:</strong> MessageQueue(1) <strong>:</strong> Thread(1)</li></ol><p>他们的调用关系可以参考这张图：<br><img src="http://ww1.sinaimg.cn/large/7853084cgw1f7x2g6lzkbj20k60b9t9j.jpg" alt=""></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h5><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">    <span class="comment">// 代码省略</span></div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>从 Handler 默认的构造函数我们可以看到，Handler 内部会通过 <code>Looper.myLooper()</code> 来获取 Looper 对象，从而与之关联。</p><h5 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h5><p>我们之前已经知道 Looper 管理着消息队列，从这里深入进去看看是如何跟 MessageQueue 建立联系。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</div><div class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">        &#125;</div><div class="line">        sMainLooper = myLooper();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 <code>Looper.myLooper()</code> 里我们看到，Looper 是通过 <code>sThreadLocal.get()</code> 来获取，那么我们又是何时将 Looper 设置给 sThreadLocal 的呢？答案就在 <code>prepare()</code> 方法里。<br>我们看到 <code>sThreadLocal.set(new Looper(quitAllowed));</code> 实例化了一个 Looper 对象给 sThreadLocal 并且一个线程只有一个 Looper 。</p><p>同时我也贴出了 <code>prepareMainLooper()</code> 方法，根据名字大家都可以猜到，这个方法就是在 Android 主线程(UI)线程调用的方法，而在这个方法里也调用了 <code>prepare(false)</code> 我们看到这里传入的是 false ，表明主线程这里的 Looper 是无法执行 <code>quit()</code> 方法。<br>我在这里贴出 ActivityThread 的 <code>Main()</code> 方法的部分代码，这也是我们程序的入口：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 代码省略</span></div><div class="line"></div><div class="line">    Looper.prepareMainLooper(); <span class="comment">// 创建消息循环 Looper</span></div><div class="line"></div><div class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">    thread.attach(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">        sMainThreadHandler = thread.getHandler(); <span class="comment">// UI 线程的 Handler</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</div><div class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></div><div class="line">                LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</div><div class="line">    &#125;</div><div class="line">    Looper.loop(); <span class="comment">// 执行消息循环</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里我们更清楚了为什么可以直接在主线程创建 Handler ，而不会发生异常。</p><p>以上，我们明白了 Looper 是通过 <code>prepare()</code> 方法与线程建立联系，同时不同线程是无法访问对方的消息队列。</p><blockquote><p>为什么 Handler 要在主线程创建才能更新 UI 呢？</p></blockquote><p>因为 Handler 要与主线程的消息队列关联上，这样 <code>handleMessage()</code> 才会执行在 UI 线程。</p><h5 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h5><p>Looper 的核心其实是它循环取出消息的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    <span class="comment">// 死循环</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/// Handler msg.target</span></div><div class="line">        msg.target.dispatchMessage(msg); <span class="comment">// 派发消息</span></div><div class="line"></div><div class="line">        <span class="comment">// 代码省略</span></div><div class="line"></div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从上面代码我们可以看到，Looper 在 <code>loop()</code> 方法里建立了一个死循环，通过消息队列里不断的取出消息，交给 Handler 去处理。</p><p>这个时候你可能会有一个问题：</p><blockquote><p>Android 中为什么主线程不会因为 Looper.loop() 里的死循环卡死？</p></blockquote><p>我比较推荐 <a href="https://www.zhihu.com/question/34652589/answer/90344494" target="_blank" rel="external">Gityuan 的回答</a></p><p>回到我们这里，在循环中是通过 <code>msg.target.dispatchMessage(msg);</code>  派发消息。其中 msg 是 Message 类型，简单看看它的成员：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</div><div class="line">    Handler target;</div><div class="line">    Runnable callback;</div><div class="line">    Message next;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Object obj;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg1;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> arg2;</div><div class="line"></div><div class="line">    <span class="comment">// 代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以知道消息队列是链表实现的，并且 target 是 Handler 类型。</p><p>现在就可以连通了，通过 Handler 将 Message 投递给消息队列（链表），<code>Looper.loop()</code> 循环从消息队列里取出消息，又将消息分发给 Handler 去处理。通过这个 target 我们也可以知道一个小细节，Handler 只能处理自己所发出的消息。</p><h5 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h5><p>理解清楚之后我们跟着顺序，看看 Handler 是如何处理和分发消息的。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 处理消息方法，交给子类复写</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">    message.callback.run();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们看到 <code>dispatchMessage()</code> 只是一个分发方法，如果 Runnable 类型的 callback 为空，则执行 <code>handleMessage(msg)</code> 处理信息，该方法为空，是交给子类进行复写，并且执行线程是在 Handler 所创建的线程。<br>如果 callback 不为空，则会执行 <code>handleCallback(msg)</code> 来处理信息，该方法会调用 callback 的 <code>run()</code> 方法。</p><p>其实说简单一点，就是 Handler 的两种分发类型。<br>一种是 <code>post(r)</code> 另一种是 <code>sendMessage(msg)</code>。</p><p>我们具体看看这两个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</div><div class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span></span>&#123;</div><div class="line">    Message m = Message.obtain();</div><div class="line">    m.callback = r;</div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">        delayMillis = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>; <span class="comment">// 与当前 Handler 绑定</span></div><div class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>做了一个导图，方便理解下：<br><img src="http://ww4.sinaimg.cn/large/7853084cgw1f7xsolnxzmj21kw0ihdh4.jpg" alt=""></p><p>从中我们可以看到，在 <code>post(r)</code> 时，会将 Runnable 包装成 Message 对象，并且赋值给 Message 的 callback 字段，最后跟 <code>sendMessage(msg)</code>  方法一样将消息插入队列。</p><p>根据代码和导图，无论是 <code>post(r)</code> 还是 <code>sendMessage(msg)</code> 都会最终调用 <code>sendMessageAtTime(msg,time)</code></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Handler 最终将消息追加到 MessageQueue 中，而 Looper 不断的从 MessageQueue 中读取消息，并且调用 Handler 的 dispatchMessage 分发消息，最后交给上层处理消息。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://book.douban.com/subject/26744163/" target="_blank" rel="external">Android 开发进阶 从小工到专家</a></li><li><a href="https://book.douban.com/subject/26599538/" target="_blank" rel="external">Android 开发艺术探索</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Handler 对于 Android 开发来说简直就是家常便饭，它的原理自然都很熟悉，这篇文章不会宏观地去介绍它的原理，而是细节深入到各个组成。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 初阶自定义 View 字符头像</title>
    <link href="http://imxie.cc/2016/09/14/let-s-practise-custom-view/"/>
    <id>http://imxie.cc/2016/09/14/let-s-practise-custom-view/</id>
    <published>2016-09-14T14:37:10.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>自己很少做自定义 View ，只有最开始的时候跟着郭神写了一个小 Demo ，后来随着见识的越来越多，特别是在开源社区看到很多优秀的漂亮的控件，都是羡慕的要死，但是拉下来的代码还是看不明白，而且当时因为时间因素，没有深入学习和研究控件和动画方面的知识，而是把更多时间花在了 Android 的异步通信和网络框架这一块。<br>因为想起暑假实习的时候有个小需求，当时因为忙着主要的业务，一直搁浅没有做，回到学校发现其实不难。索性从这个人生第一个上架的小控件慢慢深入一点，顺带复习 View 的绘制原理。</p><a id="more"></a><blockquote><ul><li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li><li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li><li>作者：<a href="https://github.com/xcc3641" target="_blank" rel="external">谢三弟</a></li><li>审阅者：<a href="https://github.com/brucezz" target="_blank" rel="external">Brucezz</a></li></ul></blockquote><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#目录">目录</a></li><li><a href="#目标效果">目标效果</a></li><li><a href="#继承-ImageView-开始">继承 ImageView 开始</a></li><li><a href="#工作流程">工作流程</a><ul><li><a href="#onMeasure">onMeasure()</a></li><li><a href="#onLayout">onLayout()</a></li><li><a href="#onDraw">onDraw()</a></li></ul></li><li><a href="#使用">使用</a></li><li><a href="#额外阅读">额外阅读</a></li></ul><h3 id="目标效果"><a href="#目标效果" class="headerlink" title="目标效果"></a>目标效果</h3><blockquote><p>需求：实习公司一个产品，因为很多是临时用户，需要为这些没有自觉设置头像的用户，给予随机头像。生成的规则是根据用户用户名的第一个字符随机匹配颜色集。</p></blockquote><p>从需求中我们可以知道：</p><ul><li>该控件需要展示图片</li><li>该控件需要按照规则生成图像</li><li>一般头像都是圆形</li></ul><p><img src="http://ww3.sinaimg.cn/large/801b780agw1f7ugm27t4oj205m05agll.jpg" alt=""></p><p>大致上可以知道是这样的。<br>开搞！</p><h3 id="继承-ImageView-开始"><a href="#继承-ImageView-开始" class="headerlink" title="继承 ImageView 开始"></a>继承 ImageView 开始</h3><p>我们都知道 Android 自带了很多控件，我们自定义控件的出发点只是官方提供的控件无法满足业务需求的时候。<br>从我们的需求来看，该控件是图片展示类的，所以我们很自然想到了只需要在系统 ImageView 上进行功能拓展即可，这样就可以满足新的需求又不会失去 ImageView 自带的功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharAvatarView</span> <span class="keyword">extends</span> <span class="title">ImageView</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = CharAvatarView.class.getSimpleName();</div><div class="line">    <span class="comment">// 颜色画板集</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] colors = &#123;</div><div class="line">        <span class="number">0xff1abc9c</span>, <span class="number">0xff16a085</span>, <span class="number">0xfff1c40f</span>, <span class="number">0xfff39c12</span>, <span class="number">0xff2ecc71</span>,</div><div class="line">        <span class="number">0xff27ae60</span>, <span class="number">0xffe67e22</span>, <span class="number">0xffd35400</span>, <span class="number">0xff3498db</span>, <span class="number">0xff2980b9</span>,</div><div class="line">        <span class="number">0xffe74c3c</span>, <span class="number">0xffc0392b</span>, <span class="number">0xff9b59b6</span>, <span class="number">0xff8e44ad</span>, <span class="number">0xffbdc3c7</span>,</div><div class="line">        <span class="number">0xff34495e</span>, <span class="number">0xff2c3e50</span>, <span class="number">0xff95a5a6</span>, <span class="number">0xff7f8c8d</span>, <span class="number">0xffec87bf</span>,</div><div class="line">        <span class="number">0xffd870ad</span>, <span class="number">0xfff69785</span>, <span class="number">0xff9ba37e</span>, <span class="number">0xffb49255</span>, <span class="number">0xffb49255</span>, <span class="number">0xffa94136</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Paint mPaintBackground;</div><div class="line">    <span class="keyword">private</span> Paint mPaintText;</div><div class="line">    <span class="keyword">private</span> Rect mRect;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String text;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> charHash;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharAvatarView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharAvatarView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharAvatarView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        mPaintBackground = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</div><div class="line">        mPaintText = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</div><div class="line">        mRect = <span class="keyword">new</span> Rect();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里我做了一些初始化工作，并且在其中的一个构造函数中实例化了 <code>Paint</code> 和 <code>Rect</code> 。</p><p>关于 View 的构造函数的区别：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CharAvatarView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(context);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CharAvatarView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(context, attrs);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CharAvatarView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>第一种属于程序内实例化时采用，之传入 Context 即可<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">CharAvatarView avatarView = <span class="keyword">new</span> CharAvatarView(<span class="keyword">this</span>);</div></pre></td></tr></table></figure></li></ul><p>这样我们的 View 就新建出来了，根据需求添加到布局即可。</p><ul><li><p>第二种用于 layout 文件实例化，会把 XML 内的参数通过 AttributeSet 带入到 View 内。</p></li><li><p>第三个主题的 style 信息，也会从 XML 里带入</p></li></ul><p>为了自定义的 View 兼容 Java 和 Xml 两种代码的使用方式，一般推荐这样写构造方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CharAvatarView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>(context, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CharAvatarView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CharAvatarView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>(context, attrs, defStyleAttr);</div><div class="line">      init();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">      mPaintBackground = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</div><div class="line">      mPaintText = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</div><div class="line">      mRect = <span class="keyword">new</span> Rect();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>我们的 View 系统是如何将它绘制到屏幕上的呢？</p><blockquote><p>View 的绘制流程是从 ViewRoot 的 <code>performTraversals</code> 方法开始，它经过 measure 、 layout 和 draw 三个过程才能最终将一个 View 绘制出来，其中 measure 用来测量 View 的宽和高，layout 用来确定 View 在父容器中的放置位置，而 draw 则负责将 View 绘制在屏幕上。针对 performTraversals 的大致流程如图：</p></blockquote><p><img src="http://ww4.sinaimg.cn/large/801b780agw1f7um4igvkcj20up0imta0.jpg" alt=""></p><blockquote><p>Measure 过程决定了 View 的宽/高， Measure 完成以后，可以通过 <code>getMeasuredWidth</code> 和 <code>getMeasuredHeight</code> 方法来获取到 View 测量后的宽/高，在几乎所有的情况下它都等同于 View 最终的宽/高，但是特殊情况除外。<br>Layout 过程 决定了 View 的四个顶点的坐标和实际的 View 的宽/高，完成以后，可以通过 <code>getTop</code>、<code>getBottom</code>、<code>getLeft</code>、<code>getRight</code> 来拿到 View 的四个顶点的位置，并可以通过 <code>getWidth</code> 和 <code>getHeight</code> 方法拿到 View 最终的宽/高。<br>Draw 过程则决定了 View 的显示，只有 draw 方法完成以后 View 的内容才能呈现在屏幕上。</p></blockquote><p>关于 View 工作流程的深入我们在以后另外开篇进行研究。目前我们已经从宏观了解到了 View 会经历三个过程绘制出来，而且清楚了其中不同方法中的用途。接下来我们看看 CharAvatarView 在这三个流程中分别做了什么。</p><h4 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure()"></a>onMeasure()</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, widthMeasureSpec); <span class="comment">// 宽高相同</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>让宽高相同，我在这里是只直接传入宽度进行测量。<br>这样会得到一个正方形的 View。</p><h4 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout()"></a>onLayout()</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我在这里什么也没有做，因为需求里对 View 的位置没有什么需要特殊的处理。</p><h4 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw()"></a>onDraw()</h4><p>大部分自定义控件，最核心的代码就是在 <code>onDraw()</code> 里了。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != text) &#123;</div><div class="line">        <span class="keyword">int</span> color = colors[charHash % colors.length];</div><div class="line">        <span class="comment">// 画圆</span></div><div class="line">        mPaintBackground.setColor(color);</div><div class="line">        canvas.drawCircle(getWidth() / <span class="number">2</span>, getWidth() / <span class="number">2</span>, getWidth() / <span class="number">2</span>, mPaintBackground);</div><div class="line">        <span class="comment">// 写字</span></div><div class="line">        mPaintText.setColor(Color.WHITE);</div><div class="line">        mPaintText.setTextSize(getWidth() / <span class="number">2</span>);</div><div class="line">        mPaintText.setStrokeWidth(<span class="number">3</span>);</div><div class="line">        mPaintText.getTextBounds(text, <span class="number">0</span>, <span class="number">1</span>, mRect);</div><div class="line">        <span class="comment">// 垂直居中</span></div><div class="line">        Paint.FontMetricsInt fontMetrics = mPaintText.getFontMetricsInt();</div><div class="line">        <span class="keyword">int</span> baseline = (getMeasuredHeight() - fontMetrics.bottom - fontMetrics.top) / <span class="number">2</span>;</div><div class="line">        <span class="comment">// 左右居中</span></div><div class="line">        mPaintText.setTextAlign(Paint.Align.CENTER);</div><div class="line">        canvas.drawText(text, getWidth() / <span class="number">2</span>, baseline, mPaintText);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ol><li>首先从颜色数组里根据 hash 取余得到背景颜色</li><li>然后画出背景圆</li><li>接下来就是写字</li><li>最后是对字居中的处理</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> content 传入字符内容</span></div><div class="line"><span class="comment"> * 只会取内容的第一个字符,如果是字母转换成大写</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String content)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (content == <span class="keyword">null</span>) &#123;</div><div class="line">        content=<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.text = String.valueOf(content.toCharArray()[<span class="number">0</span>]);</div><div class="line">    <span class="keyword">this</span>.text = text.toUpperCase();</div><div class="line">    charHash = <span class="keyword">this</span>.text.hashCode();</div><div class="line">    <span class="comment">// 重绘</span></div><div class="line">    invalidate();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是暴露给外部的方法，我们也是在这里得到要画的字符。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在 gradle 依赖里添加:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">compile <span class="string">'com.github.xcc3641:charavatarview:0.1'</span></div></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">com.hugo.charavatarview.CharAvatarView</span></span></div><div class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"50dp"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"50dp"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/avatar"</span>/&gt;</span></div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">CharAvatarView mAvatarView;</div><div class="line">mAvatarView = (CharAvatarView) findViewById(R.id.avatar);</div><div class="line">mAvatarView.setText(<span class="string">"谢三弟"</span>);</div></pre></td></tr></table></figure><p>运行：<br><img src="http://ww4.sinaimg.cn/large/801b780agw1f7upxsczbsj20p815egnp.jpg" alt=""></p><p>人生第一个自定义 View 就完成了。</p><p>上传到可以参考司机的这篇文章<a href="">码农必知之上传开源库到 jcenter</a>，配置好各种参数。以后更新版本就执行一行代码就行啦。</p><figure class="highlight gradle"><table><tr><td class="code"><pre><div class="line">.<span class="regexp">/gradlew install /</span><span class="regexp">/ 只需要第一次执行</span></div><div class="line"><span class="regexp">./g</span>radlew bintrayUpload</div></pre></td></tr></table></figure><p>开源地址：<a href="https://github.com/xcc3641/CharAvatarView" target="_blank" rel="external">GitHub 地址</a></p><h3 id="额外阅读"><a href="#额外阅读" class="headerlink" title="额外阅读"></a>额外阅读</h3><ul><li><a href="http://www.cnblogs.com/tianzhijiexian/p/4300988.html" target="_blank" rel="external">讲解 Canvas 中的一些重要方法</a></li><li><a href="http://www.jianshu.com/p/d507e3514b65" target="_blank" rel="external">教你步步为营掌握自定义 View</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己很少做自定义 View ，只有最开始的时候跟着郭神写了一个小 Demo ，后来随着见识的越来越多，特别是在开源社区看到很多优秀的漂亮的控件，都是羡慕的要死，但是拉下来的代码还是看不明白，而且当时因为时间因素，没有深入学习和研究控件和动画方面的知识，而是把更多时间花在了 Android 的异步通信和网络框架这一块。&lt;br&gt;因为想起暑假实习的时候有个小需求，当时因为忙着主要的业务，一直搁浅没有做，回到学校发现其实不难。索性从这个人生第一个上架的小控件慢慢深入一点，顺带复习 View 的绘制原理。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>框架源码 — 简析学习 Retrofit</title>
    <link href="http://imxie.cc/2016/08/20/retrofit-source-learning/"/>
    <id>http://imxie.cc/2016/08/20/retrofit-source-learning/</id>
    <published>2016-08-20T09:03:37.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>看过很多篇 Retrofit 的源码分析文章，但是别人一问起来总是讲不清楚到底 Retrofit 是怎么个流程，所以还是得自己亲自去看看源码，一步一步的分析。果然只有亲自动手实践，才有自己的收获。<br>告诫自己，<strong>慢慢来，会很快。</strong></p><a id="more"></a><blockquote><ul><li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog" target="_blank" rel="external">WeeklyBolg</a> 项目</li><li>itsCoder主页：<a href="http://itscoder.com/" target="_blank" rel="external">http://itscoder.com/</a></li><li>作者：<a href="http://imxie.cc">谢三弟</a></li><li>审阅者：<a href="http://extremej.itscoder.com/" target="_blank" rel="external">Joe</a></li></ul></blockquote><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#目录">目录</a></li><li><a href="#Retrofit-简介">Retrofit 简介</a></li><li><a href="#Retrofit-分析">Retrofit 分析</a><ul><li><a href="#具体使用">具体使用</a></li><li><a href="#工具箱：Retrofit-Builder">工具箱：Retrofit.Builder()</a></li><li><a href="#外壳：Create">外壳：Create()</a></li><li><a href="#结构：ServiceMethod">结构：ServiceMethod</a></li><li><a href="#子弹：xxxFactory">子弹：xxxFactory()</a></li><li><a href="#开枪打靶-Call-enqueue">开枪打靶: Call.enqueue()</a></li></ul></li><li><a href="#参考">参考</a></li></ul><h3 id="Retrofit-简介"><a href="#Retrofit-简介" class="headerlink" title="Retrofit 简介"></a>Retrofit 简介</h3><p>Retrofit 源码开头的解释</p><figure class="highlight"><table><tr><td class="code"><pre><div class="line">* Retrofit adapts a Java <span class="class"><span class="keyword">interface</span> <span class="title">to</span> <span class="title">HTTP</span> <span class="title">calls</span> <span class="title">by</span> <span class="title">using</span> <span class="title">annotations</span> <span class="title">on</span> <span class="title">the</span> <span class="title">declared</span> <span class="title">methods</span> <span class="title">to</span></span></div><div class="line"><span class="class">* <span class="title">define</span> <span class="title">how</span> <span class="title">requests</span> <span class="title">are</span> <span class="title">made</span>. <span class="title">Create</span> <span class="title">instances</span> <span class="title">using</span> </span>&#123;<span class="meta">@linkplain</span> Builder</div><div class="line">* the builder&#125; and pass your interface to &#123;@link #create&#125; to generate an implementation.</div></pre></td></tr></table></figure><p>Retrofit 利用方法上的注解将接口转化成一个 HTTP 请求。</p><p>简单知道是什么了之后，我们对此提出疑问：</p><ul><li>如何将接口转换为网络请求？</li><li>谁去进行网络请求？</li></ul><p>接下来我们将从 Retrofit 的使用作为入口分析。</p><h3 id="Retrofit-分析"><a href="#Retrofit-分析" class="headerlink" title="Retrofit 分析"></a>Retrofit 分析</h3><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><p>首先建立 API 接口类：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GankApi</span> </span>&#123;</div><div class="line">    String host = <span class="string">"http://gank.io/api/data/"</span>;</div><div class="line">    <span class="meta">@GET</span>(<span class="string">"Android/10/&#123;page&#125;"</span>)</div><div class="line">    <span class="function">Call&lt;Android&gt; <span class="title">getAndroid</span><span class="params">(@Path(<span class="string">"page"</span>)</span> <span class="keyword">int</span> page)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 创建 Retrofit 实例</span></div><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">    .baseUrl(GankApi.host)</div><div class="line">    .addConverterFactory(GsonConverterFactory.create())</div><div class="line">    .build();</div><div class="line"></div><div class="line"><span class="comment">// 生成接口实现类</span></div><div class="line">GankApi gankApi = retrofit.create(GankApi.class);</div><div class="line"></div><div class="line"><span class="comment">// 调用接口定义的请求方法，并且返回 Call 对象</span></div><div class="line">Call&lt;Android&gt; call = gankApi.getAndroid(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">// 调用 Call 对象的异步执行方法</span></div><div class="line">call.enqueue(Callback callback)</div></pre></td></tr></table></figure><p>简单的使用就是这样的流程。现在我们开始层层剖析。</p><h4 id="工具箱：Retrofit-Builder"><a href="#工具箱：Retrofit-Builder" class="headerlink" title="工具箱：Retrofit.Builder()"></a>工具箱：Retrofit.Builder()</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Platform platform;</div><div class="line"><span class="keyword">private</span> okhttp3.Call.Factory callFactory;</div><div class="line"><span class="keyword">private</span> HttpUrl baseUrl;</div><div class="line"><span class="keyword">private</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">private</span> List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">private</span> Executor callbackExecutor;</div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;</div></pre></td></tr></table></figure><p>创建 Retrofit 的实例，进行一些配置，这里我们不用多说。但是有一个参数必须得讲讲。</p><ul><li><strong>Platform</strong></li></ul><p>在构建 Retrofit 的时候，会对当前使用平台进行判断，Java8，Android，iOS。</p><p>我们看看 Android 平台的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(Executor callbackExecutor)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">      handler.post(r);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>从代码中我们得知两点：</p><ol><li>在 Android 里我们默认使用的 CallAdapter 是 <code>ExecutorCallAdapterFactory()</code> 它会返回的是 Call.class。关于 <code>ExecutorCallAdapterFactory()</code> 我们稍后再说，你先知道这是 Android 默认 CallAdapter 就好。</li><li>默认的 Callback 是在主线程。</li></ol><h4 id="外壳：Create"><a href="#外壳：Create" class="headerlink" title="外壳：Create()"></a>外壳：Create()</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 生成接口实现类</span></div><div class="line">GankApi gankApi = retrofit.create(GankApi.class);</div></pre></td></tr></table></figure><p>我在源码里写好了注释：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检查传入的类是否为接口并且无继承</span></div><div class="line">    Utils.validateServiceInterface(service);</div><div class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</div><div class="line">      eagerlyValidateMethods(service);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 重点是这里</span></div><div class="line">    <span class="comment">// 首先会返回一个利用代理实现的 GankApi 对象</span></div><div class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</div><div class="line"></div><div class="line">          <span class="comment">// 我们调用该对象的方法都会进入到这里</span></div><div class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></div><div class="line"><span class="function">              <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">            <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></div><div class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</div><div class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 解析方法 这里用到了注解（Runtime）这里我们标记下（A）稍后来看看里面具体实现</span></div><div class="line">            ServiceMethod serviceMethod = loadServiceMethod(method);</div><div class="line">            <span class="comment">// 将刚刚解析完毕包装后的具体方法封装成 OkHttpCall ，你可以在该实现类找到 okhttp 请求所需要的参数</span></div><div class="line">            <span class="comment">// 所以它是用来跟 okhttp 对接的。</span></div><div class="line">            OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">            <span class="comment">// 将以上我们封装好的 call 返回给上层，这个时候我们就可以执行 call 的同步方法或者异步进行请求。</span></div><div class="line">            <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>切合我们实际运用来看看顺序：</p><p><code>GankApi gankApi = retrofit.create(GankApi.class);</code>—-&gt;<br> <code>return (T) Proxy.newProxyInstance（...）{...}</code>—-&gt;<br> <code>Call&lt;Android&gt; call = gankApi.getAndroid(1);</code> —-&gt;<br>  <code>public Object invoke(...){...}</code> 调用代理类的<code>invoke()</code>。</p><p>  直到这里我们已经宏观地了解 Retrofit 是怎样的一个流程。<br>  达成 <strong>初窥门径</strong> 成就。</p><p>千万别骄傲，为了以后走的更远更稳，我们得好好筑基，上面我们用到的是动态代理，强烈建议认真阅读两篇文章。</p><ul><li><a href="http://www.jianshu.com/p/a56c61da55dd" target="_blank" rel="external">Retrofit2源码分析[动态代理]</a></li><li><a href="http://blog.csdn.net/giserstone/article/details/17199755" target="_blank" rel="external">Java静态代理和动态代理</a></li></ul><h4 id="结构：ServiceMethod"><a href="#结构：ServiceMethod" class="headerlink" title="结构：ServiceMethod"></a>结构：ServiceMethod</h4><p>Retrofit 有一个双链表用来缓存方法<br><code>private final Map&lt;Method, ServiceMethod&gt; serviceMethodCache = new LinkedHashMap&lt;&gt;();</code><br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">  <span class="function">ServiceMethod <span class="title">loadServiceMethod</span><span class="params">(Method method)</span> </span>&#123;</div><div class="line">  ServiceMethod result;</div><div class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</div><div class="line">      <span class="comment">// 从缓存中获取该方法</span></div><div class="line">    result = serviceMethodCache.get(method);</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 没有就进行创建并且存入链表缓存</span></div><div class="line">      result = <span class="keyword">new</span> ServiceMethod.Builder(<span class="keyword">this</span>, method).build();</div><div class="line">      serviceMethodCache.put(method, result);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们发现主要的方法是 <code>new ServiceMethod.Builder(this, method).build();</code> ，所以接下来我们深入看看如何 <strong>解析注解</strong> 以及 <strong>构建请求方法</strong> 。</p><ul><li>初始化一些参数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.retrofit = retrofit;</div><div class="line">  <span class="keyword">this</span>.method = method;</div><div class="line">  <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</div><div class="line">  <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</div><div class="line">  <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>build()</code></li></ul><p>这里的源码很长，做了很多异常处理，我截取重点来分析下。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">callAdapter = createCallAdapter();</div><div class="line">responseConverter = createResponseConverter();</div></pre></td></tr></table></figure><p>一个是用来发送请求的 client ，一个是结果的转换器（Gson，FastJson …）之类，后面我们再讲这个。<br>上层配置就是当我们调用 Retrofit 的 <code>addConverterFactory()</code>和 <code>addCallAdapterFactory()</code>，内部会自动使用我们定义的组件。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</div><div class="line">  parseMethodAnnotation(annotation);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这里可以看到遍历我们使用方法的注解，并且解析他们。<code>parseMethodAnnotation()</code> 内部就是解析好 HTTP 的请求方式。</p><p>为了篇幅大小，可以在 <a href="https://github.com/square/retrofit/blob/master/retrofit/src/main/java/retrofit2/ServiceMethod.java" target="_blank" rel="external">源码</a> 里看看具体的操作。</p><p>同时也可以看看 http 包下注解用到的接口，你会发现 <code>@Retention(RUNTIME)</code> 所以，从这里我们就可以明白，Retrofit 是在在运行期通过反射访问到这些注解的。</p><ul><li><code>return Call</code></li></ul><p>请求方法参数，请求客户端，返回值转换，我们都定义好了之后，便完成最后一步，构建好适合请求客户端的请求方法，Retrofit 默认的是 okhttpCall 。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line"><span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</div></pre></td></tr></table></figure><p>最后将 call 返回给上层，用户调用方法进行请求。</p><ul><li>总结</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/** Adapts an invocation of an interface method into an HTTP call. */</span></div></pre></td></tr></table></figure><p>ServiceMethod 类开头注释已经很清楚的说明了作用，将接口方法改变成一个 HTTP call 。它对于 Retrofit 是很重要的存在，整个枪支内部都是由它来支撑起来。</p><h4 id="子弹：xxxFactory"><a href="#子弹：xxxFactory" class="headerlink" title="子弹：xxxFactory()"></a>子弹：xxxFactory()</h4><p>Retrofit 给我们最大的便利就是自身框架优雅的设计，只需要很小的改动，便可以优雅的适应不同的需求。所以很需要我们再补充点额外知识，了解什么是<a href="http://blog.csdn.net/zhangjg_blog/article/details/18735243" target="_blank" rel="external">适配器模式</a>，然后回到这里看看 Retrofit 是如何应用的。</p><p>在构建 <code>ServiceMethod</code> 对象的时候，有三个方法可以单独说说</p><ol><li><code>build()</code> 中 <code>createCallAdapter()</code> —-&gt; <code>retrofit.callAdapter()</code></li><li>解析接口方法内注解时<code>parseParameterAnnotation()</code>调用到的<code>retrofit.requestBodyConverter()</code></li><li><code>build()</code> 中 <code>createResponseConverter()</code> —-&gt; <code>retrofit.responseBodyConverter()</code></li></ol><blockquote><p>callAdapter()</p></blockquote><p>最终会调用到 <code>nextCallAdapter()</code> 该方法主要是从 callAdapterFactories 中获取新的 CallAdapter，它会跳过 skipPast，以及 skipPast 之前的 Factory，然后找到与 returnType 和 annotations 都匹配的 CallAdapterFactory 。</p><blockquote><p>requestBodyConverter() &amp; responseBodyConverter()</p></blockquote><p>最终会调用到 <code>nextRequestBodyConverter()/nextResponseBodyConverter</code>利用 converterFactories 创建一个与 RequestBody/ResponseBody 对应的 Converter 对象。</p><p>所以在这里我们就可以装填我们需要的子弹类型了。</p><p><strong>进入实战，为我们的 Retrofit 添加 RxJava 和 Gson。</strong></p><ul><li>Rxjava:</li></ul><p><img src="http://ww4.sinaimg.cn/large/006tNbRwgw1f71shdblvjj30wi08igms.jpg" alt="23:33:50.jpg"></p><p> <strong>adapter-rxjava</strong> 我们重点看 RxJavaCallAdapterFactory 即可，它是实现了 CallAdapter.Factory 并在对应方法里将 Call 包装成 Observable.class 返回。<br> 然后给 Retrofit 对象加上 <code>.addCallAdapterFactory(RxJavaCallAdapterFactory.create())</code>，这样我们才可以优雅的使用 Retrofit + RxJava 。</p><ul><li>Gson:</li></ul><p><img src="http://ww3.sinaimg.cn/large/006tNbRwgw1f71si9z928j30x607adh0.jpg" alt="23:34:46.jpg"></p><p>我相信通过类名我们就可以知道每个类是用来做什么的，我在这里太过深入到具体实现反而一叶障目，<br>如果我们需要自定义数据转换格式，也是同样这样做。<br>继承 <code>Converter.Factory</code> 类作为适配类，同时创建两个实现 <code>Converter</code> 的类包装请求和响应的数据形式。</p><h4 id="开枪打靶-Call-enqueue"><a href="#开枪打靶-Call-enqueue" class="headerlink" title="开枪打靶: Call.enqueue()"></a>开枪打靶: Call.enqueue()</h4><div class="tip"><br>注意：我这里只列举一个默认状态下的情况<br></div><p>还记得我工具箱里我们提到的 <code>ExecutorCallbackCall</code> 吗？<br>这里的 Call 是对应我们选择的 call ，而此时是默认的 <code>ExecutorCallbackCall</code> 。如果还要问我为什么，请去看看 <a href="#工具箱：Retrofit-Builder">工具箱：Retrofit.Builder()</a> 里 Android 平台的源码。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">final</span> Executor callbackExecutor;</div><div class="line">  <span class="keyword">final</span> Call&lt;T&gt; delegate;</div><div class="line"></div><div class="line">  ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</div><div class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</div><div class="line">    <span class="keyword">this</span>.delegate = delegate;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"callback == null"</span>);</div><div class="line"></div><div class="line">    delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</div><div class="line">        callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">          <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (delegate.isCanceled()) &#123;</div><div class="line">              <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></div><div class="line">              callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里的 delegate 对应的就是 okhttp 的 call ，不禁有疑问了，这里调用的是异步请求，但是我们的回调是怎么回到主线程的呢？</p><p>带着疑问我们来看看。<br>首先回调是在 <code>callbackExecutor.execute()</code> 我们从这里入手。<br>我们发现在 Retrofit 的 <code>build()</code> 方法里：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</div><div class="line"><span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">  callbackExecutor = platform.defaultCallbackExecutor();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>平台默认的回调调度器，连忙回到工具箱看看：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(Executor callbackExecutor)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">      handler.post(r);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们发现，Android 默认的调度器是主线程的 Handler ，<code>execute()</code>方法也只是 <code>mainHandler.post()</code> 。</p><p>所以这下就可以解决我们的疑问了。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (delegate.isCanceled()) &#123;</div><div class="line">      <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></div><div class="line">      callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>这段代码我们就可以改写为：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mainHandler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (delegate.isCanceled()) &#123;</div><div class="line">      <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></div><div class="line">      callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>如果看到这，还不理解为什么那就得好好补补 handler 的知识啦！</p><p>我这里推荐 melo 写的这篇，风趣易懂 <a href="http://www.jianshu.com/p/fad4e2ae32f5" target="_blank" rel="external">带着这篇去通关所有Handler的提问</a> 。</p><p>最后放上两张<a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit" target="_blank" rel="external">开源社区</a>画的流程图，我觉得特别清晰：</p><p><img src="http://ww4.sinaimg.cn/large/006tNbRwgw1f75954laycj30qo0k0aas.jpg" alt="23:27:17.jpg"></p><p><img src="http://ww3.sinaimg.cn/large/006tNbRwgw1f7595w93nej30l70e6t9l.jpg" alt="23:28:01.jpg"></p><p><strong>以上。〃´∀`)</strong></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.jianshu.com/p/a56c61da55dd" target="_blank" rel="external">Retrofit2源码分析[动态代理]</a></li><li><a href="http://blog.csdn.net/giserstone/article/details/17199755" target="_blank" rel="external">Java静态代理和动态代理</a></li><li><a href="http://blog.csdn.net/zhangjg_blog/article/details/18735243" target="_blank" rel="external">一个示例让你明白适配器模式</a></li><li><a href="http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Retrofit分析-漂亮的解耦套路</a></li><li><a href="http://blog.fangjie.info/2016/07/14/%E6%88%91%E5%AF%B9Retrofit%E7%9A%84%E8%AE%A4%E8%AF%86/" target="_blank" rel="external">我对Retrofit的认识</a></li><li><a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tool-lib/network/retrofit" target="_blank" rel="external">Retrofit 源码分析</a></li><li><a href="http://wiki.jikexueyuan.com/project/java-reflection/java-at.html" target="_blank" rel="external">Java 注解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看过很多篇 Retrofit 的源码分析文章，但是别人一问起来总是讲不清楚到底 Retrofit 是怎么个流程，所以还是得自己亲自去看看源码，一步一步的分析。果然只有亲自动手实践，才有自己的收获。&lt;br&gt;告诫自己，&lt;strong&gt;慢慢来，会很快。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 基础复习实践 --- CallBack</title>
    <link href="http://imxie.cc/2016/07/23/let-s-talk-about-callback/"/>
    <id>http://imxie.cc/2016/07/23/let-s-talk-about-callback/</id>
    <published>2016-07-23T02:54:27.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>很早之前不知道如何解释清楚回调函数（CallBack），在知乎上看到一个回答特别形象，当时就收藏了，所以今天决定用代码的形式再让这个回答更加深刻点。</p><p><a href="https://www.zhihu.com/question/19801131" target="_blank" rel="external">知乎-回调函数（callback）是什么？</a></p><p>然后再看看 Android 里的应用。</p><a id="more"></a><ul><li><a href="#什么是回调函数">什么是回调函数</a></li><li><a href="#Android-里常见的回调">Android 里常见的回调</a></li></ul><h1 id="什么是回调函数"><a href="#什么是回调函数" class="headerlink" title="什么是回调函数"></a>什么是回调函数</h1><p>维基的解释：</p><blockquote><p>在计算机程序设计中，回调函数，或简称回调（Callback 即call then back 被主函数调用运算后会返回主函数），是指通过函数参数传递到其它代码的，某一块可执行代码的引用。这一设计允许了底层代码调用在高层定义的子程序。</p></blockquote><p>我认为通俗易懂的解释：</p><blockquote><p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。</p></blockquote><p>可能看着通俗的解释能够知道是怎么回事，但是轮到自己要去实现一个回调的时候，就有点寸步难行了。所以我简单将那个解释，转换成了代码再解释一番。</p><p>首先我得定义一个接口（我的电话号码）：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">INumber</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCall</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我去商店买东西，该商店对象刚刚初始化：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Store store = <span class="keyword">new</span> Store();</div></pre></td></tr></table></figure></p><p>然后我才得知商店刚刚开门没有我要的货（商店构造函数）:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Store</span><span class="params">()</span> </span>&#123;</div><div class="line">Utils.sout(<span class="string">"才开店，没有货"</span>);</div><div class="line">Utils.sout(<span class="string">"============="</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>所以我把我的电话号码留给店员，对于店员来说就是得到我的电话号码(注册事件)：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> INumber number;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(INumber number)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.number = number;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">    number.onCall();</div><div class="line">&#125;</div><div class="line"><span class="comment">/**************注册前的准备工作完毕**************/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Store store = <span class="keyword">new</span> Store();</div><div class="line">    <span class="comment">// 先注册好事件</span></div><div class="line">    store.setNumber(<span class="keyword">new</span> INumber() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCall</span><span class="params">()</span> </span>&#123;</div><div class="line">            Utils.sout(<span class="string">"============="</span>);</div><div class="line">            Utils.sout(<span class="string">"货到了"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">        Utils.sout(<span class="string">"模拟取货："</span> + i + <span class="string">"小时"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 货到了就打电话通知我</span></div><div class="line">    store.call();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>整体控制台输出：</p><blockquote><p>才开店，没有货<br>= = = = = = = = = = = = =<br>模拟取货：1小时<br>模拟取货：2小时<br>模拟取货：3小时<br>= = = = = = = = = = = = =<br>货到了</p></blockquote><hr><p>商店类的完整代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Store</span><span class="params">()</span> </span>&#123;</div><div class="line">Utils.sout(<span class="string">"才开店，没有货"</span>);</div><div class="line">Utils.sout(<span class="string">"============="</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> INumber number;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(INumber number)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.number = number;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">number.onCall();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">Store store = <span class="keyword">new</span> Store();</div><div class="line"></div><div class="line">store.setNumber(<span class="keyword">new</span> INumber() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCall</span><span class="params">()</span> </span>&#123;</div><div class="line">Utils.sout(<span class="string">"============="</span>);</div><div class="line">Utils.sout(<span class="string">"货到了"</span>);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">Utils.sout(<span class="string">"模拟取货："</span> + i + <span class="string">"小时"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">store.call();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="Android-里常见的回调"><a href="#Android-里常见的回调" class="headerlink" title="Android 里常见的回调"></a>Android 里常见的回调</h1><p>我们经常这样写：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">btShowDialog = (Button) findViewById(R.id.bt_showdialog);</div><div class="line">btShowDialog.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line"><span class="comment">// do something</span></div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>我们经常可以看到这样类似的代码，监听一个按钮的点击事件，当用户点击之后，我们执行一些逻辑。</p><p>这里的 <code>setOnClickListener()</code> 就跟我们之前店员获得我的电话号码的方法一样 <code>setNumber()</code> 注册好事件。<br>源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Register a callback to be invoked when this view is clicked. If this view is not</span></div><div class="line"><span class="comment"> * clickable, it becomes clickable.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> l The callback that will run</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@see</span> #setClickable(boolean)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(@Nullable OnClickListener l)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (!isClickable()) &#123;</div><div class="line">setClickable(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line">getListenerInfo().mOnClickListener = l;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Interface definition for a callback to be invoked when a view is clicked.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span> </span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Called when a view has been clicked.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> v The view that was clicked.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>到这里的时候是不是就很清晰了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早之前不知道如何解释清楚回调函数（CallBack），在知乎上看到一个回答特别形象，当时就收藏了，所以今天决定用代码的形式再让这个回答更加深刻点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/19801131&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;知乎-回调函数（callback）是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后再看看 Android 里的应用。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 基础 -- 生命周期和启动模式实践总结</title>
    <link href="http://imxie.cc/2016/07/21/Activity-lifecycle-launchmode/"/>
    <id>http://imxie.cc/2016/07/21/Activity-lifecycle-launchmode/</id>
    <published>2016-07-21T06:14:01.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Activity / Fragment 的生命周期是每个 Android 开发者最最基础的知识点。所以特别有必要自己整理一番。总看别人博客和书上的死知识，还不如自己动手实践，然后输出要印象深刻，理解透彻。</p><a id="more"></a><ul><li><a href="#Activity-生命周期">Activity 生命周期</a><ul><li><a href="#正常情况下的生命周期分析">正常情况下的生命周期分析</a></li><li><a href="#异常状态下的生命周期">异常状态下的生命周期</a></li></ul></li><li><a href="#Fragment">Fragment</a><ul><li><a href="#普通的-Fragment">普通的 Fragment</a></li><li><a href="#ViewPager-中的-Fragment">ViewPager 中的 Fragment</a></li></ul></li><li><a href="#启动模式">启动模式</a><ul><li><a href="#Activity-的四种启动模式">Activity 的四种启动模式</a></li><li><a href="#具体实践">具体实践</a></li></ul></li><li><a href="#参考文档">参考文档</a></li></ul><h3 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h3><h4 id="正常情况下的生命周期分析"><a href="#正常情况下的生命周期分析" class="headerlink" title="正常情况下的生命周期分析"></a>正常情况下的生命周期分析</h4><p><img src="/images/activitylife.png" alt=""></p><ol><li><p>针对一个特定的 Activity ，第一次启动，回调如下：<code>onCreate</code> —-&gt; <code>onStart</code> —-&gt; <code>onResume</code></p><blockquote><p>Log 日志<br>D/KLog: (MainActivity.java:19) onCreate<br>D/KLog: (MainActivity.java:44) onStart<br>D/KLog: (MainActivity.java:62) onResume</p></blockquote></li><li><p>切换回到桌面的时候，回调如下：<code>onPause</code> —-&gt; <code>onStop</code></p><blockquote><p>Log 日志<br>D/KLog: (MainActivity.java:50) onPause<br>D/KLog: (MainActivity.java:68) onStop</p></blockquote></li><li><p>Back 键退出的话，最后会 <code>onDestroy</code></p></li><li><p>启动一个新的 Activity , 我们看看两个 Activity 的生命周期：</p><blockquote><p>Log 日志<br>D/KLog: (MainActivity.java:50) onPause<br>D/KLog: (OtherActivity.java:25) onCreate<br>D/KLog: (OtherActivity.java:31) onStart<br>D/KLog: (OtherActivity.java:49) onResume<br>D/KLog: (MainActivity.java:68) onStop<br>可以得到顺序是：<code>onPause(A)</code> —-&gt; <code>onCreate(B)</code> —-&gt; <code>onStart(B)</code> —-&gt;  <code>onResume(B)</code> —-&gt; <code>onStop(A)</code></p></blockquote></li><li><p>这个时候我们 Back 回到第一个 Activity 时发生的回调：</p><blockquote><p>Log 日志<br>D/KLog: (OtherActivity.java:37) onPause<br>D/KLog: (MainActivity.java:56) onRestart<br>D/KLog: (MainActivity.java:44) onStart<br>D/KLog: (MainActivity.java:62) onResume<br>D/KLog: (OtherActivity.java:55) onStop<br>D/KLog: (OtherActivity.java:61) onDestroy<br>可以得到顺序是： <code>onPause(B)</code> —-&gt; <code>onRestart(A)</code> —-&gt; <code>onStart(A)</code> —-&gt; <code>onResume(A)</code> —-&gt; <code>onStop(B)</code> —-&gt; <code>onDestroy(B)</code></p></blockquote></li><li><p>如果我在 B Activity 中的 <code>onCreate</code> 回调中直接 <code>finish()</code>：</p><blockquote><p>Log 日志<br>D/KLog: (MainActivity.java:50) onPause<br>D/KLog: (OtherActivity.java:25) onCreate<br>D/KLog: (MainActivity.java:62) onResume<br>D/KLog: (OtherActivity.java:62) onDestroy<br>我们发现 B Activity 只会执行 <code>onCreate</code> 和 <code>onDestroy</code>。</p></blockquote></li><li><p>接下来我们启动一个特殊的 Activity （半透明或者对话框样式）到关闭它：</p><blockquote><p>Log 日志<br>D/MainActivity: onPause<br>D/DialogActivity: onCreate<br>D/DialogActivity: onStart<br>D/DialogActivity: onResume<br>D/DialogActivity: onPause<br>D/MainActivity: onResume<br>D/DialogActivity: onStop<br>D/DialogActivity: onDestroy</p></blockquote><p> 在正常使用应用的过程中，前台 Activity 有时会被其他导致 Activity 暂停的可视组件阻挡。 例如，当半透明 Activity 打开时（比如对话框样式中的 Activity ），上一个 Activity 会暂停。 只要 Activity 仍然部分可见但目前又未处于焦点之中，它会一直暂停。</p></li></ol><p><img src="/images/Dialog_activity.gif" alt=""></p><div class="tip"><br>问题：如果是启动一个普通的 Dialog ，Activity 的会执行 onPause 吗？<br></div><p>答案是不会的，我们可以这样理解，普通的 dialog 是依附在本 Activity 的，相当于是一个整体，所以它本身的焦点也是属于 Activity 的。故不会调用 onPause 。</p><h4 id="异常状态下的生命周期"><a href="#异常状态下的生命周期" class="headerlink" title="异常状态下的生命周期"></a>异常状态下的生命周期</h4><p><img src="/images/basic-lifecycle-savestate.png" alt=""></p><p><code>onSaveInstanceState</code> 方法只会出现在 <code>Activity</code> 被异常终止的情况下，它的调用时机是在 <code>onStop</code> 之前，它和 <code>onPause</code> 方法没有既定的时序关系，可能在它之前，也可能在它之后。当 <code>Activity</code> 被重新创建的时候， <code>onRestoreInstanceState</code> 会被回调，它的调用时机是 <code>onStart</code> 之后。<br>系统只会在 <code>Activity</code> 即将被销毁并且有机会重新显示的情况下才会去调用 <code>onSaveInstanceState</code> 方法。<br>当 <code>Activity</code> 在异常情况下需要重新创建时，系统会默认为我们保存当前 <code>Activity</code> 的视图结构，并且在 <code>Activity</code> 重启后为我们恢复这些数据，比如文本框中用户输入的数据、<code>listview</code> 滚动的位置等，这些 <code>view</code> 相关的状态系统都会默认为我们恢复。具体针对某一个 <code>view</code> 系统能为我们恢复哪些数据可以查看 <code>view</code> 的源码中的 <code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code> 方法。</p><p>Demo 代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onSaveInstanceState(outState);</div><div class="line">    KLog.d(getClass().getSimpleName(),<span class="string">"onSaveInstanceState"</span>);</div><div class="line">    outState.putString(STATE, <span class="string">"test"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</div><div class="line">    KLog.d(getClass().getSimpleName(),<span class="string">"[onRestoreInstanceState]: "</span> + savedInstanceState.getString(STATE));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>为了方便我们旋转下屏幕来异常终止 Activity :</p><blockquote><p>Log 日志<br>D/MainActivity: onPause<br>D/MainActivity: onSaveInstanceState<br>D/MainActivity: onStop<br>D/MainActivity: onDestroy<br>D/MainActivity: onCreate<br>D/MainActivity: onStart<br>D/MainActivity: [onRestoreInstanceState]: test<br>D/MainActivity: onResume</p></blockquote><p>摘自 <a href="https://book.douban.com/subject/26599538/" target="_blank" rel="external">Android 开发者艺术探索</a> 一书：</p><blockquote><p>关于保存和恢复 View 的层次结构，系统工作流程是： Activity 异常终止, Activity 调用 onSaveInstanceState 去保存数据，然后  Activity 会委托 Windows 去保存数据，接着 Window 再委托它上面的顶层容器去保存数据。顶层容器是一个 ViewGroup ，一般来说它很可能是 DectorView ，最后顶层容器再去通知它的子元素保存数据。（这是一种委托思想，上层委托下层，父容器委托子元素去处理事情，如 View 的绘制过程，事件分发都是采用类似的思想）</p></blockquote><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><h4 id="普通的-Fragment"><a href="#普通的-Fragment" class="headerlink" title="普通的 Fragment"></a>普通的 Fragment</h4><p><img src="/images/fragment_lifecycle.png" alt=""></p><p><img src="/images/fragment_activity.png" alt=""></p><p>从图可以看出，Fragment 生命周期大部分的状态与 Activity 相似，特殊的是</p><ul><li><code>onAttach()</code> —— 当 Fragment 被加入到 Activity 时调用(在这个方法中可以获得所在的 Activity ).</li><li><code>onCreateView()</code> —— 当 Activity 要得到 Fragment 的 Layout 时，调用此方法，Fragment 在其中创建自己的 Layout (界面)。</li><li><code>onActivityCreated()</code> —— 当 Activity 的 onCreated() 方法返回后调用此方法</li><li><code>onDestroyView()</code> —— 当 Fragment 中的视图被移除的时候，调用这个方法。</li><li><code>onDetach()</code> —— 当 Fragment 和 Activity 分离的时候，调用这个方法。</li></ul><h4 id="ViewPager-中的-Fragment"><a href="#ViewPager-中的-Fragment" class="headerlink" title="ViewPager 中的 Fragment"></a>ViewPager 中的 Fragment</h4><p>我们开发中经常会用到 ViewPager + Fragment 组合的形式来完成特定的需求。本身 Fragment 生命周期就比 Activity 要复杂很多，当它在 ViewPager 中又是怎么回调呢？</p><p>我先给 ViewPager 加入三个 Fragment:</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">viewPager = (ViewPager) findViewById(R.id.viewpager);</div><div class="line">fragmentList.add(<span class="keyword">new</span> OneTextFragment());</div><div class="line">fragmentList.add(<span class="keyword">new</span> TwoTextFragment());</div><div class="line">fragmentList.add(<span class="keyword">new</span> ThreeTextFragment());</div><div class="line">viewPager.setAdapter(<span class="keyword">new</span> FtAdapter(getSupportFragmentManager(), fragmentList));</div></pre></td></tr></table></figure><p>启动这个 Activity 的日志如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">D/ViewPagerHostActivity: onCreate</div><div class="line">D/ViewPagerHostActivity: onStart</div><div class="line">D/ViewPagerHostActivity: onResume</div><div class="line">D/OneTextFragment: onAttach</div><div class="line">D/OneTextFragment: onCreate</div><div class="line">D/TwoTextFragment: onAttach</div><div class="line">D/TwoTextFragment: onCreate</div><div class="line">D/TwoTextFragment: onActivityCreated</div><div class="line">D/OneTextFragment: onActivityCreated</div><div class="line">D/OneTextFragment: onStart</div><div class="line">D/OneTextFragment: onResume</div><div class="line">D/TwoTextFragment: onStart</div><div class="line">D/TwoTextFragment: onResume</div></pre></td></tr></table></figure><p>我们发现启动后，有两个 Fragment(one,two) 被创建，为什么会创建两个？这个问题我们留着后面说。</p><p>当 Activity 进入后台：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">D/ViewPagerHostActivity: onPause</div><div class="line">D/ViewPagerHostActivity: onSaveInstanceState</div><div class="line">D/TwoTextFragment: onStop</div><div class="line">D/OneTextFragment: onStop</div><div class="line">D/ViewPagerHostActivity: onStop</div></pre></td></tr></table></figure><p>当 Activity 返回前台：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">D/ViewPagerHostActivity: onRestart</div><div class="line">D/TwoTextFragment: onStart</div><div class="line">D/OneTextFragment: onStart</div><div class="line">D/ViewPagerHostActivity: onStart</div><div class="line">D/ViewPagerHostActivity: onResume</div><div class="line">D/TwoTextFragment: onResume</div><div class="line">D/OneTextFragment: onResume</div></pre></td></tr></table></figure></p><p>当 Activity 销毁：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">D/ViewPagerHostActivity: onPause</div><div class="line">D/TwoTextFragment: onStop</div><div class="line">D/OneTextFragment: onStop</div><div class="line">D/ViewPagerHostActivity: onStop</div><div class="line">D/TwoTextFragment: onDestroyView</div><div class="line">D/TwoTextFragment: onDestroy</div><div class="line">D/TwoTextFragment: onDetach</div><div class="line">D/OneTextFragment: onDestroyView</div><div class="line">D/OneTextFragment: onDestroy</div><div class="line">D/OneTextFragment: onDetach</div><div class="line">D/ViewPagerHostActivity: onDestroy</div></pre></td></tr></table></figure></p><p>滑动一页：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">D/ThreeTextFragment: onAttach</div><div class="line">D/ThreeTextFragment: onCreate</div><div class="line">D/ThreeTextFragment: onActivityCreated</div><div class="line">D/ThreeTextFragment: onStart</div><div class="line">D/ThreeTextFragment: onResume</div></pre></td></tr></table></figure></p><p>当前显示的页面是 TwoTextFragment 然后 ThreeTextFragment 也已经创建好了。</p><p>再滑动一页：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">D/OneTextFragment: onStop</div><div class="line">D/OneTextFragment: onDestroyView</div></pre></td></tr></table></figure></p><p>当前显示的页面是 ThreeTextFragment ，我们发现 OneTextFragment 已经销毁。</p><p>我们可以得到默认状态下的 ViewPager 会缓存 1 个 Fragment，相当于有两个 Fragment 是创建状态。<br>当我们增加一行代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">viewPager.setOffscreenPageLimit(<span class="number">2</span>);</div></pre></td></tr></table></figure></p><p>当 Activity 创建时的生命周期：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">D/ViewPagerHostActivity: onCreate</div><div class="line">D/ViewPagerHostActivity: onStart</div><div class="line">D/ViewPagerHostActivity: onResume</div><div class="line">D/OneTextFragment: onAttach</div><div class="line">D/OneTextFragment: onCreate</div><div class="line">D/TwoTextFragment: onAttach</div><div class="line">D/TwoTextFragment: onCreate</div><div class="line">D/ThreeTextFragment: onAttach</div><div class="line">D/ThreeTextFragment: onCreate</div><div class="line">D/TwoTextFragment: onActivityCreated</div><div class="line">D/OneTextFragment: onActivityCreated</div><div class="line">D/OneTextFragment: onStart</div><div class="line">D/OneTextFragment: onResume</div><div class="line">D/TwoTextFragment: onStart</div><div class="line">D/TwoTextFragment: onResume</div><div class="line">D/ThreeTextFragment: onStart</div><div class="line">D/ThreeTextFragment: onResume</div></pre></td></tr></table></figure></p><p>三个 Fragment 都创建好了，并且左右切换不会走任何生命周期（虽然是废话）。</p><p>setOffscreenPageLimit 源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOffscreenPageLimit</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (limit &lt; DEFAULT_OFFSCREEN_PAGES) &#123;</div><div class="line">Log.w(TAG, <span class="string">"Requested offscreen page limit "</span> + limit + <span class="string">" too small; defaulting to "</span> +</div><div class="line">DEFAULT_OFFSCREEN_PAGES);</div><div class="line">limit = DEFAULT_OFFSCREEN_PAGES;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (limit != mOffscreenPageLimit) &#123;</div><div class="line">mOffscreenPageLimit = limit;</div><div class="line">populate();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过源码我们可以知道，ViewPager 的缓存的默认值和最小值是 <strong>1</strong>。</p><h3 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h3><h4 id="Activity-的四种启动模式"><a href="#Activity-的四种启动模式" class="headerlink" title="Activity 的四种启动模式"></a>Activity 的四种启动模式</h4><ul><li><p>Standard：标准模式，一调用 startActivity() 方法就会产生一个新的实例。</p></li><li><p>SingleTop: 来了 intent, 每次都创建新的实例，仅一个例外：当栈顶的activity 恰恰就是该activity的实例（即需要创建的实例)时，不再创建新实例。这解决了栈顶复用问题</p></li><li><p>SingleTask: 来了 intent 后，检查栈中是否存在该 activity的实例，如果存在就把 intent 发送给它，否则就创建一个新的该activity的实例，放入一个新的 task 栈的栈底。肯定位于一个 task 的栈底，而且栈中只能有它一个该 activity 实例，但允许其他 activity 加入该栈。解决了在一个 task 中共享一个 activity。</p></li><li><p>SingleInstance: 这个跟 SingleTask 基本上是一样，只有一个区别：在这个模式下的Activity实例所处的task中，只能有这个activity实例，不能有其他的实例。一旦该模式的activity的实例已经存在于某个栈中，任何应用在激活该activity时都会重用该栈中的实例，解决了多个task共享一个 activity。</p></li></ul><p>这些启动模式可以在功能清单文件 AndroidManifest.xml 中进行设置，中的 launchMode 属性。</p><h4 id="具体实践"><a href="#具体实践" class="headerlink" title="具体实践"></a>具体实践</h4><ul><li><strong>SingleTop</strong> 栈顶复用模式</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".dLaunchChapter.OneActivity"</span></span></div><div class="line"><span class="tag"><span class="attr">android:launchMode</span>=<span class="string">"singleTop"</span>/&gt;</span></div></pre></td></tr></table></figure><p>我们在清单里先给 OneActivity 启动模式设置为 singleTop ，然后代码启动活动的顺序为 <code>One --&gt; One</code>，反复点击多次，然后我们看看栈内情况。</p><p>adb 命令 ：<code>dumpsys activity | grep -i run</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">root@vbox86p:/ # dumpsys activity | grep -i run</div><div class="line">    Running activities (most recent first):</div><div class="line">        Run #1: ActivityRecord&#123;23e3b5b u0 com.hugo.demo.activitydemo/.dLaunchChapter.OneActivity t595&#125;</div><div class="line">        Run #0: ActivityRecord&#123;1a2c6f3 u0 com.hugo.demo.activitydemo/.LaunchActivity t595&#125;</div></pre></td></tr></table></figure></p><p>该启动模式下并且 OneActivity 在栈顶所以不会创建新的实例，其生命周期调用 <code>onPause —-&gt; onNewIntent —-&gt; onResume</code></p><ul><li><strong>SingleTask</strong> 栈内复用模式</li></ul><p>修改 OneActivity 的启动模式为 SingleTask ，然后我们代码启动的顺序为 <code>One —-&gt; Two —-&gt; One</code>，接了下看看栈内情况：</p><p><code>One —-&gt; Two</code> 我们记录下当前的 Activity 栈：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Running activities (most recent first):</div><div class="line">        Run #2: ActivityRecord&#123;1e8701b7 u0 com.hugo.demo.activitydemo/.dLaunchChapter.TwoActivity t632&#125;</div><div class="line">        Run #1: ActivityRecord&#123;39e11719 u0 com.hugo.demo.activitydemo/.dLaunchChapter.OneActivity t632&#125;</div></pre></td></tr></table></figure><p>接下来我们执行 <code>Two —-&gt; One</code> ，当前 Activity 栈信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Running activities (most recent first):</div><div class="line">   Run #1: ActivityRecord&#123;39e11719 u0 com.hugo.demo.activitydemo/.dLaunchChapter.OneActivity t632&#125;</div></pre></td></tr></table></figure><p>当 TwoActivity 启动 OneActivity（SingleTask） 的时候，堆栈信息里只剩下了 OneActivity 并且和第一次内存信息 <strong>39e11719</strong> 相同，所以确实是复用了没有新建实例，接下来我们看看 Log 日志，再验证下我们的猜想，看看具体走了哪些生命周期：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">D/TwoActivity: onPause</div><div class="line">D/OneActivity: onNewIntent</div><div class="line">D/OneActivity: onRestart</div><div class="line">D/OneActivity: onStart</div><div class="line">D/OneActivity: onResume</div><div class="line">D/TwoActivity: onStop</div><div class="line">D/TwoActivity: onDestroy</div></pre></td></tr></table></figure><p>果然此时 OneActivity 没有重新创建，并且系统把它切换到了栈顶并调用 onNewIntent 方法，同时我们发现， SingleTask 默认具有 clearTop 效果，导致 TwoActivity 出栈。</p><div class="tip"><br>我们代码指定 OneActivity 的栈，效果还是一样的吗？<br></div><p>带着问题我们修改下代码，增加一行：<br><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span></span></div><div class="line"><span class="tag"><span class="attr">android:name</span>=<span class="string">".dLaunchChapter.OneActivity"</span></span></div><div class="line"><span class="tag"><span class="attr">android:launchMode</span>=<span class="string">"singleTask"</span></span></div><div class="line"><span class="tag"><span class="attr">android:taskAffinity</span>=<span class="string">"com.hugo.demo.singleTask"</span>/&gt;</span></div></pre></td></tr></table></figure></p><p>然后我们按照刚刚顺序 <code>One —-&gt; Two —-&gt; One</code> 启动 Activity ，现在的栈内信息还会更上次一样吗？<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Running activities (most recent first):</div><div class="line">        Run #2: ActivityRecord&#123;1bc18519 u0 com.hugo.demo.activitydemo/.dLaunchChapter.OneActivity t636&#125;</div><div class="line">        Run #1: ActivityRecord&#123;36e5e368 u0 com.hugo.demo.activitydemo/.dLaunchChapter.TwoActivity t635&#125;</div></pre></td></tr></table></figure></p><p>我们发现，虽然是复用了 OneActivity 而且移到了栈顶，但是并没有销毁 TwoActivity 。</p><p>原因在于 singleTask 模式受 <a href="https://developer.android.com/guide/topics/manifest/activity-element.html?hl=zh-cn#aff" target="_blank" rel="external">taskAffinity</a> 影响，TwoActivity 和 OneActivity 所在的 Activity 栈不同。</p><p>总结，启动一个 lauchMode 为 singleTask 的 Activity 时有两种情况:</p><blockquote><ol><li>若系统中存在相同 taskAffinity 值的任务栈 (tacks1 )时,会把 task1 从后台调到前台，若实例存在则干掉其上面的所有 Activity 并调用 onNewInstance 方法重用，没有该实例则新建一个。</li><li>否则，新建一个任务栈，并以此 Activity 作为 root 。</li></ol></blockquote><ul><li>SingleInstance 单实例模式</li></ul><p>这是一种加强的 singleTask 模式，它除了具有 singleTask 模式的所有特性以外，还加强了一点，就是具有此模式的 Activity 只能单独地位于任务栈。</p><div class="tip"><br>好了，关于生命周期和启动模式实践+知识点整理已经完成啦，<br>非常推荐大家下载源码自己运行看看 Log 日志，查看源码：<a href="https://github.com/xcc3641/ActivityLifeDemo" target="_blank" rel="external">Github</a><br>，这样可以对这篇文章知识更加深刻。<br></div><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li>Android 开发艺术探索 第一章</li><li><a href="https://developer.android.com/training/basics/activity-lifecycle/index.html" target="_blank" rel="external">管理Activity生命周期</a></li><li><a href="http://stackoverflow.com/questions/11549366/print-the-current-back-stack-in-the-log/11549400#11549400" target="_blank" rel="external">Print the current back stack in the log</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Activity / Fragment 的生命周期是每个 Android 开发者最最基础的知识点。所以特别有必要自己整理一番。总看别人博客和书上的死知识，还不如自己动手实践，然后输出要印象深刻，理解透彻。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 基础复习实践 --- Hashcode Equals</title>
    <link href="http://imxie.cc/2016/07/18/Review-the-Java-basic-equals-hashcode/"/>
    <id>http://imxie.cc/2016/07/18/Review-the-Java-basic-equals-hashcode/</id>
    <published>2016-07-18T06:14:31.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然很多知识点书籍都有整理，但是记性总是不好，所以决定将一些细小容易混淆的概念，通过简单的 Demo 实践，加深复习。特此开一个坑，坚持就是胜利。</p><p>本章内容主要为了理解以下几个知识点：</p><ul><li>equals() 的作用是什么？</li><li>equals() 与 “==”的区别是什么？</li><li>hashcode() 的作用是什么？</li><li>hashcode() 与 equals（）之间有什么联系？</li></ul><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><!-- toc --><ul><li><a href="#目录">目录</a></li><li><a href="#0x01-equals-的作用">0x01 equals() 的作用</a><ul><li><a href="#没有覆盖-equals-方法">没有覆盖 equals() 方法</a></li><li><a href="#覆盖-equals-方法">覆盖 equals() 方法</a></li><li><a href="#tips">Tips</a></li></ul></li><li><a href="#0x02-equals-与-的区别">0x02 equals() 与 == 的区别</a></li><li><a href="#0x03-hashcode-的作用">0x03 hashcode() 的作用</a></li><li><a href="#0x04-hashcode-和-equals-的关系">0x04 hashCode() 和 equals() 的关系</a></li><li><a href="#参考文档">参考文档</a></li></ul><!-- tocstop --><h1 id="0x01-equals-的作用"><a href="#0x01-equals-的作用" class="headerlink" title="0x01 equals() 的作用"></a>0x01 equals() 的作用</h1><blockquote><p>Indicates whether some other object is “equal to” this one.</p></blockquote><p>equals()是用来 <strong>判断两个对象是否相等</strong>。</p><p>equals() 定义在 JDK 的 Object.java 中。通过判断两个对象的地址是否相等(即，是否是同一个对象)来区分它们是否相等。源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>既然是在 Object 类中定义了该方法，就表明了 Java 所有类都实现了 equals() 方法，所以所有类都可以通过该方法去判断两个对象是否相等。<br>默认的 equals（） 方法等同于 ”==” 方法，所以我们一般会重写 equals（） 方法 —-&gt; 两个对象的内容相等，返回 true ，否则返回 false。</p><p>所以我们可以根据是否 <strong>重写 equals()</strong> 方法将类分为两类：</p><p>1.若某个类没有覆盖 equals() 方法，当它的通过 equals() 比较两个对象时，实际上是比较两个对象是不是同一个对象。这时，等价于通过“==”去比较这两个对象</p><p>2.覆盖类的 equals() 方法，来让 equals() 通过其它方式比较两个对象是否相等。通常的做法是：若两个对象的内容相等，则 equals()方法返回true；否则，返回 false 。</p><h2 id="没有覆盖-equals-方法"><a href="#没有覆盖-equals-方法" class="headerlink" title="没有覆盖 equals() 方法"></a>没有覆盖 equals() 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashcodeAndEquals</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">System.out.println(t);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// 实例化两个 Person 对象</span></div><div class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"小明"</span>, <span class="number">12</span>);</div><div class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"小明"</span>, <span class="number">12</span>);</div><div class="line"><span class="comment">// 通过 equals() 比较他们是否相等</span></div><div class="line">out(p1.equals(p2));</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> age;</div><div class="line">String name;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">return</span> name + <span class="string">"--- age:"</span> + age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>输出为<br>false</p></blockquote><p>结论：</p><div class="tip"><br>当我们使用 <code>p1.equals(p2)</code> 来比较 p1 和 p2 是否相等时，实际上是调用了 object 类的 equals() 方法，即 “p1==p2”，它是比较 p1 和 p2 是否为一个对象。<br><br>由定义可知，p1 和 p2 虽然内容相同，但是它们是两个不同的对象。因此，返回 false 。<br></div><h2 id="覆盖-equals-方法"><a href="#覆盖-equals-方法" class="headerlink" title="覆盖 equals() 方法"></a>覆盖 equals() 方法</h2><p>我们简单修改下 <code>HashcodeAndEquals.java</code> 文件，覆盖 <strong>equals() 方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashcodeAndEquals</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">System.out.println(t);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// 实例化两个 Person 对象</span></div><div class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"小明"</span>, <span class="number">12</span>);</div><div class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"小明"</span>, <span class="number">12</span>);</div><div class="line"><span class="comment">// 通过 equals() 比较他们是否相等</span></div><div class="line">out(p1.equals(p2));</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> age;</div><div class="line">String name;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.age = age;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">return</span> name + <span class="string">"--- age:"</span> + age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果是同一对象，返回 true</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 判断是否类型相同</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.getClass() != obj.getClass()) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">          <span class="comment">// 只有一下三种情况才能通过编译</span></div><div class="line"><span class="comment">// 1.instanceof前面的类型与后面的类型相同</span></div><div class="line"><span class="comment">// 2.instanceof前面的类型是后面的类型父类</span></div><div class="line"><span class="comment">// 3.instanceof前面的类型是后面的类型子类</span></div><div class="line"><span class="comment">// 故与我们判断类型相同有一点偏差</span></div><div class="line"><span class="comment">//</span></div><div class="line">          <span class="comment">// 这一点我们可以自己定义一个 Student 类继承 Person 类来进行实验</span></div><div class="line"><span class="comment">// if (!(obj instanceof Person)) &#123;</span></div><div class="line"><span class="comment">// return false;</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"></div><div class="line">Person per = (Person) obj;</div><div class="line"><span class="keyword">return</span> name.equals(per.name) &amp;&amp; age == per.age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>输出为<br>true</p></blockquote><p>结论：</p><div class="tip"><br>我们在新的 <code>HashcodeAndEquals.java</code> 文件中重写了 Person 类的 equals() 函数：当两个 Person 对象 name 和 age 都相等时，则返回 true ，因此结果为 true 。<br></div><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><blockquote><p>Java 对 equals() 的要求</p></blockquote><ol><li>对称性：如果 x.equals(y) 返回是” true “，那么 y.equals(x) 也应该返回是”true”。</li><li>反射性：x.equals(x) 必须返回是 “true” 。</li><li>类推性：如果 x.equals(y) 返回是”true”，而且 y.equals(z) 返回是”true”，那么 z.equals(x) 也应该返回是”true”。</li><li>一致性：如果 x.equals(y) 返回是”true”，只要x和y内容一直不变，不管你重复 x.equals(y) 多少次，返回都是”true”。</li><li>非空性，x.equals(null)，永远返回是”false”；x.equals (和x不同类型的对象)永远返回是”false”。</li></ol><h1 id="0x02-equals-与-的区别"><a href="#0x02-equals-与-的区别" class="headerlink" title="0x02 equals() 与 == 的区别"></a>0x02 equals() 与 == 的区别</h1><p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况(前面第1部分已详细介绍过)</p><p>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是否为同一个对象。</p><p>只用修改下<code>HashcodeAndEquals.java</code> 主函数为：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 实例化两个 Person 对象</span></div><div class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">"小明"</span>, <span class="number">12</span>);</div><div class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="string">"小明"</span>, <span class="number">12</span>);</div><div class="line">    <span class="comment">// 分别用 equals() 和 == 来判断</span></div><div class="line">    out(<span class="string">"equals: "</span> + p1.equals(p2));</div><div class="line">    out(<span class="string">"==: "</span> + (p1 == p2));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>输出为：<br>equals: true<br>==: false</p></blockquote><p>结果与我们预想的一样，因为我们是复写了 Person 类的 equals() 方法，而且 p1 p2 内容相同所以返回 true ，而 p1 p2 并是两个不同对象，所以 == 判断它们地址不相同，返回 false。</p><h1 id="0x03-hashcode-的作用"><a href="#0x03-hashcode-的作用" class="headerlink" title="0x03 hashcode() 的作用"></a>0x03 hashcode() 的作用</h1><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p>hashCode() 定义在 JDK 的 Object.java 中，这就意味着Java中的任何类都包含有 hashCode() 函数。</p><p>虽然，每个 Java 类都包含 hashCode() 函数。但是，仅仅当创建并某个“类的散列表”(关于“散列表”见下面说明)时，该类的 hashCode() 才有用(作用是：确定该类的每一个对象在散列表中的位置；其它情况下(例如，创建类的单个对象，或者创建类的对象数组等等)，类的 hashCode() 没有作用。</p><p>上面的散列表，指的是：Java集合中本质是散列表的类，如HashMap，Hashtable，HashSet。<br>也就是说：hashCode() 在散列表中才有用，在其它情况下没用。<br>在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><p>散列码的解释：</p><blockquote><p>我们都知道，散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！<br>散列表的本质是通过数组实现的。当我们要获取散列表中的某个“值”时，实际上是要获取数组中的某个位置的元素。而数组的位置，就是通过“键”来获取的；更进一步说，数组的位置，是通过“键”对应的散列码计算得到的。</p></blockquote><p>我们以 Hashset 为例来说明下 hashcode() 的作用：<br>首先我们都知道 HashSet 是 Set 的集合，不允许有重复的元素。当该 Set 已经有了 1000 个元素时，当插入第1001个元素时，需要怎么处理？ “将第1001个元素逐个的和前面1000个元素进行比较”？显然，这个效率是相等低下的。散列表很好的解决了这个问题，它根据元素的散列码计算出元素在散列表中的位置，然后将元素插入该位置即可。对于相同的元素，自然是只保存了一个。由此可知，若两个元素相等，它们的散列码一定相等；但反过来确不一定。<br>在散列表中，</p><ol><li>如果两个对象相等，那么它们的hashCode()值一定要相同；</li><li>如果两个对象hashCode()相等，它们并不一定相等。<br>注意：这是在散列表中的情况。在非散列表中一定如此！</li></ol><h1 id="0x04-hashCode-和-equals-的关系"><a href="#0x04-hashCode-和-equals-的关系" class="headerlink" title="0x04 hashCode() 和 equals() 的关系"></a>0x04 hashCode() 和 equals() 的关系</h1><p>我们修改主函数为：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">"小明"</span>, <span class="number">12</span>);</div><div class="line">    <span class="comment">// HashMap</span></div><div class="line">    HashMap&lt;Person, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    map.put(p1, <span class="number">1</span>);</div><div class="line">    out(map.get(<span class="keyword">new</span> Person(<span class="string">"小明"</span>, <span class="number">12</span>)));</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>按照理想中，我们输出的结果应该为 “1”，因为我们存入的 Person 和查找的 Person 都是“小明”，是同一个人。<br>但是最终运行该程序输出结果为：</p><blockquote><p>null</p></blockquote><p>所以按照设计标准我们应该在重写 equals() 方法的同时也要写重写 hashcode()。</p><p>虽然通过重写equals方法使得逻辑上姓名和年龄相同的两个对象被判定为相等的对象（跟String类类似），但是要知道默认情况下，hashCode 方法是将对象的存储地址进行映射。那么上述代码的输出结果为“null”就不足为奇了。</p><p>因为 p1 对象和 <code>new Person(&quot;小明&quot;, 12)</code> 生成的对象是两个不同的对象，它们的存储地址肯定不同，所以得到的 hashcode 值不同（不绝对，因为有哈希冲突的情况）。</p><p>所以现在重写下我们的 Person 类的 hashcode() 方法，利用 eclipse 自动生成如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</div><div class="line">    result = prime * result + age;</div><div class="line">    result = prime * result + ((name == <span class="keyword">null</span>) ? <span class="number">0</span> : name.hashCode());</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在我们再次运行程序得到结果：</p><blockquote><p>1</p></blockquote><p>与预期一致。</p><p>摘自Effective Java一书：</p><blockquote><ul><li>在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。</li><li>如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。</li><li>如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。</li></ul></blockquote><p>对于第一条，我们通过一个例子来验证：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">"小明"</span>, <span class="number">12</span>);</div><div class="line">    out(<span class="string">"初始值："</span> + p1.hashCode());</div><div class="line">    HashMap&lt;Person, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    map.put(p1, <span class="number">1</span>);</div><div class="line">    p1.age = <span class="number">13</span>;</div><div class="line">    out(<span class="string">"更新后："</span> + p1.hashCode());</div><div class="line">    out(map.get(p1));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>输出结果为：</p><blockquote><p>初始值：758036<br>更新后：758067<br>null</p></blockquote><p>其中原因我就不用多说了，因此，在设计 hashCode 方法和 equals 方法的时候，如果对象中的数据易变，则最好在 equals 方法和 hashCode 方法中不要依赖于该字段。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="http://www.importnew.com/8189.html" target="_blank" rel="external">如何生成一个合适的hashcode方法</a></li><li><a href="http://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="external">Java hashCode() 和 equals()</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然很多知识点书籍都有整理，但是记性总是不好，所以决定将一些细小容易混淆的概念，通过简单的 Demo 实践，加深复习。特此开一个坑，坚持就是胜利。&lt;/p&gt;
&lt;p&gt;本章内容主要为了理解以下几个知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;equals() 的作用是什么？&lt;/li&gt;
&lt;li&gt;equals() 与 “==”的区别是什么？&lt;/li&gt;
&lt;li&gt;hashcode() 的作用是什么？&lt;/li&gt;
&lt;li&gt;hashcode() 与 equals（）之间有什么联系？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Update Ruby With RVM About Brew Error</title>
    <link href="http://imxie.cc/2016/07/13/Update-Ruby-With-RVM-About-Brew-Error/"/>
    <id>http://imxie.cc/2016/07/13/Update-Ruby-With-RVM-About-Brew-Error/</id>
    <published>2016-07-13T02:51:52.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>要运行 IOS 的应用程序，需要安装 <a href="http://code4app.com/article/cocoapods-install-usage" target="_blank" rel="external">CocoaPods</a> ，然后又需要 Ruby ，发现安装的时候说 Ruby 版本过低（我 MBP 自带的版本号是 2.0 ==&gt; 2.2.2），所以又得找个 RVM 用来升级 Ruby。</p><a id="more"></a><h1 id="安装-RVM"><a href="#安装-RVM" class="headerlink" title="安装 RVM"></a>安装 RVM</h1><blockquote><p>$ curl -L get.rvm.io | bash -s stable</p></blockquote><p>等待之后</p><blockquote><p>  $ source ~/.bashrc<br>  $ source ~/.bash_profile</p></blockquote><p>测试是否正常</p><blockquote><p>   $ rvm -v</p></blockquote><h1 id="升级-Ruby"><a href="#升级-Ruby" class="headerlink" title="升级 Ruby"></a>升级 Ruby</h1><blockquote><p>$ rvm install 2.2.4</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Found remote file https://rvm_io.global.ssl.fastly.net/binaries/osx/10.11/x86_64/ruby-2.2.2.tar.bz2</div><div class="line">Checking requirements for osx.</div><div class="line">ERROR: &apos;/usr/local/Cellar&apos; is not writable - it is required for Homebrew, try &apos;brew doctor&apos; to fix it!</div><div class="line">Requirements installation failed with status: 1.</div></pre></td></tr></table></figure><p>遇到上述错误。</p><p>解决方案：</p><blockquote><p>sudo chown -R $USER /usr/local</p></blockquote><p>再次运行</p><blockquote><p>rvm install 2.2.2</p></blockquote><p>等待升级完成。</p><h1 id="安装-CocoaPods"><a href="#安装-CocoaPods" class="headerlink" title="安装 CocoaPods"></a>安装 CocoaPods</h1><p>因为GFW，所以我们可以用淘宝的 Ruby 镜像来访问 cocoapods 。按照下面的顺序在终端中敲入依次敲入命令：</p><blockquote><p>$ gem sources –remove <a href="https://rubygems.org/" target="_blank" rel="external">https://rubygems.org/</a><br>//等有反应之后再敲入以下命令<br>$ gem sources -a <a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a></p></blockquote><p>为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看：</p><blockquote><p>▶ gem sources -l</p></blockquote><p>出现这个就可以了：</p><blockquote><p><strong><em> CURRENT SOURCES </em></strong><br><a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a></p></blockquote><p>最后进行安装：</p><blockquote><p>$ sudo gem install cocoapods</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要运行 IOS 的应用程序，需要安装 &lt;a href=&quot;http://code4app.com/article/cocoapods-install-usage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPods&lt;/a&gt; ，然后又需要 Ruby ，发现安装的时候说 Ruby 版本过低（我 MBP 自带的版本号是 2.0 ==&amp;gt; 2.2.2），所以又得找个 RVM 用来升级 Ruby。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://imxie.cc/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="IOS" scheme="http://imxie.cc/tags/IOS/"/>
    
      <category term="Ruby" scheme="http://imxie.cc/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>一次 Android Day/Night 实践（夜间模式）</title>
    <link href="http://imxie.cc/2016/07/12/Android-New-Day-Night-Swtich/"/>
    <id>http://imxie.cc/2016/07/12/Android-New-Day-Night-Swtich/</id>
    <published>2016-07-12T02:09:39.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>用过 就看天气 的话，都会发现，它在 18：00 的时候会自动切换成夜间模式，当时使用的方法是在创建视图的时候就判断当前手机时间，再进行一些 UI 的改变。这样的做法不是特别的 cool ，无意之间发现 Android 23.2.0 的包下提供了 日/夜间 主题，所以立马就加入 就看天气 ，让我们来看看如何使用吧。</p><a id="more"></a><h4 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h4><p>首先你得先在你的 <code>style.xml</code>  文件里，把你的主题继承 DayNight 主题，像这样：</p><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span></span></div><div class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.DayNight.DarkActionBar"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="xml">        <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></span></div><div class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></div><div class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>@color/colorPrimaryDark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></div><div class="line"><span class="xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>@color/colorAccent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><p>它有四个可选值，分别是：</p><ul><li>MODE_NIGHT_NO： 使用亮色(light)主题，不使用夜间模式</li><li>MODE_NIGHT_YES：使用暗色(dark)主题，使用夜间模式</li><li>MODE_NIGHT_AUTO：根据当前时间自动切换 亮色(light)/暗色(dark)主题</li><li>MODE_NIGHT_FOLLOW_SYSTEM(默认选项)：设置为跟随系统，通常为 MODE_NIGHT_NO</li></ul><p>推荐在 Application 添加一个静态代码块来进行初始化全局设置：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    AppCompatDelegate.setDefaultNightMode(</div><div class="line">        AppCompatDelegate.MODE_NIGHT_AUTO); <span class="comment">// 选择你需要的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="切换主题时使用自定义资源"><a href="#切换主题时使用自定义资源" class="headerlink" title="切换主题时使用自定义资源"></a>切换主题时使用自定义资源</h4><p>使用自定义资源，只需要在 res 目录下创建对应的 values-night 文件夹并创建对应的 themes.xml 文件：</p><h5 id="res-values-colors-xml"><a href="#res-values-colors-xml" class="headerlink" title="res/values/colors.xml"></a>res/values/colors.xml</h5><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>#106c99<span class="tag">&lt;/<span class="name">color</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>#0D4A6A<span class="tag">&lt;/<span class="name">color</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"colorAccent"</span>&gt;</span>#FC413D<span class="tag">&lt;/<span class="name">color</span>&gt;</span></div></pre></td></tr></table></figure><h5 id="res-values-night-colors-xml"><a href="#res-values-night-colors-xml" class="headerlink" title="res/values-night/colors.xml"></a>res/values-night/colors.xml</h5><figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>#201D45<span class="tag">&lt;/<span class="name">color</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"colorPrimaryDark"</span>&gt;</span>#201D45<span class="tag">&lt;/<span class="name">color</span>&gt;</span></div></pre></td></tr></table></figure><p>同理其他资源你只需要在末尾添加 <code>-night</code> 系统就会自动加载对应的文件了。</p><hr><p><img src="http://ww2.sinaimg.cn/large/006tNbRwgw1f5umljz70uj30zo1iqn2z.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/006tNbRwgw1f5umrv1sbpj30zo1iqjwv.jpg" alt=""></p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><p><a href="http://www.androidpolice.com/2016/02/24/android-support-library-v23-2-adds-auto-switching-daynight-theme-support-for-vector-drawables-and-much-more/" target="_blank" rel="external">Android Support Library v23.2 Adds Auto-Switching Day/Night Theme, Support For Vector Drawables, And Much More</a></p></li><li><p><a href="https://kingideayou.github.io/2016/03/07/appcompat_23.2_day_night/" target="_blank" rel="external">AppCompat v23.2 - 夜间模式最佳实践</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用过 就看天气 的话，都会发现，它在 18：00 的时候会自动切换成夜间模式，当时使用的方法是在创建视图的时候就判断当前手机时间，再进行一些 UI 的改变。这样的做法不是特别的 cool ，无意之间发现 Android 23.2.0 的包下提供了 日/夜间 主题，所以立马就加入 就看天气 ，让我们来看看如何使用吧。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://imxie.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://imxie.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>魔都实习之旅</title>
    <link href="http://imxie.cc/2016/07/11/Intern-life-in-SH/"/>
    <id>http://imxie.cc/2016/07/11/Intern-life-in-SH/</id>
    <published>2016-07-10T22:09:42.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Keep - Move - Think</p><a id="more"></a><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><blockquote><p>丙申年 乙未月 甲午日</p></blockquote><p>7点的东方航空。从重庆到上海浦东。顺风车是在5点，重邮新校门接的我，路上闲聊还知道，司机是老校友，那时候重邮末尾还跟着学院。</p><p>晚上十点左右收拾好东西，把华为的比赛作品也提交完成，还看完了 硅谷 第一季的最后两集。闷热，好像寝室的空调不怎么给力了，凌晨1点躺在床上还是觉得不舒服，辗转反侧，应该是没有睡着吧，一直等到四点半的闹钟，倒了垃圾，然后出发。</p><p>是靠窗的位置，眼睛还是特别累，马上又要去上海了，当初自己跟朋友明确表达过不喜欢的这个城市，然而人生 3.0 Hard Mode 起始点还是这里。</p><p>住在青旅，8人间，第一次住青旅，没有想象中的那么糟糕，也没有想象中的很多娱乐。有个法语专业的室友蛮有意思，当过兵，来上海是为了找一个跟专业相关的工作，所以住在“下一栈”青旅。他人还蛮好的，各种问题他都回答的蛮详细，后来才知道他以前早来过这里，并且还在这里兼过职。他跟我讲他在青旅认识的外国友人，他特别喜欢一个巴西的妹子，看上去很漂亮，而且才14岁。</p><p>吃过晚饭后，出去走了下，因为台风的原因吗？迎面而来的风特别肆虐，不过还好不闷热，蛮舒服。<br>今天办好了招行的卡，明天早上就准备去公司入职了。说实话还是蛮期待的。<br>嗯，晚安，加油。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><blockquote><p>丙申年  乙未月 乙未日 七月十二日</p></blockquote><p>每天记录还是不现实的，但今天是第一天入职，还是有很多体会。</p><p>早上7点就自然醒了，到公司是9点，人蛮少的，溜达了一转，觉得蛮酷。配了一个戴尔的屏幕，我是自带的 MBP ，所以环境什么的完全不需要配置。入职需要走一些流程，填表啊，申请邮箱啊，还要给全公司发介绍信。椅子坐着很舒服，公司蛮弹性的，而且没很多条条框框，待着很舒服。</p><p>晚上自愿加下班，九点坐了公交再走段路回青旅。</p><p>在上海，大家都嫌弃纸币喜欢硬币。<br>在上海，公交车说三种语言，就普通话声小。<br>在上海，地铁公交人满了下一班次也是满的。<br>在上海，感觉是一个特繁华的重庆。<br>在上海，遇到阿姨别叫嬢嬢了。</p><p>不过遇到了很多有意思的人。<br>对了，最近还喜欢李悦君的《梦伴》这首歌。</p><h1 id="Day-10"><a href="#Day-10" class="headerlink" title="Day 10"></a>Day 10</h1><blockquote><p>丙申年 乙未月 癸卯日</p></blockquote><p>周末跟上海的 Android 开发网友小聚，见到了给予我蛮多帮助的天哥和猴哥。大家都是特别有意思的家伙。</p><p>从青旅搬家到了哥哥那里住，浦东新区，开始挤地铁去上班，坐一个半小时。需要从2号线南京东路换乘10号线到江湾体育场。<br>在地铁上蛮花时间的，所以这几天也养成了背单词，刚好在早上，花点不多的时间，把软件上的每日60词刷完。</p><p>到了公司10点左右，开站会，早上自己决定看书，下午做项目。<br>其实来这里公司环境还是可以，同事们也都友善易相处。唯一对我来说的缺点就是没有能够聊 Android 的人吧。</p><p>校招也开始了，确实好快，又是一波面试。<br>虽然总能受到周遭人的鼓励和认可，但是自己几斤几两特别清楚。</p><h1 id="Day-26"><a href="#Day-26" class="headerlink" title="Day 26"></a>Day 26</h1><blockquote><p>丙申年  乙未月 庚申日</p></blockquote><p>很久没有更新这个篇章，上班真的蛮磨人的，从公司到住的地方需要一个半小时，回到家之后就特别累了然后就想休息，带回来的电脑然后明天又背着回去。</p><p>今天一大早也拿到了半个月的工资，特别愉悦~<br>本来今天周六，下午3点还是来公司学习，居然还碰到了运维的两个小伙伴。晚饭点的外卖，韩寒的那家，感觉没有他们说的那么难吃嘛。</p><p>DaoVoice 这周走了两个前端小伙伴，DaoCloud 也有其他部门的小伙伴离职，感觉在工作之后，分离也开始变得平常了起来，来来去去的，可能是因为第一次经历吧，或许以后会习惯的。<br>所以更加理解了<strong>一期一会</strong>的意思，得要以最好的方式对待对方。</p><p>最近的成果还是蛮明显的。<br>DaoVoice 框架+第一层逻辑已经完成，还完成了自己的小玩具，是运用 Leancloud 的云引擎——<a href="http://imxie.leanapp.cn" target="_blank" rel="external">这都被你找到了</a></p><p>越来越喜欢上海了诶。第一次来上海是带着玩的心态，这次是却是来生活，体会比原来更细致。</p><h1 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h1><p>浦东国际机场 宝山路 下一栈青旅 南京东路 五角场 广兰路 张江 香楠小区<br>-<br>波司登大厦 老板娘日式料理 米馆的火车头 暖食的侧脸服务员 星巴克的买二送一 全家的味全优酸乳 隔壁的盒装水果<br>-<br>小米粥 家制酸粉 家制混合饮品 望湘园 PizzaExpress 游轮晚宴 星怡会 家府潮仙菜<br>-<br>中山公园 龙之梦 （桂满陇）末那寿司 动漫画展 南京大牌档 香天下火锅 蕉叶 江湾体育场 西北狼烧烤 85℃ 蒸青年 上海歌神<br>-<br>钢炼 李狗嗨 请回答1988 gakki 乖巧 羁绊 友谊之水 中二之魂 嗨歌 歇斯底里 再见 朋友 写真集 月饼盒 两封信 同理心<br>-<br>香楠小区 张江 广兰路 虹桥<br>-<br>“有事开口，不要客气”<br>“天涯海角，唯望君安”<br>-<br>再见，上海。<br>这座偶尔温暖的城市。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Keep - Move - Think&lt;/p&gt;
    
    </summary>
    
      <category term="发骚" scheme="http://imxie.cc/categories/%E5%8F%91%E9%AA%9A/"/>
    
    
      <category term="实习" scheme="http://imxie.cc/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>自用 Mac 软件整理和推荐</title>
    <link href="http://imxie.cc/2016/07/08/My-Mac-Awesome-Apps/"/>
    <id>http://imxie.cc/2016/07/08/My-Mac-Awesome-Apps/</id>
    <published>2016-07-08T12:53:30.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>自己无论是 Android 手机上的软件还是 Mac 上的，都存有很多。<br>Mac 上大多都是为了提升工作效率，手机上除了必备的来说，其他都是为了给自己找灵感。</p><p>算个软件控吧。</p><a id="more"></a><!-- toc --><ul><li><a href="#技术">技术</a></li></ul><!-- tocstop --><h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><ol><li>IDEA</li></ol><p>Java 开发必备吧。<br>虽然我是个 Android 开发，但是偶尔还是会用到 IDEA 去写写 Java 程序的，并且还可以用这个给 AS 写插件。<br><img src="http://ww3.sinaimg.cn/large/7853084cgw1f81jtgf3egj21de0vs41y.jpg" alt=""></p><ol><li>Android Studio</li></ol><p>Android 开发必备。<br>这个不用多说，升级到 2.2 字体渲染比原来好多了。<br><img src="http://ww1.sinaimg.cn/large/7853084cgw1f81k1435jvj21de0vsn20.jpg" alt=""></p><ol><li>PyCharm</li></ol><p>偶尔写写 Python 玩的时候用下。<br><img src="http://ww4.sinaimg.cn/large/7853084cgw1f81k2cjn28j21de0vswhc.jpg" alt=""></p><ol><li>Sublime</li></ol><p>经常用它来看代码和轻量级的修改代码。<br>再加上 zsh 对它设置了快捷键，很方便打开路径文件夹。<br><img src="http://ww1.sinaimg.cn/large/7853084cgw1f81k6fdjwfj21kw10b444.jpg" alt=""></p><ol><li>Atom</li></ol><p>我比较喜欢用 Atom 来写博客，因为对文件管理和 Markdown 的渲染要好看很多。<br>但是还是有弊端的，在我这里如果篇幅过长还是蛮卡顿的。</p><p>不过目前来说还是可以忍受，毕竟还没有找到替代品。</p><p><img src="http://ww3.sinaimg.cn/large/7853084cgw1f81k8cy47hj21kw0zkn7s.jpg" alt=""></p><ol><li>Dash</li></ol><p>配合小帽子可以很快速的查看 API 信息，太方便了。<br>感恩。</p><p><img src="http://ww2.sinaimg.cn/large/7853084cgw1f81kboboeqj21kw0wrwmc.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/7853084cgw1f81kcgszu3j20x00syn0z.jpg" alt=""></p><ol><li>PDF Expert</li></ol><p>用这个软件看电子书，很舒服。<br>并且可以进行一些批注和记录。</p><p><img src="http://ww1.sinaimg.cn/large/7853084cgw1f81kdbea01j21kw17ajy9.jpg" alt=""></p><ol><li>Vysor</li></ol><p>Chrome 插件，很方便展示手机上的内容。</p><ul><li><a href="http://www.itdadao.com/articles/c15a508725p0.html" target="_blank" rel="external">修改最新版协议方法</a><br><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f8ssnm4jiej20v01iyn2b.jpg" alt=""><br>####</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己无论是 Android 手机上的软件还是 Mac 上的，都存有很多。&lt;br&gt;Mac 上大多都是为了提升工作效率，手机上除了必备的来说，其他都是为了给自己找灵感。&lt;/p&gt;
&lt;p&gt;算个软件控吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>不务正业—— Sketch 学习之路</title>
    <link href="http://imxie.cc/2016/07/04/Sketch-learning-as-android/"/>
    <id>http://imxie.cc/2016/07/04/Sketch-learning-as-android/</id>
    <published>2016-07-04T14:24:50.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>这篇纯粹是为了满足我一直崇拜设计师，业余时间向他们学习的记录。</p><a id="more"></a><h3 id="实战模仿"><a href="#实战模仿" class="headerlink" title="实战模仿"></a>实战模仿</h3><h4 id="雨滴"><a href="#雨滴" class="headerlink" title="雨滴"></a>雨滴</h4><p><img src="http://ww4.sinaimg.cn/large/006tNbRwgw1f79tx0g6goj31kw19uq7e.jpg" alt="22:28:18.jpg"></p><ul><li><p>教程来自 <a href="http://www.ui.cn/detail/34282.html" target="_blank" rel="external"><strong>使用Sketch 3设计水滴图标</strong></a></p></li><li><p>教程感受：</p><p>   简单学习了 Sketch 的插入图形（矩形，圆，三角形），学习到了内/外阴影、渐变的应用，同时还有两个图形的组合【Union】 </p></li></ul><h4 id="小鸟"><a href="#小鸟" class="headerlink" title="小鸟"></a>小鸟</h4><p><img src="http://ww1.sinaimg.cn/large/006y8lVagw1f7d2v66uruj31kw0zi0w7.jpg" alt="17:54:13.jpg"></p><ul><li><p>教程来自 <a href="http://www.sketchs.cn/tutorials/detail/204.html" target="_blank" rel="external"><strong>Sketch 创建小鸟图标</strong></a></p></li><li><p>教程感受：</p><p>   初步接触了钢笔工具的使用，同时巩固了图形的一些变换。不过对于蒙版和阴影还没有做好。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;这篇纯粹是为了满足我一直崇拜设计师，业余时间向他们学习的记录。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从 RxBus 这辆兰博基尼深入进去</title>
    <link href="http://imxie.cc/2016/06/02/deep-understanding-of-RxBus/"/>
    <id>http://imxie.cc/2016/06/02/deep-understanding-of-RxBus/</id>
    <published>2016-06-02T12:24:41.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>很早之前有看过别人实现的 RxBus , 当初也只是随意用用而已，没有想过去研究。今天看到 brucezz 天哥在群里分享了一把，自己也加入了讨论，下来还实践了一把，所以想借此篇进入到源码层，深刻体验下 RxBus 这辆 “兰博基尼” 的设计美感和独特魅力。</p><p><strong>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</strong></p><a id="more"></a><ul><li><a href="#Rxbus">RxBus</a><ul><li><a href="#准备">准备</a></li><li><a href="#解剖">解剖</a></li></ul></li><li><a href="#从-Subject-开始发车">从 Subject 开始发车</a><ul><li><a href="#官方解释">官方解释</a></li><li><a href="#Subject-源码">Subject 源码</a></li><li><a href="#PublishSubject-解释">PublishSubject 解释</a></li><li><a href="#串行化">串行化</a></li><li><a href="#SerializedSubject">SerializedSubject</a></li><li><a href="#SerializedObserver">SerializedObserver</a></li><li><a href="#NotificationLite">NotificationLite</a></li><li><a href="#CompositeSubscription">CompositeSubscription</a></li><li><a href="#参考文章">参考文章</a></li></ul></li><li><a href="#熄火休息">熄火休息</a></li></ul><h3 id="RxBus"><a href="#RxBus" class="headerlink" title="RxBus"></a>RxBus</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>关于简单的实现和用法，这篇文章已经很好的说明了。</p><p>推荐先看看 RxBus 的简单实现和用法。</p><p>地址在这里：<a href="http://brucezz.github.io/articles/2016/06/02/a-simple-rxbus-implementation/" target="_blank" rel="external">RxBus 的简单实现</a></p><h4 id="解剖"><a href="#解剖" class="headerlink" title="解剖"></a>解剖</h4><p><img src="http://ww3.sinaimg.cn/large/a17a2d22gw1f4h6davxw6j20m80gotbq.jpg" alt=""></p><hr><p>让我们看看这辆车到底用了些什么？</p><ul><li><p>Subject</p></li><li><p>SerializedSubject</p></li><li><p>PublishSubject</p></li><li><p>CompositeSubscription</p></li></ul><h3 id="从-Subject-开始发车"><a href="#从-Subject-开始发车" class="headerlink" title="从 Subject 开始发车"></a>从 Subject 开始发车</h3><h4 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h4><p>这是 Subject 的中文解释：</p><p>Subject可以看成是一个桥梁或者代理，在某些ReactiveX实现中（如RxJava），它同时充当了Observer和Observable的角色。因为它是一个Observer，它可以订阅一个或多个Observable；又因为它是一个Observable，它可以转发它收到(Observe)的数据，也可以发射新的数据。</p><p>由于一个Subject订阅一个Observable，它可以触发这个Observable开始发射数据（如果那个Observable是”冷”的–就是说，它等待有订阅才开始发射数据）。因此有这样的效果，Subject可以把原来那个”冷”的Observable变成”热”的。</p><h4 id="Subject-源码"><a href="#Subject-源码" class="headerlink" title="Subject 源码"></a>Subject 源码</h4><p>源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Subject</span><span class="params">(OnSubscribe&lt;R&gt; onSubscribe)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(onSubscribe);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasObservers</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SerializedSubject&lt;T, R&gt; <span class="title">toSerialized</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (getClass() == SerializedSubject.class) &#123;</div><div class="line">            <span class="keyword">return</span> (SerializedSubject&lt;T, R&gt;)<span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SerializedSubject&lt;T, R&gt;(<span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>Subject 只有两个方法。</p><p><code>hasObservers()</code>方法的解释是:</p><blockquote><p>Indicates whether the {@link Subject} has {@link Observer Observers} subscribed to it.<br>判断 Subject 是否已经有 observers 订阅了 有则返回 ture</p></blockquote><p><code>toSerialized()</code> 方法的解释是：</p><blockquote><p>Wraps a {@link Subject} so that it is safe to call its various {@code on} methods from different threads.<br>包装 Subject 后让它可以安全的在不同线程中调用各种方法</p></blockquote><p><strong>为什么这个方法后就可以是线程安全了呢？</strong></p><p>我们看到 <code>toSerialized()</code> 返回了 <code>SerializedSubject&lt;T, R&gt;</code> 。我们先到这里打住，稍后我们再看看该类做了什么。</p><h4 id="PublishSubject-解释"><a href="#PublishSubject-解释" class="headerlink" title="PublishSubject 解释"></a>PublishSubject 解释</h4><p><img src="http://ww4.sinaimg.cn/large/a17a2d22gw1f4h8xwycjdj20ye0k2q5b.jpg" alt=""></p><p>在 RxJava 里有一个抽象类 Subject，既是 Observable 又是 Observer，可以把 Subject 理解成一个管道或者转发器，数据从一端输入，然后从另一端输出。</p><p>Subject 有好几种，这里可以使用最简单的 <code>PublishSubject</code>。订阅之后，一旦数据从一端传入，结果会里立刻从另一端输出。</p><p>源码里给了用法例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">PublishSubject&lt;Object&gt; subject = PublishSubject.create();</div><div class="line"><span class="comment">// observer1 will receive all onNext and onCompleted events</span></div><div class="line">subject.subscribe(observer1);</div><div class="line">subject.onNext(<span class="string">"one"</span>);</div><div class="line">subject.onNext(<span class="string">"two"</span>);</div><div class="line"><span class="comment">// observer2 will only receive "three" and onCompleted</span></div><div class="line">subject.subscribe(observer2);</div><div class="line">subject.onNext(<span class="string">"three"</span>);</div><div class="line">subject.onCompleted();</div></pre></td></tr></table></figure><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>官方文档推荐我们：</p><blockquote><p>如果你把 Subject 当作一个 Subscriber 使用，注意不要从多个线程中调用它的onNext方法（包括其它的on系列方法），这可能导致同时（非顺序）调用，这会违反Observable协议，给Subject的结果增加了不确定性。</p><p>要避免此类问题，你可以将 Subject 转换为一个 SerializedSubject ，类似于这样：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">mySafeSubject = <span class="keyword">new</span> SerializedSubject( myUnsafeSubject );</div></pre></td></tr></table></figure></p></blockquote><p>所以我们可以看到在 RxBus 初始化的时候我们做了这样一件事情：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;Object, Object&gt; BUS;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">RxBus</span><span class="params">()</span> </span>&#123;</div><div class="line">    BUS = <span class="keyword">new</span> SerializedSubject&lt;&gt;(PublishSubject.create());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了保证多线程的调用中结果的确定性，我们按照官方推荐将 Subject 转换成了一个 SerializedSubject 。</p><h4 id="SerializedSubject"><a href="#SerializedSubject" class="headerlink" title="SerializedSubject"></a>SerializedSubject</h4><p><img src="http://ww4.sinaimg.cn/large/a17a2d22gw1f4i5h2l0anj20ww0nujuy.jpg" alt=""></p><p>该类同样是 <code>Subject</code> 的子类，这里贴出该类的构造方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> SerializedObserver&lt;T&gt; observer;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;T, R&gt; actual;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SerializedSubject</span><span class="params">(<span class="keyword">final</span> Subject&lt;T, R&gt; actual)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> OnSubscribe&lt;R&gt;() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; child)</span> </span>&#123;</div><div class="line">            actual.unsafeSubscribe(child);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">this</span>.actual = actual;</div><div class="line">    <span class="keyword">this</span>.observer = <span class="keyword">new</span> SerializedObserver&lt;T&gt;(actual);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们发现，<code>Subject</code> 最后转化成了 <code>SerializedObserver</code>.</p><h4 id="SerializedObserver"><a href="#SerializedObserver" class="headerlink" title="SerializedObserver"></a>SerializedObserver</h4><blockquote><p>When multiple threads are emitting and/or notifying they will be serialized by:<br>Allowing only one thread at a time to emit<br>Adding notifications to a queue if another thread is already emitting<br>Not holding any locks or blocking any threads while emitting</p><p>一次只会允许一个线程进行发送事物<br>如果其他线程已经准备就绪，会通知给队列<br>在发送事物中，不会持有任何锁和阻塞任何线程</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/a17a2d22gw1f4i6cogy7ej20yo0r6gpa.jpg" alt=""></p><p>通过介绍可以知道是通过 <code>notifications</code> 来进行并发处理的。</p><p>SerializedObserver 类中<br><code>private final NotificationLite&lt;T&gt; nl = NotificationLite.instance();</code></p><p>重点看看 nl 在 onNext() 方法里的使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">  <span class="comment">// 省略一些代码</span></div><div class="line">       <span class="keyword">for</span> (;;) &#123;</div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_DRAIN_ITERATION; i++) &#123;</div><div class="line">               FastList list;</div><div class="line">               <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                   list = queue;</div><div class="line">                   <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</div><div class="line">                       emitting = <span class="keyword">false</span>;</div><div class="line">                       <span class="keyword">return</span>;</div><div class="line">                   &#125;</div><div class="line">                   queue = <span class="keyword">null</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">for</span> (Object o : list.array) &#123;</div><div class="line">                   <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">                       <span class="keyword">break</span>;</div><div class="line">                   &#125;</div><div class="line">                   <span class="comment">// 这里的 accept() 方法</span></div><div class="line">                   <span class="keyword">try</span> &#123;</div><div class="line">                       <span class="keyword">if</span> (nl.accept(actual, o)) &#123;</div><div class="line">                           terminated = <span class="keyword">true</span>;</div><div class="line">                           <span class="keyword">return</span>;</div><div class="line">                       &#125;</div><div class="line">                   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                       terminated = <span class="keyword">true</span>;</div><div class="line">                       Exceptions.throwIfFatal(e);</div><div class="line">                       actual.onError(OnErrorThrowable.addValueAsLastCause(e, t));</div><div class="line">                       <span class="keyword">return</span>;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h4 id="NotificationLite"><a href="#NotificationLite" class="headerlink" title="NotificationLite"></a>NotificationLite</h4><p>知道哪里具体调用了之后，我们再仔细看看  <code>NotificationLite</code> 。</p><p>先来了解它到底是什么：</p><blockquote><p>For use in internal operators that need something like materialize and dematerialize wholly within the implementation of the operator but don’t want to incur the allocation cost of actually creating {@link rx.Notification} objects for every {@link Observer#onNext onNext} and {@link Observer#onCompleted onCompleted}.<br>It’s implemented as a singleton to maintain some semblance of type safety that is completely non-existent.</p><p>大致意思是：作为一个单例类保持这种完全不存在的安全类型的表象。  </p></blockquote><p><img src="http://ww4.sinaimg.cn/large/a17a2d22gw1f4i7btoa64j21ei0qygs6.jpg" alt=""></p><p>刚我们在 SerializedObserver 的 onNext() 方法中看到 <code>nl.accept(actual, o)</code><br>所以我们再深入到 <code>accept()</code> 方法中：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; o, Object n)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (n == ON_COMPLETED_SENTINEL) &#123;</div><div class="line">         o.onCompleted();</div><div class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == ON_NEXT_NULL_SENTINEL) &#123;</div><div class="line">         o.onNext(<span class="keyword">null</span>);</div><div class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">if</span> (n.getClass() == OnErrorSentinel.class) &#123;</div><div class="line">             o.onError(((OnErrorSentinel) n).e);</div><div class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">         &#125;</div><div class="line">         o.onNext((T) n);</div><div class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"The lite notification can not be null"</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><blockquote><p>Unwraps the lite notification and calls the appropriate method on the {@link Observer}.<br>判断 lite 通知类别，通知 observer 执行适当方法。</p></blockquote><p>通过 NotificationLite 类图可以看到有三个标识</p><ul><li>ON_NEXT_NULL_SENTINEL （onNext 标识）</li><li>ON_COMPLETED_SENTINEL （onCompleted 标识)</li><li>OnErrorSentinel (onError 标识)</li></ul><p>与 Observer 回调一致。通过分析得知 <code>accept()</code>  就是通过标识来判断，然后调用 Observer 相对应的方法。</p><h4 id="CompositeSubscription"><a href="#CompositeSubscription" class="headerlink" title="CompositeSubscription"></a>CompositeSubscription</h4><p>RxBus 这辆”兰博基尼”与 CompositeSubscription 车间搭配更好。</p><hr><p><img src="http://ww4.sinaimg.cn/large/a17a2d22gw1f4ijb9l4zwj20v80ps42f.jpg" alt=""></p><p>构造函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Set&lt;Subscription&gt; subscriptions;</div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> unsubscribed;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CompositeSubscription</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">CompositeSubscription</span><span class="params">(<span class="keyword">final</span> Subscription... subscriptions)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.subscriptions = <span class="keyword">new</span> HashSet&lt;Subscription&gt;(Arrays.asList(subscriptions));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>内部是初始化了一个 HashSet ，按照哈希算法来存取集合中的对象，存取速度比较快，并且没有重复对象。</p><p>所以我们推荐在基类里实例化一个 CompositeSubscription 对象，使用 CompositeSubscription 来持有所有的 Subscriptions ，然后在 onDestroy()或者 onDestroyView()里取消所有的订阅。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="http://blog.csdn.net/lzyzsd/article/details/45033611" target="_blank" rel="external">http://blog.csdn.net/lzyzsd/article/details/45033611</a></li><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/Subject.html" target="_blank" rel="external">https://mcxiaoke.gitbooks.io/rxdocs/content/Subject.html</a></li></ul><h3 id="熄火休息"><a href="#熄火休息" class="headerlink" title="熄火休息"></a>熄火休息</h3><p>能力有限，文章错误还望指出，有任何问题都欢迎讨论 :)</p><p>转载请注明出处。</p><p>最后送上我女神 Gakki , 开心最好 ( ´͈ｖ `͈ )◞。</p><p><img src="http://ww3.sinaimg.cn/large/a17a2d22gw1f4ijpqofquj20fi0gowgo.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早之前有看过别人实现的 RxBus , 当初也只是随意用用而已，没有想过去研究。今天看到 brucezz 天哥在群里分享了一把，自己也加入了讨论，下来还实践了一把，所以想借此篇进入到源码层，深刻体验下 RxBus 这辆 “兰博基尼” 的设计美感和独特魅力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://imxie.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://imxie.cc/tags/Android/"/>
    
      <category term="RxJava" scheme="http://imxie.cc/tags/RxJava/"/>
    
      <category term="RxBus" scheme="http://imxie.cc/tags/RxBus/"/>
    
  </entry>
  
  <entry>
    <title>【转】RxBus 的简单实现</title>
    <link href="http://imxie.cc/2016/06/02/%E3%80%90%E8%BD%AC%E3%80%91RxBus-%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://imxie.cc/2016/06/02/【转】RxBus-的简单实现/</id>
    <published>2016-06-02T12:20:25.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇转自 <a href="http://brucezz.github.io/" target="_blank" rel="external">brucezz</a></p></blockquote><p>今天写代码正好想到要用事件总线，先前都是使用 Square 的 Otto 或者 GreenRobot 的 EventBus ，听说 RxJava 能够轻易实现一个 Bus，所以就来研究研究这个车怎么开~</p><a id="more"></a><p><img src="http://brucezz.github.io/images/no-time-to-explain.jpg" alt="没时间解释了，快上车！"></p><p>这辆车需要有一下功能：</p><ul><li>订阅者能够订阅某种事件 Event</li><li>发布某种 Event 时，该事件的订阅者们能够及时响应</li></ul><p>在 RxJava 里有一个对象 Subject，既是 Observable 又是 Observer，可以把 Subject 理解成一个管道或者转发器，数据从一端输入，然后从另一端输出。</p><p>Subject 有好几种，这里可以使用最简单的 <code>PublishSubject</code>。一旦数据从一端传入，结果会里立刻从另一端输出。</p><p>由于允许订阅者订阅某一种类型的 Event，所以注册订阅的时候需要一个 Class 对象对事件进行过滤。</p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxBus</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RxBus instance;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Subject&lt;Object, Object&gt; BUS;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RxBus</span><span class="params">()</span> </span>&#123;</div><div class="line">        BUS = <span class="keyword">new</span> SerializedSubject&lt;&gt;(PublishSubject.create());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RxBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (RxBus.class) &#123;</div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> RxBus();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">        BUS.onNext(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">toObserverable</span><span class="params">(Class&lt;T&gt; eventType)</span> </span>&#123;</div><div class="line">        <span class="comment">// ofType = filter + cast</span></div><div class="line">        <span class="keyword">return</span> BUS.ofType(eventType);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中，RxBus 使用了单例模式，确保应用中只有一辆车。</p><p><code>post</code> 方法发布一个 Event 对象给 bus，然后由 bus 转发给订阅者们。</p><p><code>toObserverable</code> 方法能够获得一个包含目标事件的 Observable，订阅者对其订阅即可响应。</p><p><code>bus.ofType()</code> 等效于  <code>bus.filter(eventType::isInstance).cast(eventType)</code> ，即先过滤事件类型，然后发射给订阅者。</p><h3 id="开车啦"><a href="#开车啦" class="headerlink" title="开车啦"></a>开车啦</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxBusActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> CompositeSubscription allSubscription = <span class="keyword">new</span> CompositeSubscription();</div><div class="line">    Button send;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        send = (Button) findViewById(R.id.send);</div><div class="line">        send.setOnClickListener(</div><div class="line">                v -&gt; RxBus.getDefault().post(<span class="keyword">new</span> OneEvent(<span class="string">"hello bus"</span>)));</div><div class="line">        allSubscription.add(RxBus.getDefault()</div><div class="line">                .toObserverable(OneEvent.class).subscribe(<span class="keyword">this</span>::response));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">(OneEvent event)</span> </span>&#123;</div><div class="line">        ToastUtil.show(event.msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="keyword">if</span> (allSubscription != <span class="keyword">null</span> &amp;&amp; !allSubscription.isUnsubscribed())</div><div class="line">            allSubscription.unsubscribe();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OneEvent</span> </span>&#123;</div><div class="line">        <span class="comment">// some data you need ...</span></div><div class="line">        String msg;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OneEvent</span><span class="params">(String msg)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.msg = msg;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>点击按钮，发送  <code>OneEvent</code> 事件，然后响应此事件，发出 Toast ~</p><p>通过多次调用 <code>toObserverable()</code> 方法可以订阅多种事件。</p><p><strong>小 tip</strong> : <code>CompositeSubscription</code> 可以把 Subscription 收集到一起，方便 Activity 销毁时取消订阅，防止内存泄漏。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://drakeet.me/rxbus" target="_blank" rel="external">翻译：通过 RxJava 实现一个 Event Bus – RxBus | Drakeet的个人博客</a></li><li><a href="http://www.jianshu.com/p/ca090f6e2fe2/" target="_blank" rel="external">用RxJava实现事件总线(Event Bus) - 简书</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这篇转自 &lt;a href=&quot;http://brucezz.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;brucezz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天写代码正好想到要用事件总线，先前都是使用 Square 的 Otto 或者 GreenRobot 的 EventBus ，听说 RxJava 能够轻易实现一个 Bus，所以就来研究研究这个车怎么开~&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://imxie.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://imxie.cc/tags/Android/"/>
    
      <category term="RxJava" scheme="http://imxie.cc/tags/RxJava/"/>
    
      <category term="RxBus" scheme="http://imxie.cc/tags/RxBus/"/>
    
  </entry>
  
  <entry>
    <title>讨论下 RxJava 里的 onError</title>
    <link href="http://imxie.cc/2016/06/01/tao-lun-Rx-onError/"/>
    <id>http://imxie.cc/2016/06/01/tao-lun-Rx-onError/</id>
    <published>2016-06-01T06:12:26.000Z</published>
    <updated>2017-08-11T03:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为上次在网络请求里用到了 <code>onErrorReturn</code> 所以想自己实践下和搞清楚 RxJava 里异常处理到底是怎么回事，以及自己如何更好的使用。</p><a id="more"></a><!-- toc --><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RxJavaTest</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] arrayA = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">    <span class="keyword">static</span> List&lt;Integer&gt; listB = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        listB.add(<span class="number">1</span>);</div><div class="line">        listB.add(<span class="number">2</span>);</div><div class="line">        listB.add(<span class="number">3</span>);</div><div class="line">        errorTest();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">errorTest</span><span class="params">()</span> </span>&#123;</div><div class="line">        Observable.from(listB)</div><div class="line">            .doOnNext(integer -&gt; arrayA[integer] = integer)</div><div class="line">            .subscribe(integer -&gt; &#123;</div><div class="line">            &#125;, throwable -&gt; &#123;</div><div class="line">                System.out.println(<span class="string">"在onError处理了:"</span> + throwable.toString());</div><div class="line">            &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到我在这里模拟了一个越界异常，在 <code>errorTest()</code> 方法里做写了遍历列表 <code>listB</code> 并且将值赋值给数组 <code>arrayA</code> 对应角标。</p><p>运行以上程序在控制台输出的是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">在onError处理了:java.lang.ArrayIndexOutOfBoundsException: 2</div></pre></td></tr></table></figure><p>现在我们做一点改变：</p><p><strong>在 <code>errorTest</code> 方法里加入 <code>onErrorReturn</code> 并且返回 null </strong></p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">errorTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    Observable.from(listB)</div><div class="line">        .doOnNext(integer -&gt; arrayA[integer] = integer)</div><div class="line">        .onErrorReturn(throwable -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"在onErrorReturn处理了:"</span> + throwable.toString());</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(integer -&gt; &#123;</div><div class="line"></div><div class="line">        &#125;, throwable -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"在onError处理了:"</span> + throwable.toString());</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在再运行程序得到在控制台的输出是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">在onErrorReturn处理了:java.lang.ArrayIndexOutOfBoundsException: 2</div></pre></td></tr></table></figure><p>发现异常只在 onErrorReturn 处理了，并没有在 onError 里。</p><p>难道只要写了 onErrorReturn 处理了异常就不会抛到 onError 里吗？</p><p>带着这个疑问，我们再修改下 errorTest() 方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">errorTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    Observable.from(listB)</div><div class="line">        .doOnNext(integer -&gt; arrayA[integer] = integer)</div><div class="line">        .onErrorReturn(throwable -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"在onErrorReturn处理了:"</span> + throwable.toString());</div><div class="line">            <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">        &#125;)</div><div class="line">        .doOnNext(integer -&gt; arrayA[integer] = integer)</div><div class="line">        .subscribe(integer -&gt; &#123;</div><div class="line">        &#125;, throwable -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"在onError处理了:"</span> + throwable.toString());</div><div class="line">        &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>让 onErrorReturn 处理了异常后并且返回一个 3，随后继续进行赋值操作。</p><p>现在运行程序，控制台输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">在onErrorReturn处理了:java.lang.ArrayIndexOutOfBoundsException: 2</div><div class="line">在onError处理了:java.lang.ArrayIndexOutOfBoundsException: 3</div></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>onErrorRetrun</strong> 能够捕获在它之前发生的异常，它之后流中的操作发生的异常就它就不会管了。<br>经过小栗子的演示，我们现在理解了 onErrorReturn 的作用域，从而明白该什么时候使用它。</p><p>参考文章：</p><ul><li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Catch.html" target="_blank" rel="external">https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Catch.html</a></li><li><a href="https://dzone.com/articles/rxjavas-side-effect-methods" target="_blank" rel="external">https://dzone.com/articles/rxjavas-side-effect-methods</a></li><li><a href="http://blog.chengyunfeng.com/?p=976" target="_blank" rel="external">http://blog.chengyunfeng.com/?p=976</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为上次在网络请求里用到了 &lt;code&gt;onErrorReturn&lt;/code&gt; 所以想自己实践下和搞清楚 RxJava 里异常处理到底是怎么回事，以及自己如何更好的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://imxie.cc/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="RxJava" scheme="http://imxie.cc/tags/RxJava/"/>
    
      <category term="Java" scheme="http://imxie.cc/tags/Java/"/>
    
  </entry>
  
</feed>
