{"meta":{"title":"IM XIE","subtitle":null,"description":"代码如诗","author":"谢三弟","url":"http://imxie.cc"},"pages":[{"title":"很高兴遇到你","date":"2018-08-24T12:11:33.394Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"about/index.html","permalink":"http://imxie.cc/about/index.html","excerpt":"","text":"Hi，我是 Google 粉 / Android 开发 / 女神 Gakki / 钢炼入宅特别喜欢 3 这个数字 / 所以会有人 三哥/三弟 称呼随意/简单 就好 / 我们相互学习 / 随意联系 我的作品 就看天气 个人开源 校园说 团队项目 组织 ItsCoder 我们一起在做一件值得的事情。 我的朋友 Joe Brucezz Jaeger Tracy 你可以这样联系我 Weibo: 谢晨成不发微博 Github: IMXIE Email : Hugo3641@gmail.com 推广推荐科学上网：地址（自用）"},{"title":"一次 Android Day/Night 实践（夜间模式）","date":"2016-07-12T02:09:39.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/Android-New-Day-Night-Swtich.html","permalink":"http://imxie.cc/hide/Android-New-Day-Night-Swtich.html","excerpt":"用过 就看天气 的话，都会发现，它在 18：00 的时候会自动切换成夜间模式，当时使用的方法是在创建视图的时候就判断当前手机时间，再进行一些 UI 的改变。这样的做法不是特别的 cool ，无意之间发现 Android 23.2.0 的包下提供了 日/夜间 主题，所以立马就加入 就看天气 ，让我们来看看如何使用吧。","text":"用过 就看天气 的话，都会发现，它在 18：00 的时候会自动切换成夜间模式，当时使用的方法是在创建视图的时候就判断当前手机时间，再进行一些 UI 的改变。这样的做法不是特别的 cool ，无意之间发现 Android 23.2.0 的包下提供了 日/夜间 主题，所以立马就加入 就看天气 ，让我们来看看如何使用吧。 主题配置首先你得先在你的 style.xml 文件里，把你的主题继承 DayNight 主题，像这样： &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.DayNight.DarkActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 它有四个可选值，分别是： MODE_NIGHT_NO： 使用亮色(light)主题，不使用夜间模式 MODE_NIGHT_YES：使用暗色(dark)主题，使用夜间模式 MODE_NIGHT_AUTO：根据当前时间自动切换 亮色(light)/暗色(dark)主题 MODE_NIGHT_FOLLOW_SYSTEM(默认选项)：设置为跟随系统，通常为 MODE_NIGHT_NO 推荐在 Application 添加一个静态代码块来进行初始化全局设置： static &#123; AppCompatDelegate.setDefaultNightMode( AppCompatDelegate.MODE_NIGHT_AUTO); // 选择你需要的&#125; 切换主题时使用自定义资源使用自定义资源，只需要在 res 目录下创建对应的 values-night 文件夹并创建对应的 themes.xml 文件： res/values/colors.xml&lt;color name=\"colorPrimary\"&gt;#106c99&lt;/color&gt;&lt;color name=\"colorPrimaryDark\"&gt;#0D4A6A&lt;/color&gt;&lt;color name=\"colorAccent\"&gt;#FC413D&lt;/color&gt; res/values-night/colors.xml&lt;color name=\"colorPrimary\"&gt;#201D45&lt;/color&gt;&lt;color name=\"colorPrimaryDark\"&gt;#201D45&lt;/color&gt; 同理其他资源你只需要在末尾添加 -night 系统就会自动加载对应的文件了。 参考文章 Android Support Library v23.2 Adds Auto-Switching Day/Night Theme, Support For Vector Drawables, And Much More AppCompat v23.2 - 夜间模式最佳实践"},{"title":"Android Studio 在 El Capitan 中切换闪屏问题","date":"2016-05-07T12:41:11.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/Android-Studio-Mac-闪屏解决方案.html","permalink":"http://imxie.cc/hide/Android-Studio-Mac-闪屏解决方案.html","excerpt":"","text":"买来 RMBP 有一段时间了，确实用来写代码很爽和快乐。但是还是遇到一些小坑，所以决定记录一下。我是 Android 开发爱好者，在使用 Android Studio 的时候全屏模式下，切换会闪屏。虽然是小问题，但是特别难受，自己谷歌了很多方法，终于相互结合后，已经成功解决。 方案 先在官网下载 jdk 1.8 在 Android Studio 安装路径下 修改info.plist中JVMversion为 1.8* 同时下载最新版本的 IDEA ，将它自身带有的 JAR 包拷贝到 Android Studio 对应位置 提高 Android Studio Gradle 内存，在 studio.vmoptions 修改"},{"title":"Android studio 自用插件","date":"2016-01-22T01:58:42.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/Android-studio-插件.html","permalink":"http://imxie.cc/hide/Android-studio-插件.html","excerpt":"整理了自己常用的 Android Studio 插件。","text":"整理了自己常用的 Android Studio 插件。 Lifecycle-Sorter 可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序， 快捷键Ctrl + alt + K CodeGlance 可用于快速定位代码，类似于Sublime编辑器右侧定位视图 GsonFormat 根据Gson库使用的要求,将JSONObject格式的String 解析成实体。 FindBugs-IDEA FindBugs 是一个静态分析工具，它检查类或者 JAR 文件，将字节码与一组缺陷模式进行对比以发现可能的问题。 FindViewByMe ↗ FindViewByMe是一个自动生成FindViewById代码的IDEA/Android Studio插件，支持Activity、Fragment和ViewHolder中的findViewById的代码生成。 WakaTime 一个统计插件，可以看自己代码时间。 Translations Plugin github 交流群里小伙伴写的翻译插件，用法是 shift + T，再也不用担心看源码不认识英文了。"},{"title":"【译】深入浅出Android权限（一）","date":"2016-02-26T03:47:13.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/Android6.0-permissions-part-1.html","permalink":"http://imxie.cc/hide/Android6.0-permissions-part-1.html","excerpt":"原文链接 : Permissions – Part 1 原文作者 : Styling Android 译文出自 : 掘金翻译计划 译者 : Hugo Xie 校对者 : BOBO，markzhai","text":"原文链接 : Permissions – Part 1 原文作者 : Styling Android 译文出自 : 掘金翻译计划 译者 : Hugo Xie 校对者 : BOBO，markzhai 因为 Marshmallow（Android 6.0）一个新的权限模型的引入，Android 开发者需要采取不同于以往的方式来获取 Android的权限。本系列中我们将从技术以及如何提供流畅用户体验的角度，讲解如何处理请求权限。 在我们陷入困境之前，需要明确一个应用必须申请权限的两种情况的其中之一是：那些权限是应用程序的运行的核心——如果没有申请到这些核心权限，该应用程序将不能正常工作。比如，对于一个相机应用来说，CAMERA权限是核心功能中的一部分，一个相机应用如果不能照相就毫无用处。然而，可能会有其他功能，比如像给图片标记位置（需要ACCESS_FINE_LOCATION权限），这是一个很好的功能，但应用可以不需要位置权限也可以运行。所以为了接下来的一系列的文章，并且让大家都可以准备开始做app之前，需要申请以下两个权限RECORD_AUDIO 和 MODIFY_AUDIO_SETTINGS。为了去获得这些权限，像我们经常做的一样需要在Manifest文件里声明他们。 AndroidManifest.xml&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" package=\"com.stylingandroid.permissions\"&gt; &lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\"&gt; &lt;uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\"&gt; &lt;application android:allowbackup=\"false\" android:fullbackupcontent=\"false\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsrtl=\"true\" android:theme=\"@style/AppTheme.NoActionBar\" tools:ignore=\"GoogleAppIndexingWarning\"&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;activity android:name=\".PermissionsActivity\" android:label=\"@string/title_activity_permissions\" android:theme=\"@style/AppTheme.NoActionBar\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"&gt; &lt;/category&gt;&lt;/action&gt;&lt;/intent-filter&gt; &lt;/activity&gt; &lt;/activity&gt;&lt;/application&gt;&lt;/uses-permission&gt;&lt;/uses-permission&gt;&lt;/manifest&gt; 从API1\\开始这已经成为一种标准的方法去请求Android里的权限。不过，从targetSdkVersion 23或者已更新的版本，我们也需要在运行中去请求我们需要的权限。这是非常重要的，因为已经有很多开发者在他们的例子中只是简单地把targetSdkVersion设置为最新，然后他们发现自己的应用直接崩溃了，因为他们并没有在应用运行中实现必要的代码去请求权限。问题的是，一旦当你发布一个目标API23的app到Google Play后，接着就没法用一个目标API更早的APK去替换它了。 值得一提的另外一件事情是在这一点上已经有一些旨在简化在运行中请求权限流程的库。这些库在代码质量和有效性上是多样化的，但是我觉得有必要了解底层流程再使用这种类型的库，否则你可能会遇到问题，因为你根本不了解你所使用的库实际上在做什么。这就是这一系列文章的主要动机。我们需要这两个权限实际上是属于两个不同类别的权限：RECORD_AUDIO 是被认为一种高危的权限，MODIFY_AUDIO_SETTINGS 被认为是一种正常的权限。高危权限可能会危及到安全或隐私；尽管一个普通的权限是为了访问应用领域之外的资源，但是用户的隐私风险会有很少甚至没有。普通的权限会被系统自动地授予，然而高危的权限在运行过程中需要使用者明确地授予给你的应用。 我们需要做的第一件事是这部分过程首先确定是否我们已经获得了我们所需要的权限。在API 23中， Context加入了新的方法去检查是否已被授予了特定的权限。 但是，现在推崇使用ContextCompat取代直接访问Context，包括您自己的 API-level 检查：PermissionChecker.javaclass PermissionsChecker &#123; private final Context context; public PermissionsChecker(Context context) &#123; this.context = context; &#125; public boolean lacksPermissions(String... permissions) &#123; for (String permission : permissions) &#123; if (lacksPermission(permission)) &#123; return true; &#125; &#125; return false; &#125; private boolean lacksPermission(String permission) &#123; return ContextCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_DENIED; &#125;&#125; 这其实是非常直接的 —— ContextCompat#checkSelfPermission 方法是很容易理解的，未被授权将返回PackageManager.PERMISSION_DENIED已被授权将返回PackageManager.PERMISSION_GRANTED。我对这个app添加好了一些进一步的逻辑，刚好可以实现它的这个功能：检测出任何没有被授权的但又是必要的权限。 值得重申的是ContextCompat能在这里为我们做什么。运行在 Marshmallow（Android6.0）以前的不支持新的运行权限模型的设备上时（旧的系统上是隐式授予权限）checkSelfPermission() 方法总会返回PackageManger.PERMISSION_GRANTED，因为Manifest的申明，只需要调用一个方法让它运行在所有版本系统中，并且我们不需要在自己的代码中写任何API-level 具体的checks。 之所以为此创建了一个具体的类，是因为我们以后需要在app中所有activity里做这些检查，这样把检查逻辑从Activity中分离出来可以减少重复代码，提高可维护性。 所以在实际应用在我们的Activity中，我们可以简单地把它称为Activity 请求的权限清单。 MainActivity.javapublic class MainActivity extends AppCompatActivity &#123; private static final String[] PERMISSIONS = new String[] &#123;Manifest.permission.RECORD_AUDIO, Manifest.permission.MODIFY_AUDIO_SETTINGS&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); PermissionsChecker checker = new PermissionsChecker(this); if (checker.lacksPermissions(PERMISSIONS)) &#123; Snackbar.make(toolbar, R.string.no_permissions, Snackbar.LENGTH_INDEFINITE).show(); &#125; . . . &#125;&#125; 实际应用上非常简单。 在Marshamllow（Andorid 6.0）以前的设备上运行效果： 但我们还没有对Marshamllow（Android 6.0）和以后的版本进行缺少的权限的处理——只是展示了一个Snackbar： 请求缺少的权限是一个非常复杂的变化过程，我们将会在下一篇文章进行讲解。 这篇文章的源码可以在这里获取。"},{"title":"【译】深入浅出Android权限（二）","date":"2016-02-29T11:39:26.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/Android6.0-permissions-part-2.md.html","permalink":"http://imxie.cc/hide/Android6.0-permissions-part-2.md.html","excerpt":"原文链接 : Permissions – Part 2 原文作者 : Styling Android 译文出自 : 掘金翻译计划 译者 : Hugo 校对者 : Adam Shen,JOJO","text":"原文链接 : Permissions – Part 2 原文作者 : Styling Android 译文出自 : 掘金翻译计划 译者 : Hugo 校对者 : Adam Shen,JOJO 因为 Marshmallow（Android 6.0）一个新的权限模型的引入，Android 开发者需要采取不同于以往的方式来获取 Android 的权限。本系列中我们将从技术以及如何提供流畅用户体验的角度，讲解处理权限请求的方法。 以前我们可以检查是否已经被授予了请求的权限，但是没有机制去请求任何缺少的权限。在这篇文章中，我们来看看如何在不往 Activities 中加入大量重复代码的情况下，引入必要的权限检查和请求。请牢记下文的一切都是特定于Marshmallow或者更高的版本（早期的版本已经从Manifest中隐式授予了权限），并且你需要检查是否你已经在你的项目中指定了targetSdkVersion=23或者更高的版本。 接下来的第一件事情我们需要去了解权限请求模型是如何实现的。正如我们已经讨论过的，普通的权限可被隐式授予但高危权限需要明确地请求用户授予。如果用户给了我们需要的权限，事情就非常简单了，但是我们需要尽量避免被用户拒绝权限请求。对于我们将要开发的这个程序来说，用户可能并不明白我们为什么要请求 RECORD_AUDIO 权限，所以我们需要通过一些条款来告知用户我们为什么需要这个权限。 从用户的角度来看，在第一次运行程序的时候，用户会被询问是否授予所需权限： 如果用户授予了所需权限，我们就可以继续我们要做的操作了。但是，如果他们拒绝授予权限，我们可以反复询问用户所需的权限： 但是注意，如果用户已经在之前拒绝了这个所需权限，系统会给用户提供一个“不再询问”的选项。如果用户选择了这个选项，那我们代码随后发出的任何该权限请求都会被系统自动拒绝，而不会再次询问用户。显然地，这会对我们开发者造成问题，所以我们需要考虑到这一点。 这个问题可以变得更复杂，因为在任何时候，用户都可以在设置页面对我们应用所需的任何权限进行授予或者拒绝。因为权限可能随时会改变，所以我们不仅仅应该在应用启动时，也要在每个 Activity 中，去检查所需的权限是否被授予。 所以我们处理这个问题的方式是使用一个单独的 Activity 专门用来请求权限，并且所有应用中的其他 Activity 都需要检查它们是否拥有需要的权限，如果它们所需的权限被拒绝，就交由 PermissionsActivity 处理。 接下来我们稍微改动下MainActivity： MainActivity.java public class MainActivity extends AppCompatActivity { static final String[] PERMISSIONS = new String[]{Manifest.permission.RECORD_AUDIO, Manifest.permission.MODIFY_AUDIO_SETTINGS}; private PermissionsChecker checker; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); checker = new PermissionsChecker(this); } @Override protected void onResume() { super.onResume(); if (checker.lacksPermissions(PERMISSIONS)) { startPermissionsActivity(); } } private void startPermissionsActivity() { PermissionsActivity.startActivity(this, PERMISSIONS); } } 我们把权限检查移动到了onResume()里。这是考虑到用户可能先暂停我们的应用，切换到设置页面，拒绝了一个权限后再回到我们的应用的情况。好吧，这是一些极端情况，但是为了防止这种情况导致的程序崩溃，这样做是值得的。 所以我们实现的基本方法是，每当Activity恢复的时候，我们需要先确认该 Activity 拥有所需的权限再运行。如果所需权限被拒绝，就需要我们把控制传递给负责获取所需的权限的PermissionsActivity。虽然这感觉确实就像一种抵御方式，但是我认为这真是一种明智的并且实际上不需要大量代码的做法。所有的检查逻辑都封装到PermissionsChecker，然后请求逻辑在PermissionsActivity进行处理。 使得权限检查组件相对轻量是非常重要的，因为这样我们就可以用相对低的成本来检查组件，并且只在完全必要的情况下，才使用切换 Activity 这种成本高得多的途径来请求缺失的权限。 在下一篇文章中，我们来看看PermissionsActivity中实际上是如何处理权限请求和探讨在用户拒绝我们权限请求的时候，如何进一步告知用户为什么这个权限是应用需要的。 这篇文章的源码在这里可以获取. 在PermissionsActivity中有一个占位符，我们将在下一篇文章中扩展，所以它并不是完整功能的代码。"},{"title":"Gifts-for-designers（RxJava初入学习一）","date":"2016-01-22T01:03:58.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/Gifts-for-designers.html","permalink":"http://imxie.cc/hide/Gifts-for-designers.html","excerpt":"一个为设计师设计的APP( ´_ゝ`)一个特别简单项目 主要用来练习Rx，当然这个适合初入Rx的看看。 自己参考的教程给 Android 开发者的 RxJava 详解 Github地址：Gifts-for-designers 可以给个 star 鼓励下( ◜◡‾)っ✂╰⋃╯","text":"一个为设计师设计的APP( ´_ゝ`)一个特别简单项目 主要用来练习Rx，当然这个适合初入Rx的看看。 自己参考的教程给 Android 开发者的 RxJava 详解 Github地址：Gifts-for-designers 可以给个 star 鼓励下( ◜◡‾)っ✂╰⋃╯ Usage( ´_ゝ`) 好像这个项目没有很多代码需要解释，不过我还是整理一份 自定义字体// 字体Typeface fontFace = Typeface.createFromAsset(getAssets(),&quot;font/Inconsolata.otf&quot;);Typeface tvFontFace = Typeface.createFromAsset(getAssets(), &quot;font/Lobster.ttf&quot;);editTextHEX.setTypeface(fontFace);editTextRGB.setTypeface(fontFace);textView.setTypeface(tvFontFace); Rx监听输入RxTextView.textChanges(editTextHEX) .subscribeOn(AndroidSchedulers.mainThread()) .debounce(300, TimeUnit.MICROSECONDS) .map(new Func1&lt;CharSequence, String&gt;() &#123; @Override public String call(CharSequence charSequence) &#123; return charSequence.toString(); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .doOnNext(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; if (s.length() == 5) &#123; setBackground(&quot;56abe4&quot;, 0); editTextRGB.setText(&quot;&quot;); &#125; if (!colors.isEmpty()) &#123; colors.clear(); adapter.notifyDataSetChanged(); &#125; &#125; &#125;) .filter(new Func1&lt;String, Boolean&gt;() &#123; @Override public Boolean call(String s) &#123; return s.length() &gt; 5; &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; setBackground(s, 0);// addColorAdapter(s); changeToRGB(s); &#125; &#125;) 改变背景颜色（有个过渡效果） /** * @param color * @param mark 0:HEX 1:RGB */public void setBackground(String color, int mark) &#123; int i = 0; ValueAnimator paramInteger; Drawable localDrawable = this.relativeLayout.getBackground(); if ((localDrawable instanceof ColorDrawable)) i = ((ColorDrawable) localDrawable).getColor(); if (mark == 0) &#123; paramInteger = ValueAnimator.ofObject(new ArgbEvaluator(), i, Color .parseColor(&quot;#&quot; + color)); &#125; else &#123; paramInteger = ValueAnimator.ofObject(new ArgbEvaluator(), i, mark); &#125; paramInteger.setDuration(500L); paramInteger.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; public void onAnimationUpdate(ValueAnimator paramAnonymousValueAnimator) &#123; relativeLayout.setBackgroundColor((Integer) paramAnonymousValueAnimator.getAnimatedValue()); &#125; &#125; ); paramInteger.start(); &#125; 将16进制转化成RGBprivate void changeToRGB(String s) &#123; int red = Integer.parseInt(String.valueOf(s.charAt(0)) + s.charAt(1), 16); int green = Integer.parseInt(String.valueOf(s.charAt(2)) + s.charAt(3), 16); int blue = Integer.parseInt(String.valueOf(s.charAt(4)) + s.charAt(5), 16); Log.d(TAG, red + &quot; &quot; + green + &quot; &quot; + blue); editTextRGB.setText(&quot;(&quot; + red + &quot;,&quot; + green + &quot;,&quot; + blue + &quot;)&quot;);&#125; Todo&amp;Issues [x] 搭配色算法推荐 [ ] 搭配色展示（RecyclerView） [ ] 目前只做了16进制颜色，RGB有些逻辑问题 [ ] 删除过快会有卡顿（不知道如何解决） [ ] 颜色保存列表 截图"},{"title":"自用 Mac 软件整理和推荐","date":"2016-07-08T12:53:30.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/My-Mac-Awesome-Apps.html","permalink":"http://imxie.cc/hide/My-Mac-Awesome-Apps.html","excerpt":"自己无论是 Android 手机上的软件还是 Mac 上的，都存有很多。Mac 上大多都是为了提升工作效率，手机上除了必备的来说，其他都是为了给自己找灵感。 算个软件控吧。","text":"自己无论是 Android 手机上的软件还是 Mac 上的，都存有很多。Mac 上大多都是为了提升工作效率，手机上除了必备的来说，其他都是为了给自己找灵感。 算个软件控吧。 技术 技术 IDEA Java 开发必备吧。虽然我是个 Android 开发，但是偶尔还是会用到 IDEA 去写写 Java 程序的，并且还可以用这个给 AS 写插件。 Android Studio Android 开发必备。这个不用多说，升级到 2.2 字体渲染比原来好多了。 PyCharm 偶尔写写 Python 玩的时候用下。 Sublime 经常用它来看代码和轻量级的修改代码。再加上 zsh 对它设置了快捷键，很方便打开路径文件夹。 Atom 我比较喜欢用 Atom 来写博客，因为对文件管理和 Markdown 的渲染要好看很多。但是还是有弊端的，在我这里如果篇幅过长还是蛮卡顿的。 不过目前来说还是可以忍受，毕竟还没有找到替代品。 Dash 配合小帽子可以很快速的查看 API 信息，太方便了。感恩。 PDF Expert 用这个软件看电子书，很舒服。并且可以进行一些批注和记录。 Vysor Chrome 插件，很方便展示手机上的内容。 修改最新版协议方法####"},{"title":"Java 基础 —— 多线程（读书笔记）「二」","date":"2016-09-29T08:02:31.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/Review-Java-Thread-2.html","permalink":"http://imxie.cc/hide/Review-Java-Thread-2.html","excerpt":"第二章内容讲讲与多线程相关的方法—— Callable ， Future 和 FutureTask","text":"第二章内容讲讲与多线程相关的方法—— Callable ， Future 和 FutureTask 目录 目录 三个类的介绍 Callable Future FutureTask 实例演示 总结与参考 三个类的介绍CallableCallable 与 Runnable 的功能大致相似，不同的是 Callable 是泛型接口，它有一个泛型参数 V ，该接口中有一个返回值「类型为 V 」的 call() 函数，而 Runnable 的 run() 函数是没有返回参数的。 Callable 的声明如下：public interface Callable&lt;V&gt; &#123; // 泛型返回结果 V call() throws Exception;&#125; Future书中比喻 Runnable 与 Callable 就像『脱缰的野马』，无法控制。对于应用开发，我们需要『战马』，Future 就是这类『战马』的标准。 Future 为线程池制定了一个可管理的任务标准。提供了对 Runnable 或者 Callable 任务的执行结果进行取消，查询是否完成，获取结果，设置结果操作。 Future 的声明如下：public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); // 该任务是否被取消 boolean isCancelled(); // 该任务是否完成 boolean isDone(); // 获取结果，如果任务未完成，则等待，直到完成，因此该函数会阻塞 V get() throws InterruptedException, ExecutionException; // 获取结果，如果任务未完成，则等待，直到 timeout 或者返回结果，该函数会阻塞 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; FutureTaskFuture 只是定义了一些规范的接口，而 FutureTask 是它的实现类。FutureTask 实现了 RunnableFuture ，而 RunnableFuture 实现了 Runnable, Future ，因此 FutureTask 具备了它们的能力。 public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; // 代码省略&#125; RunnableFuture 的定义如下：public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125; FutureTask 会像 Thread 一样对 Runnable 那样对 Runnable 和 Callable 进行包装，是在 FutureTask 构造函数里注入： public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125;public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125; 从上面代码我们可以知道，如果传入的是 Runnable 会被 Executors.callable() 方法转化成 Callable 类型，可知， FutureTask 最终都是执行 Callable 类型的任务。 我们进入 Executors.callable() 函数，看看是如何适配转换的：public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result);&#125;// Runnable 的适配器，将 Runnable 转换成 Callable static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123; final Runnable task; final T result; RunnableAdapter(Runnable task, T result) &#123; this.task = task; this.result = result; &#125; public T call() &#123; task.run(); return result; &#125;&#125; 因为 FutureTask 实现了 Runnable 接口，因此它可以通过 Thread 包装执行，也可以提交给 ExecuteService 来执行。并且还可以直接通过 get() 方法获取执行结果，该方法会阻塞，直到结果返回。所以可以这样理解 FutureTask ： 既是 Runnable 又是 Future ，同时也包装了 Callable (如果是 Runnable 最终会转化成 Callable )。 实例演示public class FutureDemo &#123; // 线程池 static ExecutorService mExecutorService = Executors.newSingleThreadExecutor(); public static void main(String[] args) &#123; try &#123; futureWithRunnable(); futureWithCallable(); futureTask(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; // 向线程池中提交 Runnable 对象 private static void futureWithRunnable() throws InterruptedException, ExecutionException &#123; Future&lt;?&gt; rFuture = mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; fibc(20); &#125; &#125;); System.out.println(\"future result from runnable : \" + rFuture.get()); &#125; // 提交 Callable 对象， private static void futureWithCallable() throws InterruptedException, ExecutionException &#123; Future&lt;Integer&gt; rFuture2 = mExecutorService.submit(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; return fibc(20); &#125; &#125;); System.out.println(\"future result from Callable : \" + rFuture2.get()); &#125; // 提交 FutureTask 对象 private static void futureTask() throws InterruptedException, ExecutionException &#123; FutureTask&lt;Integer&gt; mTask = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; return fibc(20); &#125; &#125;); mExecutorService.submit(mTask); System.out.println(\"future result from futureTask : \" + mTask.get()); &#125; // 斐波那契数列 模拟耗时操作 private static int fibc(int num) &#123; if (num == 0) &#123; return 0; &#125; if (num == 1) &#123; return 1; &#125; return fibc(num - 1) + fibc(num - 2); &#125;&#125; 运行之后，控制台的输出如下： future result from runnable : nullfuture result from Callable : 6765future result from futureTask : 6765 futureWithRunnable() 方法中提交了一个 Runnable 对象，在 run() 方法里直接操作计算，这个方法没有返回值，所以 Future 对象 get() 拿到的值是 Null 。 futureWithCallable() 方法里提交的是一个 Callable 对象&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); Callable 实现的是 V call() 方法，最后会返回一个 Future 对象。 futureTask() 则是一个 RunnableFuture 既实现了 Runnable 又实现了 Future 这两个接口。提交给 ExecutorService 执行后，可以通过返回的 Future 对象 get() 方法得到执行结果。 总结与参考本章内容是作为铺垫，了解和实践了会用到线程池中的三个类。之前我很少接触到，所以写了这篇文章用来加深印象和笔记翻阅。 Android 开发进阶 — 从小工到专家"},{"title":"RxJava + Retrofit 的实际应用场景","date":"2016-05-24T06:38:50.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/RxJava-Retrofit-的实际应用场景.html","permalink":"http://imxie.cc/hide/RxJava-Retrofit-的实际应用场景.html","excerpt":"关于RxJava Retrofit很多篇文章都有详细的说明，在这里我想分享一个具体的使用案例，在我的开源项目 就看天气 里的实际应用。也希望跟大家探讨如何优雅的使用。","text":"关于RxJava Retrofit很多篇文章都有详细的说明，在这里我想分享一个具体的使用案例，在我的开源项目 就看天气 里的实际应用。也希望跟大家探讨如何优雅的使用。 前提 实战 准备 组件 RxSchedulerHelper handleResult RetrofitSingleton 使用 结语 前提需要知道什么是 RxJava 这里推荐下 扔物线写的 给 Android 开发者的 RxJava 详解 再感谢 RxJava 与 Retrofit 结合的最佳实践 这篇满满的干货。 实战准备项目中用到的依赖： compile 'io.reactivex:rxjava:1.1.0'compile 'io.reactivex:rxandroid:1.1.0'compile 'com.google.code.gson:gson:2.4'compile 'com.squareup.retrofit2:retrofit:2.0.2'compile 'com.squareup.retrofit2:converter-gson:2.0.2'compile 'com.squareup.retrofit2:adapter-rxjava:2.0.2'compile 'com.squareup.okhttp3:okhttp:3.0.1'compile 'com.squareup.okhttp3:logging-interceptor:3.0.1'compile 'com.squareup.okio:okio:1.6.0' 因为要用到网络，所以千万别忘记了这个权限。&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 组件Rx 封装的工具 使用compose操作符 compose()里接收一个Transformer对象，Transformer继承自Func1&lt;Observable&lt;T&gt;, Observable&lt;R&gt;&gt;，可以通过它将一种类型的Observable转换成另一种类型的Observable。 RxSchedulerHelper封装 Rx 线程相关操作 public static &lt;T&gt; Observable.Transformer&lt;T, T&gt; rxSchedulerHelper() &#123; return tObservable -&gt; tObservable.subscribeOn(Schedulers.io()) .unsubscribeOn(AndroidSchedulers.mainThread()) .observeOn(AndroidSchedulers.mainThread());&#125; handleResult封装 API 请求后统一处理 public static &lt;T&gt; Observable.Transformer&lt;Result&lt;T&gt;, T&gt; handleResult() &#123; return resultObservable -&gt; resultObservable.flatMap(tResult -&gt; &#123; if (tResult.code == 1) &#123; return createData(tResult.data); &#125; else &#123; return Observable.error(new ApiException(tResult.code)); &#125; &#125;);&#125; RetrofitSingleton自己封装了下 Retrofit。可以学习下小艾的方式。 自己将请求是写在该类，使用者只需要关心如何处理拿到的数据和相应的 UI 操作。 public Observable&lt;Weather&gt; fetchWeather(String city) &#123; return apiService.mWeatherAPI(city, C.KEY) .filter(weatherAPI -&gt; weatherAPI.mHeWeatherDataService30s.get(0).status.equals(\"ok\")) .map(weatherAPI -&gt; weatherAPI.mHeWeatherDataService30s.get(0)) .compose(RxUtils.rxSchedulerHelper());&#125;public Observable&lt;VersionAPI&gt; fetchVersion() &#123; return apiService.mVersionAPI(C.API_TOKEN).compose(RxUtils.rxSchedulerHelper());&#125; 使用将网络拉取和读取缓存用 Rx 结合。这里就要使用 concat 操作符，官方解释. 首先看看获取网络是如何写的： private Observable&lt;Weather&gt; fetchDataByNetWork() &#123; String cityName = Util.replaceCity(mSetting.getCityName()); return RetrofitSingleton.getInstance() .fetchWeather(cityName) .onErrorReturn(throwable -&gt; &#123; PLog.e(throwable.getMessage()); return null; &#125;);&#125; 这里的 onErrorReturn 待会儿说。 再来看看读取缓存的代码：private Observable&lt;Weather&gt; fetchDataByCache() &#123; return Observable.defer(() -&gt; &#123; Weather weather = (Weather) aCache.getAsObject(C.WEATHER_CACHE); return Observable.just(weather); &#125;);&#125; 然后我们将他们连接起来：private void load() &#123; Observable.concat(fetchDataByNetWork(), fetchDataByCache()) .first(weather -&gt; weather != null) .doOnError(throwable -&gt; &#123; mErroImageView.setVisibility(View.VISIBLE); mRecyclerView.setVisibility(View.GONE); &#125;) .doOnNext(weather -&gt; &#123; mErroImageView.setVisibility(View.GONE); mRecyclerView.setVisibility(View.VISIBLE); &#125;) .doOnTerminate(() -&gt; &#123; mRefreshLayout.setRefreshing(false); mProgressBar.setVisibility(View.GONE); &#125;) .subscribe(observer);&#125; concat + first 连接和过滤的操作实现了，网络+缓存的逻辑。 刚刚为什么说要在网络代码那里使用 onErrorReturn 呢？ 如果不写，网络发生异常的话，整个流就会直接走 onError ，不会执行到读取缓存的流。 结语Rx 的各种操作符的不同组合就可以实现不同的效果。本身 Rx 封装已经足够好了，我们加工的时候一定要想到是否破坏了他本身的优雅。 因为 Rx 是一种数据流链式结构的编程思想，我们在封装时应该不能打断其链式结构。 欢迎互相讨论和探讨 :)"},{"title":"RxJava 的一次简单分享","date":"2016-05-30T08:48:21.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/RxJava_for_fresh_learning.html","permalink":"http://imxie.cc/hide/RxJava_for_fresh_learning.html","excerpt":"CampusSay 校园说 Android 端的技术栈中很大一部分是 RxJava ，为了帮助小伙伴能够入手项目，自己在这里做一个简单的技术分享，大家一起讨论。 感谢 Mr.Fu 做的 Keynote","text":"CampusSay 校园说 Android 端的技术栈中很大一部分是 RxJava ，为了帮助小伙伴能够入手项目，自己在这里做一个简单的技术分享，大家一起讨论。 感谢 Mr.Fu 做的 Keynote 0x01 入门 介绍 为什么使用？ 基本概念 实操练习 0x02 项目实例 0x03 讨论 0x01 入门介绍 一个在 Java VM 上使用可观测序列来组成的异步的、基于事件的程序的库 这是 RxJava 的官方解释，扔物线前辈总结了一点特别好。 其实， RxJava 的本质可以压缩为异步这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的。 为什么使用？简洁，异步。 随着程序逻辑变得越来越复杂，它依然能够保持简洁和清晰。 举个例子 一组文件夹下所有的 png 图片都加载出来，并显示在 imageCollectorView 内 看看不用 RxJava 是这么写：new Thread() &#123; @Override public void run() &#123; super.run(); for (File folder : folders) &#123; File[] files = folder.listFiles(); for (File file : files) &#123; if (file.getName().endsWith(\".png\")) &#123; final Bitmap bitmap = getBitmapFromFile(file); getActivity().runOnUiThread(new Runnable() &#123;@Overridepublic void run() &#123; imageCollectorView.addImage(bitmap);&#125; &#125;); &#125; &#125; &#125; &#125;&#125;.start(); 现在我们试试 RxJava 来写这段逻辑：Observable.from(folders).flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123; @Override public Observable&lt;File&gt; call(File file) &#123; return Observable.from(file.listFiles()); &#125;&#125;).filter(new Func1&lt;File, Boolean&gt;() &#123; @Override public Boolean call(File file) &#123; return file.getName().endsWith(\".png\"); &#125;&#125;).map(new Func1&lt;File, Bitmap&gt;() &#123; @Override public Bitmap call(File file) &#123; return getBitmapFromFile(file); &#125;&#125;).subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; imageCollectorView.addImage(bitmap); &#125;&#125;); 如果使用 lambda 你看到的是这样的：Observable.from(folders) .flatMap((Func1) (folder) -&gt; &#123; Observable.from(file.listFiles()) &#125;) .filter((Func1) (file) -&gt; &#123; file.getName().endsWith(\".png\") &#125;) .map((Func1) (file) -&gt; &#123; getBitmapFromFile(file) &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe((Action1) (bitmap) -&gt; &#123; imageCollectorView.addImage(bitmap) &#125;); 基本概念 Observable 对于我的理解是一个“车间头”，随后所有连接的操作符都是“加工方式”，最后再给“订阅者（Subscriber）” 添加订阅关系的方法是 subscribe()public final Subscription subscribe(final Observer&lt;? super T&gt; observer) &#123; if (observer instanceof Subscriber) &#123; return subscribe((Subscriber&lt;? super T&gt;)observer); &#125; return subscribe(new ObserverSubscriber&lt;T&gt;(observer));&#125; 可以看到无论我们传入 subscribe() 里的参数是 Subscriber 还是 Observe ，最终都会转化成 Subscriber 。 可以知道 Subscriber 比起 Observe 更能让我们做好状态的控制。 那么 Subscriber 是多久取消订阅的呢？ 我们深入源码看看： 前面我看到添加了订阅关系后 observer 会被转化成 Subscriber 随后我们继续深入我们发现最终会到：private static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) &#123; // 省略无关代码 subscriber.onStart(); if (!(subscriber instanceof SafeSubscriber)) &#123; subscriber = new SafeSubscriber&lt;T&gt;(subscriber); &#125; // 忽略 &#125; 我们发现了 SafeSubscriber ，深入发现该类中方法：public void onCompleted() &#123; if (!done) &#123; done = true; try &#123; actual.onCompleted(); &#125; catch (Throwable e) &#123; &#125; finally &#123; unsubscribe(); &#125; &#125; &#125; 得知 最终它在 finally 里自动取消订阅了。 实操练习输出一个 Hello World 新的需求，Hello World - xxx 加上签名 Observable 和 Subscriber 是独立于中间的变换过程的。 所以上述最好是使用 map 来实现转换。 先到这里简单入了个门。更多的操作符使用，参考 RxJava 的文档。 0x02 项目实例参考我的这篇 RxJava + Retrofit 的实际应用场景,这里详细介绍了 RxJava 一个实际使用案例。 0x03 讨论有任何问题，我们都可以讨论 :)"},{"title":"一次简单地封装 SharedPreferences","date":"2016-03-12T12:31:17.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/SharedPreferences-Util.html","permalink":"http://imxie.cc/hide/SharedPreferences-Util.html","excerpt":"有一段时间开发，经常用 SharedPreferences 所以可以想尝试下简单封装，让 SharedPreferences 更易于开发使用。","text":"有一段时间开发，经常用 SharedPreferences 所以可以想尝试下简单封装，让 SharedPreferences 更易于开发使用。 单一public SPUtil() &#123; throw new AssertionError(\"no instance\");&#125;private static class Holder &#123; private static SharedPreferences sp = App.getContext().getSharedPreferences(C.DEFAULT, Activity.MODE_PRIVATE);&#125;private static SharedPreferences getSP() &#123; return Holder.sp;&#125; 工具类本身不需要构造，内部类里实例化一个生命周期是 Application 的 SharedPreferences 对象。 内部使用调用 getSP() 方法即可。 统一方法（我这里只写了两个）： public static void putInt(String key, int value) &#123; getSP().edit().putInt(key, value).apply();&#125;public static int getInt(String key, int defValue) &#123; return getSP().getInt(key, defValue);&#125;public static void putString(String key, String value) &#123; getSP().edit().putString(key, value).apply();&#125;public static String getString(String key, String defValue) &#123; return getSP().getString(key, defValue);&#125; 具体使用public static void setUuid(String uuid) &#123; putString(\"uuid\", uuid);&#125;public static String getUuid() &#123; return getString(\"uuid\", \"\");&#125; 上层只需要使用 SPUtil.get/setUuid() 即可对该 Value 进行获取和设置。 如果有更好方便的思路，请留言告知交流谢谢"},{"title":"不务正业—— Sketch 学习之路","date":"2016-07-04T14:24:50.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/Sketch-learning-as-android.html","permalink":"http://imxie.cc/hide/Sketch-learning-as-android.html","excerpt":"引言这篇纯粹是为了满足我一直崇拜设计师，业余时间向他们学习的记录。","text":"引言这篇纯粹是为了满足我一直崇拜设计师，业余时间向他们学习的记录。 实战模仿雨滴 教程来自 使用Sketch 3设计水滴图标 教程感受： 简单学习了 Sketch 的插入图形（矩形，圆，三角形），学习到了内/外阴影、渐变的应用，同时还有两个图形的组合【Union】 小鸟 教程来自 Sketch 创建小鸟图标 教程感受： 初步接触了钢笔工具的使用，同时巩固了图形的一些变换。不过对于蒙版和阴影还没有做好。"},{"title":"Update Ruby With RVM About Brew Error","date":"2016-07-13T02:51:52.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/Update-Ruby-With-RVM-About-Brew-Error.html","permalink":"http://imxie.cc/hide/Update-Ruby-With-RVM-About-Brew-Error.html","excerpt":"要运行 IOS 的应用程序，需要安装 CocoaPods ，然后又需要 Ruby ，发现安装的时候说 Ruby 版本过低（我 MBP 自带的版本号是 2.0 ==&gt; 2.2.2），所以又得找个 RVM 用来升级 Ruby。","text":"要运行 IOS 的应用程序，需要安装 CocoaPods ，然后又需要 Ruby ，发现安装的时候说 Ruby 版本过低（我 MBP 自带的版本号是 2.0 ==&gt; 2.2.2），所以又得找个 RVM 用来升级 Ruby。 安装 RVM $ curl -L get.rvm.io | bash -s stable 等待之后 $ source ~/.bashrc $ source ~/.bash_profile 测试是否正常 $ rvm -v 升级 Ruby $ rvm install 2.2.4 Found remote file https://rvm_io.global.ssl.fastly.net/binaries/osx/10.11/x86_64/ruby-2.2.2.tar.bz2Checking requirements for osx.ERROR: &apos;/usr/local/Cellar&apos; is not writable - it is required for Homebrew, try &apos;brew doctor&apos; to fix it!Requirements installation failed with status: 1. 遇到上述错误。 解决方案： sudo chown -R $USER /usr/local 再次运行 rvm install 2.2.2 等待升级完成。 安装 CocoaPods因为GFW，所以我们可以用淘宝的 Ruby 镜像来访问 cocoapods 。按照下面的顺序在终端中敲入依次敲入命令： $ gem sources –remove https://rubygems.org///等有反应之后再敲入以下命令$ gem sources -a https://ruby.taobao.org/ 为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看： ▶ gem sources -l 出现这个就可以了： CURRENT SOURCES https://ruby.taobao.org/ 最后进行安装： $ sudo gem install cocoapods"},{"title":"JitPack 指南","date":"2016-12-04T08:02:31.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/how_to_upload_your_project_to_jitpack.html","permalink":"http://imxie.cc/hide/how_to_upload_your_project_to_jitpack.html","excerpt":"前言最初发布一些 lib 是用的 jCenter ，但是每次上传都跟玄学一样，就算我全局或者指定代理还是凭运气，后来问了老司机，结识了 JitPack ，体验更加方便和易懂。","text":"前言最初发布一些 lib 是用的 jCenter ，但是每次上传都跟玄学一样，就算我全局或者指定代理还是凭运气，后来问了老司机，结识了 JitPack ，体验更加方便和易懂。 文章来源：itsCoder 的 WeeklyBolg 项目 itsCoder主页：http://itscoder.com/ 作者：谢三弟 审阅者：JoeSteven 步骤账号 首先进入网页我们看到是： 然后我们进行账号登陆，默认是跟 Github 绑定的。 成功之后网站会读取你的 repo 显示在左侧： Gradle 配置 首先在你的 root build.gradle 添加： buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.2' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5' // 这一栏 &#125;&#125; 接下来在你的 Lib build.gradle 添加： group = &apos;com.github.&lt;username&gt;&apos; // 最好是你的 github 名字// 指定编码tasks.withType(JavaCompile) &#123; options.encoding = &quot;UTF-8&quot;&#125;// 打包源码task sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = &apos;sources&apos;&#125;artifacts &#123; archives sourcesJar&#125; 配置完成后，将你的项目 push 到 github 点击 Releases 编写好之后发布，回到 JitPack 发布 根据你的 group/Lib 搜索你的裤子。 点击 get it 别人就可以用到你写的裤子了 (๑•̀ㅂ•́) ✧ 更新裤子 更新你的裤子，用上述同样的方法。 不过在你完成发布新版的时候，最好删除原来的 Tag 。 参考全文以 Watcher: Help to watch the fps and used memory of your app 为实践，如果有疑问可以参考该项目模仿配置。 JitPack"},{"title":"Java 基础复习实践 --- CallBack","date":"2016-07-23T02:54:27.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/let-s-talk-about-callback.html","permalink":"http://imxie.cc/hide/let-s-talk-about-callback.html","excerpt":"很早之前不知道如何解释清楚回调函数（CallBack），在知乎上看到一个回答特别形象，当时就收藏了，所以今天决定用代码的形式再让这个回答更加深刻点。 知乎-回调函数（callback）是什么？ 然后再看看 Android 里的应用。","text":"很早之前不知道如何解释清楚回调函数（CallBack），在知乎上看到一个回答特别形象，当时就收藏了，所以今天决定用代码的形式再让这个回答更加深刻点。 知乎-回调函数（callback）是什么？ 然后再看看 Android 里的应用。 什么是回调函数 Android 里常见的回调 什么是回调函数维基的解释： 在计算机程序设计中，回调函数，或简称回调（Callback 即call then back 被主函数调用运算后会返回主函数），是指通过函数参数传递到其它代码的，某一块可执行代码的引用。这一设计允许了底层代码调用在高层定义的子程序。 我认为通俗易懂的解释： 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。回答完毕。 可能看着通俗的解释能够知道是怎么回事，但是轮到自己要去实现一个回调的时候，就有点寸步难行了。所以我简单将那个解释，转换成了代码再解释一番。 首先我得定义一个接口（我的电话号码）： public interface INumber &#123; public void onCall();&#125; 我去商店买东西，该商店对象刚刚初始化：Store store = new Store(); 然后我才得知商店刚刚开门没有我要的货（商店构造函数）:public class Store &#123; public Store() &#123; Utils.sout(\"才开店，没有货\"); Utils.sout(\"=============\"); &#125;&#125; 所以我把我的电话号码留给店员，对于店员来说就是得到我的电话号码(注册事件)：private INumber number;public void setNumber(INumber number) &#123; this.number = number;&#125;public void call() &#123; number.onCall();&#125;/**************注册前的准备工作完毕**************/public static void main(String[] args) &#123; Store store = new Store(); // 先注册好事件 store.setNumber(new INumber() &#123; @Override public void onCall() &#123; Utils.sout(\"=============\"); Utils.sout(\"货到了\"); &#125; &#125;); for (int i = 1; i &lt; 4; i++) &#123; Utils.sout(\"模拟取货：\" + i + \"小时\"); &#125; // 货到了就打电话通知我 store.call();&#125; 整体控制台输出： 才开店，没有货= = = = = = = = = = = = =模拟取货：1小时模拟取货：2小时模拟取货：3小时= = = = = = = = = = = = =货到了 商店类的完整代码：public class Store &#123; public Store() &#123; Utils.sout(\"才开店，没有货\"); Utils.sout(\"=============\"); &#125; private INumber number; public void setNumber(INumber number) &#123; this.number = number; &#125; public void call() &#123; number.onCall(); &#125; public static void main(String[] args) &#123; Store store = new Store(); store.setNumber(new INumber() &#123; @Override public void onCall() &#123; Utils.sout(\"=============\"); Utils.sout(\"货到了\"); &#125; &#125;); for (int i = 1; i &lt; 4; i++) &#123; Utils.sout(\"模拟取货：\" + i + \"小时\"); &#125; store.call(); &#125;&#125; Android 里常见的回调我们经常这样写：btShowDialog = (Button) findViewById(R.id.bt_showdialog);btShowDialog.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // do something &#125;&#125;); 我们经常可以看到这样类似的代码，监听一个按钮的点击事件，当用户点击之后，我们执行一些逻辑。 这里的 setOnClickListener() 就跟我们之前店员获得我的电话号码的方法一样 setNumber() 注册好事件。源码：/** * Register a callback to be invoked when this view is clicked. If this view is not * clickable, it becomes clickable. * * @param l The callback that will run * * @see #setClickable(boolean) */public void setOnClickListener(@Nullable OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l;&#125;/** * Interface definition for a callback to be invoked when a view is clicked. */public interface OnClickListener &#123; /** * Called when a view has been clicked. * * @param v The view that was clicked. */ void onClick(View v);&#125; 到这里的时候是不是就很清晰了呢？"},{"title":"Python 初探 leancloud","date":"2016-04-27T01:03:58.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/python-初探-leancloud.html","permalink":"http://imxie.cc/hide/python-初探-leancloud.html","excerpt":"很久没有写 Python 了，自己阿里云的服务器也忘记续费而被释放。当初用的东西有点重，Ubuntu 下定时任务执行一个 Python 爬虫，将爬取到的数据写入 MySQL ，接口是 Java 那一套 tomcat 。 所以准备写个系列，从简单的使用 leancloud 的存储到 leancloud 的云引擎。","text":"很久没有写 Python 了，自己阿里云的服务器也忘记续费而被释放。当初用的东西有点重，Ubuntu 下定时任务执行一个 Python 爬虫，将爬取到的数据写入 MySQL ，接口是 Java 那一套 tomcat 。 所以准备写个系列，从简单的使用 leancloud 的存储到 leancloud 的云引擎。 0x01 准备安装 virtualenv使用 virtualenv 可以创建一个与系统隔离的 Python 环境，在其中安装的第三方模块版本不会与系统自带的或者其他项目中的模块冲突。 安装 virtualenv &gt; pip install virtualenv 创建虚拟并激活虚拟环境cd yourProjectvirtualenv ENV(自取)source bin/activate 命令行上出现 (ENV) 表示是在当前虚拟环境下 使用 deactivate 可以退出虚拟环境 安装 leancloud-sdkpip install leancloud-sdk 0x02 数据存储初始化 leancloudimport leancloudfrom leancloud import Objectleancloud.init('id', 'key') id 和 key 在 项目 &gt; 设置 &gt;应用 Key 中查看。 存储数据class GirlImage(Object): @property def src(self): # 可以使用property装饰器，方便获取属性 return self.get('src') @src.setter def src(self, value): # 同样的，可以给对象的score增加setter return self.set('src', value)girl_image = GirlImage()girl_image.set('src',\"地址\")girl_image.save() 执行完之后，你会在项目存储&gt;数据下看到已经新建好了 GirlImage 这个表并且保存了一条src = 地址 的数据。 爬取存储def http(): page = 1 url = 'http://www.dbmeinv.com/dbgroup/current.htm?gid=haixiuzu&amp;pager_offset=' + str(page) headers = &#123;'content-type': 'text/html;charset=UTF-8', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.87 Safari/537.36 QQBrowser/9.2.4907.400'&#125; content = requests.post(url, headers).text images_codes = re.findall('&lt;img class=\"height_min\" .+? src=\"(.*?)\"', content, re.S) # print images_codes for url in images_codes: girl_image = GirlImage() girl_image.set(\"src\", url) girl_image.save() 一个简单的小爬虫，爬了该网站一页图片，20条存入 leancloud 。 查询query = Query(GirlImage) # 这里也可以直接传递一个 Class 名字的字符串作为构造参数query.select('src')reslut = query.find()for i in reslut: print(i.get('src')) 0x03初探就先这样结束了，我这里只是运用了很简单的功能。 不过爬取&gt;存储&gt;查询，都写全了。 后期我会再探 leancloud 写增量爬取加 leancloud 的云引擎。 更多请参考leancloud 对象操作 leancloud 查询操作"},{"title":"Android开发：shape和selector和layer-list","date":"2016-01-24T05:34:11.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/shap.html","permalink":"http://imxie.cc/hide/shap.html","excerpt":"","text":"整理了 shape selector 和 layer-list 的知识。 shape简介作用：XML中定义的几何形状位置：res/drawable/文件的名称.xml 方法Java代码中：R.drawable.文件的名称XML中：Android:background=”@drawable/文件的名称” shape属性Android:shape=[“rectangle” | “oval” | “line” | “ring”]其中rectagle矩形，oval椭圆，line水平直线，ring环形 子属性 &lt; gradient&gt; 渐变Android:startColor起始颜色Android:endColor结束颜色Android:angle渐变角度，0从左到右，90表示从下到上，数值为45的整数倍，默认为0；Android:type渐变的样式 liner线性渐变 radial环形渐变 sweep&lt; solid &gt; 填充Android:color填充的颜色&lt; stroke &gt;描边Android:width描边的宽度Android:color描边的颜色Android:dashWidth 表示’-‘横线的宽度Android:dashGap表示’-‘横线之间的距离&lt; corners &gt;圆角Android:radius圆角的半径 值越大角越圆Android:topRightRadius右上圆角半径Android:bottomLeftRadius右下圆角角半径Android:topLeftRadius左上圆角半径Android:bottomRightRadius左下圆角半径&lt; padding &gt;填充android:bottom=”1.0dip”底部填充android:left=”1.0dip”左边填充android:right=”1.0dip”右边填充android:top=”0.0dip”上面填充 Selector简介根据不同的选定状态来定义不同的现实效果分为四大属性：android:state_selected 是选中android:state_focused 是获得焦点android:state_pressed 是点击android:state_enabled 是设置是否响应事件,指所有事件另：android:state_window_focused 默认时的背景图片引用位置：res/drawable/文件的名称.xml 方法Java代码中：R.drawable.文件的名称XML中：Android:background=”@drawable/文件的名称” &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt; &lt;selector xmlns:Android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;!-- 默认时的背景图片--&gt; &lt;item Android:drawable=\"@drawable/pic1\" /&gt; &lt;!-- 没有焦点时的背景图片 --&gt; &lt;item Android:state_window_focused=\"false\" android:drawable=\"@drawable/pic_blue\" /&gt; &lt;!-- 非触摸模式下获得焦点并单击时的背景图片 --&gt; &lt;item Android:state_focused=\"true\" android:state_pressed=\"true\" android:drawable= \"@drawable/pic_red\" /&gt; &lt;!-- 触摸模式下单击时的背景图片--&gt; &lt;item Android:state_focused=\"false\" Android:state_pressed=\"true\" Android:drawable=\"@drawable/pic_pink\" /&gt; &lt;!--选中时的图片背景--&gt; &lt;item Android:state_selected=\"true\" android:drawable=\"@drawable/pic_orange\" /&gt; &lt;!--获得焦点时的图片背景--&gt; &lt;item Android:state_focused=\"true\" Android:drawable=\"@drawable/pic_green\" /&gt; &lt;/selector&gt; layer-list将多个图片或上面两种效果按照顺序层叠起来&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item&gt; &lt;bitmap android:src=\"@drawable/android_red\" android:gravity=\"center\" /&gt; &lt;/item&gt; &lt;item android:top=\"10dp\" android:left=\"10dp\"&gt; &lt;bitmap android:src=\"@drawable/android_green\" android:gravity=\"center\" /&gt; &lt;/item&gt; &lt;item android:top=\"20dp\" android:left=\"20dp\"&gt; &lt;bitmap android:src=\"@drawable/android_blue\" android:gravity=\"center\" /&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;ImageView android:layout_height=\"wrap_content\" android:layout_width=\"wrap_content\" android:src=\"@drawable/layers\" /&gt;"},{"title":"讨论下 RxJava 里的 onError","date":"2016-06-01T06:12:26.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/tao-lun-Rx-onError.html","permalink":"http://imxie.cc/hide/tao-lun-Rx-onError.html","excerpt":"因为上次在网络请求里用到了 onErrorReturn 所以想自己实践下和搞清楚 RxJava 里异常处理到底是怎么回事，以及自己如何更好的使用。","text":"因为上次在网络请求里用到了 onErrorReturn 所以想自己实践下和搞清楚 RxJava 里异常处理到底是怎么回事，以及自己如何更好的使用。 栗子public class RxJavaTest &#123; static int[] arrayA = new int[2]; static List&lt;Integer&gt; listB = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; listB.add(1); listB.add(2); listB.add(3); errorTest(); &#125; private static void errorTest() &#123; Observable.from(listB) .doOnNext(integer -&gt; arrayA[integer] = integer) .subscribe(integer -&gt; &#123; &#125;, throwable -&gt; &#123; System.out.println(\"在onError处理了:\" + throwable.toString()); &#125;); &#125;&#125; 可以看到我在这里模拟了一个越界异常，在 errorTest() 方法里做写了遍历列表 listB 并且将值赋值给数组 arrayA 对应角标。 运行以上程序在控制台输出的是： 在onError处理了:java.lang.ArrayIndexOutOfBoundsException: 2 现在我们做一点改变： 在 errorTest 方法里加入 onErrorReturn 并且返回 null private static void errorTest() &#123; Observable.from(listB) .doOnNext(integer -&gt; arrayA[integer] = integer) .onErrorReturn(throwable -&gt; &#123; System.out.println(\"在onErrorReturn处理了:\" + throwable.toString()); return null; &#125;) .subscribe(integer -&gt; &#123; &#125;, throwable -&gt; &#123; System.out.println(\"在onError处理了:\" + throwable.toString()); &#125;);&#125; 现在再运行程序得到在控制台的输出是： 在onErrorReturn处理了:java.lang.ArrayIndexOutOfBoundsException: 2 发现异常只在 onErrorReturn 处理了，并没有在 onError 里。 难道只要写了 onErrorReturn 处理了异常就不会抛到 onError 里吗？ 带着这个疑问，我们再修改下 errorTest() 方法：private static void errorTest() &#123; Observable.from(listB) .doOnNext(integer -&gt; arrayA[integer] = integer) .onErrorReturn(throwable -&gt; &#123; System.out.println(\"在onErrorReturn处理了:\" + throwable.toString()); return 3; &#125;) .doOnNext(integer -&gt; arrayA[integer] = integer) .subscribe(integer -&gt; &#123; &#125;, throwable -&gt; &#123; System.out.println(\"在onError处理了:\" + throwable.toString()); &#125;);&#125; 让 onErrorReturn 处理了异常后并且返回一个 3，随后继续进行赋值操作。 现在运行程序，控制台输出：在onErrorReturn处理了:java.lang.ArrayIndexOutOfBoundsException: 2在onError处理了:java.lang.ArrayIndexOutOfBoundsException: 3 总结onErrorRetrun 能够捕获在它之前发生的异常，它之后流中的操作发生的异常就它就不会管了。经过小栗子的演示，我们现在理解了 onErrorReturn 的作用域，从而明白该什么时候使用它。 参考文章： https://mcxiaoke.gitbooks.io/rxdocs/content/operators/Catch.html https://dzone.com/articles/rxjavas-side-effect-methods http://blog.chengyunfeng.com/?p=976"},{"title":"【校对】世界级Android测试开发流程（一）","date":"2016-02-24T12:05:17.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/【校对】世界级Android测试开发流程（一）.html","permalink":"http://imxie.cc/hide/【校对】世界级Android测试开发流程（一）.html","excerpt":"原文链接 : World-Class Testing Development Pipeline for Android - Part 1. 原文作者 : Karumi 译文出自 : 掘金翻译计划 译者 : markzhai 校对者: JustWe, Hugo Xie","text":"原文链接 : World-Class Testing Development Pipeline for Android - Part 1. 原文作者 : Karumi 译文出自 : 掘金翻译计划 译者 : markzhai 校对者: JustWe, Hugo Xie 世界级的 Android 测试开发流程（一）在开发完移动应用并和手动QA团队合作了数年后，我们决定开始写测试。作为工程师，我们知道，自动化测试是成功的移动开发之关键。 在这篇博客里，我将会分享我们的故事——Karumi启动于几年前的测试故事。这是系列博客的第一篇，我们将会囊括世界级的 Android测试流程的所有方面。 几年前，我们开始为移动应用写测试。我们对测试了解有限，所以我们致力于接受测试并使用最常用的框架来做单元测试，一个简单的test runner和mocking库。过了一段时间我们遇到了问题： 我们不知道测试什么和如何去测试它。 我们的代码还没准备好被测试。 我们沉迷于Mike Cohn的测试金字塔，却没有考虑到我们在写的软件类型。 即使我们的测试通过了，也不意味着代码没有问题。 是不是很可怕? 我们花了很多时间去克服这些挑战，在某个时刻我们意识到是方法错了。即便测试覆盖率很高，我们的软件仍然在出错。最坏的是，从我们的测试中，无法得到任何反馈。解决我们的问题的关键是识别出我们一直碰到的问题所在： 我们的接受测试太难写了，因为我们需要提供配置API来模拟接受测试的初始状态。 大部分时候，我们的测试会随机失败，而我们不知道为什么。只能用重复编译来通过测试。 我们有大量的单元测试和高覆盖率，但我们的单元测试从未失败。即便应用出问题了，我们的测试仍然能通过。 我们用很多时间去验证mock的调用。 我们不得不使用一些“魔法”测试工具来测试代码，一个私有方法或者模拟静态方法的调用结果。 这是我们决定停下，并开始思考为什么我们对自己的测试感觉不爽。我们快速需要找到问题的解决方案。我们的项目告诉说我们做错了，我们需要解决方案，我们需要一个测试开发流程。话虽如此，为了改善程序质量，测试开发流程不总是第一件要完善的事。 一个测试开发流程定义了测什么、怎么测。用什么工具，为什么用？测试的范围是什么？即便有良好的测试开发流程，可测试的代码对有自信去写测试仍然是必须的，因为大部分的测试是不可能的，或者至少，很难去写。如果你的代码没有准备好，与代码以及单元或集成范围最贴近的测试并不是那么容易去写的。因此，我们决定带着这些目标，首先识别出应用中的问题，然后去解决它们。那么问题来了，如果我们的代码能够是完美的，我们对它有何期望呢？期望是： 应用必须是可测试的。 代码必须是可读的。 职责必须是清晰而有结构的。 低耦合高内聚。 代码必须是诚实的。 在重构之前代码一团糟。软件职责丢失在代码的行与行之间。实现细节是完全暴露的，activities和fragments负责处理软件的状态，到处都是软件状态。另外，我们的业务逻辑和框架是耦合的。带着这些问题，我们决定把应用架构改成其他更有结构的东西。我们使用的架构是 “Clean Architecture”。除了架构的核心内容，我们还应用了一些和GUI应用相关模式像是MVP和MMVM，以及数据处理相关的模式像是Repository模式。架构详情和这篇博客没有关系（我们会在未来的博文中讨论到它），“Clean Architecture”的核心元素与最重要的SOLID原则之一，依赖倒置原则相关。 依赖倒置原则提出你的代码必须依赖于抽象而不是具体实现。这个原则，仅仅是这个原则就是通向成功的钥匙。它是改变我们的代码并适配测试策略以有效克服我们手上问题的关键。依赖于抽象既无关于依赖注入框架，也无关于使用Java接口来定义类的API。然而，它与隐藏细节有关。根据不同角色，软件职责改变的点，引入测试替身(TestDouble)的点去创建层，大大限制了测试的范围。 通过依赖倒置原则，我们能够去选择正确数量的代码去测试。一旦这些点清晰了，我们就停下为所有的mocks去写测试。我们能够使用准确数字的mocks去覆盖一个测试用例，并确保我们在测试软件状态而不仅仅是组件之间的交互。 一旦应用架构清晰了，我们开始 定义我们的测试开发流程。我们的目标是回答2个问题：我们想要测试什么？我们如何去测试它？ 在尝试找出如何分割测试，并用简单又可读的方式去写以后，我们注意到层次分离是最完美的出发点。结果，解决方案变得清晰： 我们想要测试什么? 独立于任何框架或者库去测试我们的业务逻辑。 测试我们的API集成。 持久化框架的集成。 一些通用UI组件。 测试黑盒场景下，从用户视角写的的接收准则。 我们想要怎么去测试? 这是我们在下一博客文章要说的东西，敬请期待！;) 参考: 世界级的Android测试开发流程幻灯片 by Pedro Vicente Gómez Sánchez. http://www.slideshare.net/PedroVicenteGmezSnch/worldclass-testing-development-pipeline-for-android Mike Cohn的测试金字塔 by Martin Fowler. http://martinfowler.com/bliki/TestPyramid.html Clean架构 by Uncle Bob. https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html 在野外的DIP by Martin Fowler.http://martinfowler.com/articles/dipInTheWild.html 测试替身 by Martin Fowler. http://www.martinfowler.com/bliki/TestDouble.html"},{"title":"【转】RxBus 的简单实现","date":"2016-06-02T12:20:25.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/【转】RxBus-的简单实现.html","permalink":"http://imxie.cc/hide/【转】RxBus-的简单实现.html","excerpt":"这篇转自 brucezz 今天写代码正好想到要用事件总线，先前都是使用 Square 的 Otto 或者 GreenRobot 的 EventBus ，听说 RxJava 能够轻易实现一个 Bus，所以就来研究研究这个车怎么开~","text":"这篇转自 brucezz 今天写代码正好想到要用事件总线，先前都是使用 Square 的 Otto 或者 GreenRobot 的 EventBus ，听说 RxJava 能够轻易实现一个 Bus，所以就来研究研究这个车怎么开~ 这辆车需要有一下功能： 订阅者能够订阅某种事件 Event 发布某种 Event 时，该事件的订阅者们能够及时响应 在 RxJava 里有一个对象 Subject，既是 Observable 又是 Observer，可以把 Subject 理解成一个管道或者转发器，数据从一端输入，然后从另一端输出。 Subject 有好几种，这里可以使用最简单的 PublishSubject。一旦数据从一端传入，结果会里立刻从另一端输出。 由于允许订阅者订阅某一种类型的 Event，所以注册订阅的时候需要一个 Class 对象对事件进行过滤。 简单实现public class RxBus &#123; private static volatile RxBus instance; private final Subject&lt;Object, Object&gt; BUS; private RxBus() &#123; BUS = new SerializedSubject&lt;&gt;(PublishSubject.create()); &#125; public static RxBus getDefault() &#123; if (instance == null) &#123; synchronized (RxBus.class) &#123; if (instance == null) &#123; instance = new RxBus(); &#125; &#125; &#125; return instance; &#125; public void post(Object event) &#123; BUS.onNext(event); &#125; public &lt;T&gt; Observable&lt;T&gt; toObserverable(Class&lt;T&gt; eventType) &#123; // ofType = filter + cast return BUS.ofType(eventType); &#125;&#125; 其中，RxBus 使用了单例模式，确保应用中只有一辆车。 post 方法发布一个 Event 对象给 bus，然后由 bus 转发给订阅者们。 toObserverable 方法能够获得一个包含目标事件的 Observable，订阅者对其订阅即可响应。 bus.ofType() 等效于 bus.filter(eventType::isInstance).cast(eventType) ，即先过滤事件类型，然后发射给订阅者。 开车啦public class RxBusActivity extends AppCompatActivity &#123; private CompositeSubscription allSubscription = new CompositeSubscription(); Button send; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); send = (Button) findViewById(R.id.send); send.setOnClickListener( v -&gt; RxBus.getDefault().post(new OneEvent(\"hello bus\"))); allSubscription.add(RxBus.getDefault() .toObserverable(OneEvent.class).subscribe(this::response)); &#125; private void response(OneEvent event) &#123; ToastUtil.show(event.msg); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (allSubscription != null &amp;&amp; !allSubscription.isUnsubscribed()) allSubscription.unsubscribe(); &#125; class OneEvent &#123; // some data you need ... String msg; public OneEvent(String msg) &#123; this.msg = msg; &#125; &#125;&#125; 点击按钮，发送 OneEvent 事件，然后响应此事件，发出 Toast ~ 通过多次调用 toObserverable() 方法可以订阅多种事件。 小 tip : CompositeSubscription 可以把 Subscription 收集到一起，方便 Activity 销毁时取消订阅，防止内存泄漏。 Reference 翻译：通过 RxJava 实现一个 Event Bus – RxBus | Drakeet的个人博客 用RxJava实现事件总线(Event Bus) - 简书"},{"title":"为自己的App搭建自定义API接口","date":"2015-11-20T16:02:52.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/为自己的App搭建自定义API接口.html","permalink":"http://imxie.cc/hide/为自己的App搭建自定义API接口.html","excerpt":"做过爬虫，爬取过自己喜欢的图片（咳咳），当初只会手动执行并且下载到本地，这样的话比较无聊，不好玩。后来跟着高架构学了点服务器和简单的API接口搭建。用服务器可以自动化很多操作（配合Python），API接口搭建自己用的是（Java + Tomcat），数据储存是Mysql。","text":"做过爬虫，爬取过自己喜欢的图片（咳咳），当初只会手动执行并且下载到本地，这样的话比较无聊，不好玩。后来跟着高架构学了点服务器和简单的API接口搭建。用服务器可以自动化很多操作（配合Python），API接口搭建自己用的是（Java + Tomcat），数据储存是Mysql。 实践服务器Tomcat安装和启动 首先同样我们需要将Tomcat 7下载下来。打开Tomcat的官网。我们选择左边的Tomcat 7下载 我的是Ubuntu系统的服务器，选择tar.gz下载方式，用本地化工具将该文件上传给服务器 我是讲文件放在/usr/local/software/下，然后用tar命令进行解压 当解压成功后，进入tomcat7/bin目录下，输入sh startup.sh启动tomcat 在浏览器输入服务器ip:8080，出现tomcat默认界面即启动成功 将程序部署到服务器 对Eclipse项目右键 –&gt; Export –&gt; WAR file 将打包好的war项目放在服务器tomcat目录下的webapps文件夹中 重启tomcat服务器即可tomcat/bin目录下 sh shutup.sh后sh startup.sh Java代码数据库（DAO）数据库连接String url = &quot;jdbc:mysql://localhost:3306/数据库名&quot;;String usrname = &quot;root&quot;;String passwd = &quot;***&quot;;Class.forName(&quot;com.mysql.jdbc.Driver&quot;);connection = DriverManager.getConnection(url, usrname, passwd); 查询语句public ResultSet selectSQL(String sql,Connection connection) &#123; ResultSet rs = null; try &#123; statement = connection.prepareStatement(sql); rs = statement.executeQuery(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return rs; &#125; 主类（extends HttpServlet）在doGet方法里写（贴下关键代码）PrintWriter pw=response.getWriter();Dao d = new Dao();Connection connection = d.connectSQL();int index = 0;String url = &quot;&quot;;String s = &quot;select url from img where date=&quot;+date;JSONObject jsonObject = new JSONObject();JSONArray jsonArray = new JSONArray();ResultSet rs = d.selectSQL(s,connection); 数据用JSON包装：while(rs.next())&#123; url = rs.getString(\"url\"); jsonArray.add(index, url); jsonObject.put(\"date\", today); jsonObject.put(\"urls\", jsonArray); &#125; 显示：pw.println(jsonObject);pw.flush();pw.close(); 接下来访问地址主机ip:8080/项目名/主类名?date=改程序即可根据用户输入的日期（YYMMDD格式）进行查询数据库，根据日期输出满足条件的 所有数据。该数据为JSON。 Python新学了如何用python操作mysql，其他的都是以前的知识，比如网络请求（requests），正则匹配（re）。 数据库操作核心代码db = MySQLdb.connect(\"localhost\", usrname, passwd, \"db_girlimg\")cursor = db.cursor()first_sql = \"select url from img WHERE id=%d\" % (1)cursor.execute(first_sql)first_sql_data = cursor.fetchall();db.commit()if len(first_sql_data) != 0: mark_url = first_sql_data[0] mark_url = mark_url[0] print(mark_url)else: mark_url = \"xxx\" # 目标数据标志url 根据mark_url判断进行循环插入还是更新mark_url然后break for url in urls: if mark_url != url: insert_sql = \"INSERT INTO img(url,date) VALUES ('%s','%s')\" % \\ (url, today) cursor.execute(insert_sql) db.commit() else: update_sql = \"update img set url='%s' , date='%s' where id ='%d'\" % (urls[0], today, 1) cursor.execute(update_sql) db.commit() break; db.close() 爬取信息代码简单不用贴，简单思路为： http：requests.get进行访问url,获取该网页的内容content = http.text 然后对目标地址进行正则匹配re.findall（正则表达式,content,re.S） Android这方面就可以访问取出自己要的数据，然后进行使用。解析自己包装好的数据，比用其他API里的数据要有成就感的多吧？ 收获服务器基本常识： Get简单搭建接口技巧：Get成就感与幸福感：ヾ(⌒(ノ’ω’)ノ"},{"title":"从一个实例简单学习 RecyclerView 基础应用","date":"2015-11-29T05:40:00.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/从一个实例简单学习RecyclerView.html","permalink":"http://imxie.cc/hide/从一个实例简单学习RecyclerView.html","excerpt":"实例简单学习 RV 。","text":"实例简单学习 RV 。 实例展示 1.1. 实例简介 RcyclerView简述 2.1. 基础代码 2.2. 实例代码 1. 实例展示 1.1. 实例简介 每日对【听力特快】中空中英语教室和CNN学生新闻视频栏目的音频文件下载，同时包括对CNN学生新闻视频的字幕抓取 RecyclerView+CardView进行布局展示 AsyncTask和Jsoup进行异步网络下载音频和字幕抓取 MediaPlay 进行判断本地是否有音频，若有则本地播放，若无则进行预加载播放 AppCompatSeekBar 进度控制 2. RcyclerView 简述2.1. 基础代码 LayoutManager: 管理 RecyclerView 的结构. Adapter: 处理每个 Item 的显示. ItemDecoration: 添加每个 Item 的装饰. ItemAnimator: 负责添加\\移除\\重排序时的动画效果. mRecyclerView = findView(R.id.recyclerView);//设置布局管理器mRecyclerView.setLayoutManager(layout);//设置adaptermRecyclerView.setAdapter(adapter)//设置Item增加、移除动画mRecyclerView.setItemAnimator(new DefaultItemAnimator());//添加分割线mRecyclerView.addItemDecoration(new DividerItemDecoration( getActivity(), DividerItemDecoration.HORIZONTAL_LIST)); 2.2. 实例代码LinearLayoutManager llm = new LinearLayoutManager(MainActivity.this);recyclerView.setLayoutManager(llm);recyclerView.setHasFixedSize(true);recyclerView.setAdapter(adapter);int spacingInPixels = getResources().getDimensionPixelSize(R.dimen.space);recyclerView.addItemDecoration(new SpaceItemDecoration(spacingInPixels)); //设置分割线 布局管理RecyclerView提供这些内置的布局管理器： LinearLayoutManager 显示在垂直或水平滚动列表项。 GridLayoutManager 显示在网格中的项目。 StaggeredGridLayoutManager 显示了交错网格项目。 要创建自定义布局管理器，扩展RecyclerView.LayoutManager类。 自定义分割线 // 分隔间距 继承RecyclerView.ItemDecoration class SpaceItemDecoration extends RecyclerView.ItemDecoration &#123; private int space; public SpaceItemDecoration(int space) &#123; this.space = space; &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123;// super.getItemOffsets(outRect, view, parent, state); if (parent.getChildAdapterPosition(view) != 0) &#123; outRect.top = space; &#125; &#125; &#125; 写好继承自RecyclerView.ItemDecoration的类，即可自定义间隔距离。 int spacingInPixels = getResources().getDimensionPixelSize(R.dimen.space);recyclerView.addItemDecoration(new SpaceItemDecoration(spacingInPixels)); Adapter适配器, 处理RecyclerView的Item事务. public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.InfosViewHolder&gt; &#123; private final String TAG = &quot;RecyclerViewAdapter&quot;; private List&lt;Infos&gt; infos; private Context context; private String[] url = new String[2]; private int progress; public RecyclerViewAdapter(List&lt;Infos&gt; infos, Context context) &#123; this.infos = infos; this.context = context; &#125; @Override public RecyclerViewAdapter.InfosViewHolder onCreateViewHolder(ViewGroup viewGroup, int i) &#123; View v = LayoutInflater.from(context).inflate(R.layout.cardview_item, viewGroup, false); InfosViewHolder nvh = new InfosViewHolder(v); return nvh; &#125; @Override public void onBindViewHolder(final RecyclerViewAdapter.InfosViewHolder personViewHolder, int i) &#123; final int j = i; personViewHolder.news_photo.setImageResource(infos.get(i).getPhotoId()); personViewHolder.news_title.setText(infos.get(i).getTitle()); personViewHolder.news_desc.setText(infos.get(i).getDesc()); url[i] = infos.get(i).getUrl(); //cardView arrowbutton设置点击事件 personViewHolder.cardView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(context, InfosActivity.class); intent.putExtra(&quot;Infos&quot;, infos.get(j)); context.startActivity(intent); Log.d(TAG, &quot;this is &quot; + j); &#125; &#125;); personViewHolder.arrowButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; personViewHolder.arrowButton.startAnimating();// 这里因为viewHolder是final 从第一栏加载 所以最后的数据是最好一栏的数据 解决方案就是将viewHolder需要做事件的控件传入 DownloadTask downloadTask = new DownloadTask(context, infos.get(j).getTitle(), personViewHolder.arrowButton); downloadTask.execute(url[j]); Log.d(TAG, url[j]); &#125; &#125;); 关键方法意义 onCreateViewHolder创建ViewHolder.onBindViewHolder绑定每一项数据. getItemCount返回列表长度. RecyclerView强制使用ViewHolder.//自定义ViewHolder类 进行视图绑定static class InfosViewHolder extends RecyclerView.ViewHolder &#123; @Bind(R.id.cardView) CardView cardView; @Bind(R.id.news_photo) ImageView news_photo; @Bind(R.id.news_title) TextView news_title; @Bind(R.id.news_desc) TextView news_desc; @Bind(R.id.arrow_button) ArrowDownloadButton arrowButton; public InfosViewHolder(final View itemView) &#123; super(itemView); ButterKnife.bind(this, itemView); //设置TextView背景为半透明 news_title.setBackgroundColor(Color.argb(20, 0, 0, 0)); &#125;&#125; 在onCreateViewHolder方法, 创建类; 在onBindViewHolder方法, 绑定数据. 遇到的小问题ViewHolder加载视图的顺序是从第一个Item到最后一个，而且该对象是final类型，故自己最初在DownloadTask exntend AsyncTask&lt;&gt; 该类写 ViewHolder.arrowButton.setProgress 只有最后一个Item才会有下载的动画显示（setProgress生效）,但下载是没有问题的。 解决方案则是将该Button在new DownloadTask的时候传入。 问题解决。 数据更新RecyclerView的更新自己目前用到的还是adapter.notifyDataSetChanged 新手Tips implements Serializable 的范类才可以进行Intent传送 Intent intent = getIntent();Infos item = (Infos) intent.getSerializableExtra(&quot;Infos&quot;); 理解ViewHolder的加载模式 Handler灵活应用"},{"title":"从零到“就看天气”上线","date":"2015-11-13T09:37:31.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/就看天气介绍.html","permalink":"http://imxie.cc/hide/就看天气介绍.html","excerpt":"想借自己这款“就看天气”说说自己接近半年来的Android开发之路，也算是自己这段时间的学习总结和知识沉淀。 自己是重庆某高校大三学生，软件工程学院。在学校大一的时候学习的是C艹（当然这个特别难懂的语言着实打击了我一阵子，所以没有学好） 大二在学校学了Java。在Java学习过程中，比大一时候要轻松很多，就我个人而言，认为学习Java比C艹要轻松，然而还是不明白学校为什么还是要把C艹的学习放在大一。 决定学习Android是自己很早的想法了，但是真正落实去做是放在了大二暑假。","text":"想借自己这款“就看天气”说说自己接近半年来的Android开发之路，也算是自己这段时间的学习总结和知识沉淀。 自己是重庆某高校大三学生，软件工程学院。在学校大一的时候学习的是C艹（当然这个特别难懂的语言着实打击了我一阵子，所以没有学好） 大二在学校学了Java。在Java学习过程中，比大一时候要轻松很多，就我个人而言，认为学习Java比C艹要轻松，然而还是不明白学校为什么还是要把C艹的学习放在大一。 决定学习Android是自己很早的想法了，但是真正落实去做是放在了大二暑假。 这之前自己做了如下准备： 一台配置不错的台式（SSD+8G内存） Java基础知识 极客学院Vip账号（非广告，当然你还有其他选择，比如慕课网的视频也不错） 《第一行代码》 一个好的电脑确实是必需品，现在写Android应该都开始用Android Studio了吧，这个IDE配上SDD+8G内存你才能优雅的写代码。 Android学习之前真的要把Java基础学好，这样你学Android的时候才不会特别痛苦。掌握基础之后再学Android，还可以边学习Android边复习Java，一举两得。 现在很多网上的视频教程，我个人最开始是跟着极客学院视频走的，而且还加上翻《第一行代码》这本书。虽然这本书是用的Eclipse，但是你用AS重写是完全没有问题的。 实战只有在实际操作中你才能知道自己哪些方面的知识欠缺，才会知道开发过程中会遇到哪些恶心的BUG，才会主动的去思考，搜索方案去解决这个问题。而且在自己实践中，也获得了很多开发应用的乐趣。而自己特别喜欢这种创造带给自己的快乐，也是这样才让我喜欢去敲代码吧。每个天气类应用逻辑就是特别简单，但是这个小应用也能让你明白很多Android的知识。整理了下自己开发这款的思路： 获取省会列表自己获取省会城市列表是应用本地数据库，该数据库里包含了省——市——乡三级，Android里用SQLite进行数据库处理操作，最后用ListView显示出来。这里会学到的知识就是：SQLite，Cursor，简单的ListView+Adapter。 获取天气信息这里获取天气信息是从获取到用户要查什么城市名称后跟地址组合发送给“和风天气”API，它会返回给我一个JSON数据。这里会学到的知识是：Android的网络通信。这里我自己用的是android-async-http库。 处理天气信息获取到返回的JSON数据后，需要对这个JSON进行解析，这里我用的是Gson这个库，并且用SharedPreferences进行保存。这里会学到的知识是：Json数据的处理，SharedPreference常用库的应用。 更新UI从SharedPreference获取指定数据，并实现UI更新。这里会学到的知识是：对Android线程的理解。 应用就看天气—个人向天气类应用断断续续写了2个月实战+资料+看书+整理 这样的自我学习模式很有效果已经在豌豆荚，魅族应用，酷安等平台上线 希望你们喜欢而且能够做出自己喜欢的应用（＾∀＾） 图 这货晚上，长这个样子的 (/“≡ _ ≡)/~┴┴"},{"title":"获取一个有JS加载的网页信息","date":"2015-12-26T12:02:24.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/获取一个有JS加载的网页信息.html","permalink":"http://imxie.cc/hide/获取一个有JS加载的网页信息.html","excerpt":"现在很多网页内容是通过JS加载出来的，而不是静态不变的。本文以网易摄影为例子分 Java 和 Python 两种语言爬取图片信息。","text":"现在很多网页内容是通过JS加载出来的，而不是静态不变的。本文以网易摄影为例子分 Java 和 Python 两种语言爬取图片信息。 JavaJava 找了很久找到了 Htmlunit 网络请求库，主要的特点就是模拟浏览器运行。 //初始化WebClient wc = new WebClient(BrowserVersion.CHROME); 浏览器种类可更改。 //相关配置。wc.getOptions().setUseInsecureSSL(true);wc.getOptions().setJavaScriptEnabled(true); // 启用JS解释器，默认为truewc.getOptions().setCssEnabled(false); // 禁用css支持wc.getOptions().setThrowExceptionOnScriptError(false); // js运行错误时，是否抛出异常wc.getOptions().setTimeout(100000); // 设置连接超时时间 ，这里是10S。如果为0，则无限期wc.getOptions().setDoNotTrackEnabled(false);wc.getOptions().setThrowExceptionOnFailingStatusCode(false); HtmlPage page = wc.getPage(&quot;http://pp.163.com/pp/#p=10&amp;c=-1&amp;m=3&amp;page=1&quot;);// 该方法在getPage()方法之后调用才能生效wc.waitForBackgroundJavaScript(1000 * 3); 等待网页JS代码运行后我们才能得到我们需要的数据。 /*** &lt;div class=\"pic\"&gt; &lt;a class=\"img js-anchor etag noul\" hidefocus=\"true\"* target=\"_blank\" href=\"http://pp.163.com/oneness/pp/16356042.html\"* title=\"登登与小猫笨笨 \"&gt;*///div[@class=\"pic\"]/a/@hrefList&lt;DomAttr&gt; links = (List&lt;DomAttr&gt;)page.getByXPath(\"//div[@class=\\\"pic\\\"]/a/@href\"); 我这里用得是 XPath 进行匹配数据。看下简单的实例，就蛮容易上手的。得到之后，剩下的事情就很简单了。 但是 Htmlunit 进行爬取成功率会有问题，偶尔会有一两次访问不到，不过我暂时没有在 Java 里找到更好的解决方案。 PythonPython 写这个代码有点早，是用的 Spynner 库，是一个操控一个无 GUI 的 Webkit 核心实现 http访 问的 Python 模块，用来爬使用 js 运行才有结果的网页最好。 //初始化browser = spynner.Browser()browser.create_webview() 然后调用browser.load(url=url, tries=5)browser.load_jquery(True)content = browser.html.encode(\"utf-8\") 这样 JS 运行后的页面就可以获取到了，通过 bs4 或者 re 正则都可以获取想要的东西。 最后还是放一张图："},{"title":"“一个”爬取自动邮件功能","date":"2015-11-14T08:48:45.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/跑在服务器上爬取一个的py.html","permalink":"http://imxie.cc/hide/跑在服务器上爬取一个的py.html","excerpt":"“一个”爬取自动邮件功能","text":"“一个”爬取自动邮件功能 准备 一台云服务器 写好的 Python 脚本 效果因为现在“一个”的 Android 客户端启动越来越慢，而且很多自己不感兴趣的东西（我只是想看看文章），所以就写了这个小爬虫。它可以在“一个”更新后把我要的内容发到我的邮箱里。放在云服务器里，所以不用担心电费啊其他问题~ 实践云服务器自己配置的是阿里云的服务器，学生特惠9.9，Ubuntu 系统。这个系统自带了 Python2.7 环境，所以不用自己手动去安装。本地是用的 Window10 系统，最好安装下SecureCRSecureFXPortable。远程连接自己的服务器，而且命令行和文件操作会简便很多。因为“一个”是每天22点会更新，所以自己的服务器要做一个定时服务，ubuntu下 自带了Crontab定时任务。 配置Crontab1.加入需要执行的脚本crontab -e* * * * * 路径/python 路径/xxx.py保存重启 /etc/init.d/cron restart 2.Python 最好写全路径，这是一个坑3.需要在 root 用户下进行4.具体的 Crontab 可以参考Crontab Python代码这里主要是用到了 Python 自带的邮件服务的库和第三方网络解析库，代码量不多而且也不难，有编程基础的很容易学会。 邮件相关邮件类库from email.mime.multipart import MIMEMultipartfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.utils import parseaddr, formataddrimport smtplib 配置邮件&amp;发送邮件的关键代码 msg = MIMEMultipart()msg['From'] = _format_addr(u'Xie CC &lt;%s&gt;' % from_addr)msg['To'] = _format_addr(u'管理员 &lt;%s&gt;' % to_addr)msg['Subject'] = Header(u'The One ' + title, 'utf-8').encode()msg.attach(MIMEText('&lt;html&gt;&lt;body&gt;&lt;div style=\"text-align: center;\"&gt;&lt;p&gt;&lt;img src=\"' + img + '\"&gt;&lt;/p&gt;&lt;/div&gt;' + '&lt;p style=\"text-align:center;\\\"&gt; &lt;br /&gt;&lt;br /&gt;&lt;strong&gt;&lt;span style=\"font-size:14px;\\\"&gt;' + text + '&lt;/span&gt;&lt;/p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;' + story + '&lt;/body&gt;&lt;/html&gt;', 'html', 'utf-8'))server = smtplib.SMTP(smtp_server, 25)server.set_debuglevel(1)server.login(from_addr, password)server.sendmail(from_addr, [to_addr], msg.as_string())server.quit() 这里自己就不详细介绍这个库，具体可以参考这个教程，Python 不是很难理解. 爬取信息类库import requestsfrom bs4 import BeautifulSoup 有一次用 urllib，urllib2 发现会遇到各种编码问题需要自己去解决，特别烦人。然后转到了 requests 这个库，完全没有遇到像 urllib 那样恶心的编码问题，而且很多需求都可以满足，所以后面爬静态网页都习惯用这个库了。以前还是蛮喜欢用正则的，这次就学习了下 bs4 的用法，感觉还是挺容易上手的。具体的实现都不难，都是基础的爬虫知识，而且“一个”并没有反爬虫的设定，所以蛮适合初学者的。 用工具方便自己，我觉得这就是自己编程的意义，这让我很开心。"},{"title":"Java 基础 —— 多线程（读书笔记）「三」","date":"2016-09-29T08:02:31.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"wait/Review-Java-Thread-3.html","permalink":"http://imxie.cc/wait/Review-Java-Thread-3.html","excerpt":"前面两章已经了解了很多线程相关的知识，但是当我们需要频繁地创建多个线程进行耗时操作时，每次通过 new Thread 并不是很好的实现方式。 新建和销毁对象性能较差 线程缺乏统一管理 可能无限制新建线程，相互竞争，死锁 缺少定时执行，定期执行，线程中断等等","text":"前面两章已经了解了很多线程相关的知识，但是当我们需要频繁地创建多个线程进行耗时操作时，每次通过 new Thread 并不是很好的实现方式。 新建和销毁对象性能较差 线程缺乏统一管理 可能无限制新建线程，相互竞争，死锁 缺少定时执行，定期执行，线程中断等等 目录 目录 简介 使用 ThreadPoolExecutor 构造函数 WorkQueue RejectedExecutionHandler 简介线程池简单来说：创建多个线程并且进行管理，提交给线程的任务会被线程池指派给其中的线程执行，通过线程池的统一调度，管理使得多线程的使用更简单，高效。 大致流程图： 线程池都实现了 ExecutorService 接口，它的实现有 ThreadPoolExecutor 和 ScheduledExecutorService 。ThreadPoolExecutor 也就是我们运用最多的线程池实现，而 ScheduledExecutorService 通过名字我们就可以知道用于周期性地执行任务。 通常我们都不会使用 new 的形式来创建线程池，而使用 JDK 给我们封装好了的 Executors 工厂类来简化这个过程。 使用ThreadPoolExecutorThreadPoolExecutor 是线程池的实现之一，它的功能是启动指定数量的线程以及将任务添加到一个队列中，并且将任务分发给空闲线程。 ExecutorService 的生命周期包括三种状态：运行，关闭，终止。创建后便进入运行状态，当调用了 shutdown() 方法时，便进入关闭状态，此时意味着 ExecutorService 不再接受新的任务，但它还在执行已经提交了的任务。当所有已经提交的任务执行完毕后，就变成终止状态。 做了一个图，直观的展示了状态的转换： 构造函数public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 我们主要对构造函数的参数进行简要说明： corePoolSize 线程池中所保存的核心线程数。 maximumPoolSize 线程池允许创建的最大线程数。 keepAliveTime 当前线程池线程总数大于核心线程数时，终止多余的空闲线程的时间。 Unit keepAliveTime 参数的时间单位，可选值有毫秒，秒，分等。 workQueue 任务队列，如果当前线程池达到核心线程数 corePoolSize ，且当前线程都处于活动状态时，则将新加入的任务放到此队列。 threadFactory 线程工厂，让用户可以定制线程的创建过程，通常不需要设置。 RejectedExecutionHandler 拒绝策略，当线程池与 workQueue 队列都满了的情况下，对新加任务采取的处理策略。 WorkQueue其中 workQueue 有下列几个常用的实现： ArrayBlockingQueue： 基于数组结构的有界队列，此队列按 FIFO 原则对任务进行排序。如果队列满了还有任务进来，则调用拒绝策略。 LinkedBlockingQueue：基于链表结构的无界队列，此队列按 FIFO 原则对任务进行排序。因为它是无界的，根本不会满，所以采用此队列后线程池将忽略拒绝策略 (handler) 参数；同时还将忽略最大线程数 maximumPoolSize 。 SynchronousQueue：直接将任务提交给线程而不是将它加入到队列，实际上此队列是空的。每个插入的操作必须等到另一个调用移除的操作；如果新任务来了线程池没有任何可用线程处理的话，则调用拒绝策略。 PriorityBlockingQueue：具有优先级基于数组结构的有界队列，可以自定义优先级，默认是按照自然排序。 RejectedExecutionHandler当线程池与 workQueue 队列都满了的情况下，对新加任务采取的处理策略也有几个默认实现： AbortPolicy：拒绝任务，抛出 RejectedExecutionException 异常。线程池默认策略。 CallerRunsPolicy：拒绝新任务进入，如果该线程池还没有被关闭，那么将这个新任务执行在调用线程中。 DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序。 DiscardPolicy： 加不进的任务都被抛弃了，同时没有异常抛出。 实践Executors 可以构建几种常见的线程池，我们通过实例对比来加深对他们的印象。 newCachedThreadPool 当线程池中的线程空闲时间超过 60s 则会自动回收该线程，当任务超过线程池的线程数则创建新线程。线程池的大小上限为 Integer.MAX_VALUE，可看做是无限大。 public class ThreadPoolTest &#123; public static void main(String[] args) &#123; cachedThreadPoolRun(); &#125; private static void produceTasks(ExecutorService service) &#123; for (int i = 0; i &lt; 10; i++) &#123; final int finalI = i; service.submit(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"This Thread is: \" + Thread.currentThread().getName() + \" &gt;&gt;&gt; Task:\" + finalI); &#125; &#125;); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static void cachedThreadPoolRun() &#123; ExecutorService service = Executors.newCachedThreadPool(); produceTasks(service); service.shutdown(); &#125;&#125; 运行后控制台输出： This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:0This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:1This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:2This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:3This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:4This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:5This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:6This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:7This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:8This Thread is: pool-1-thread-1 &gt;&gt;&gt; Task:9 从结果可以看出，整个过程都在 pool-1-thread-1 中执行，后续任务一直在复用之前线程。 newFixedThreadPool 总结和参考 ThreadPoolExecutor 源码学习笔记 Java 线程池分析"},{"title":"写点脚本方便开发和工作吧","date":"2016-11-08T15:23:28.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"wait/To-write-some-script-to-work-efficiently.html","permalink":"http://imxie.cc/wait/To-write-some-script-to-work-efficiently.html","excerpt":"这里放着的都是自己平时开发过程中觉得很实用的脚本代码。一直重复操作做一些事情，有点繁琐的对吧。","text":"这里放着的都是自己平时开发过程中觉得很实用的脚本代码。一直重复操作做一些事情，有点繁琐的对吧。 Python批量安装 Debug Apk# encoding: utf-8import osdef extract_lines(content): \"\"\" Extract lines from terminal response. \"\"\" return content.strip().split('\\n')[1:]def extract_id(line): \"\"\" Extract device id from line \"\"\" return line.split('\\t')[0].strip()def install(device_id): \"\"\" Execute adb tasks \"\"\" os.system('adb -s ' + device_id + ' install -r app/build/outputs/apk/app-debug.apk') os.system('adb -s '+ device_id +' shell am start -n \"com.ruguoapp.jike/com.ruguoapp.jike.business.main.ui.SplashActivity\" -a android.intent.action.MAIN -c android.intent.category.LAUNCHER')map(install, map(extract_id, extract_lines(os.popen('adb devices').read()))) Bash"},{"title":"Java 基础 —— 多线程（读书笔记）「一」","date":"2016-09-21T14:51:32.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/Review-Java-Thread-1.html","permalink":"http://imxie.cc/hide/Review-Java-Thread-1.html","excerpt":"多线程对于 Android 开发者来说是基础。而且这类知识在计算机里也是很重要的一环，所以很有必要整理一番。","text":"多线程对于 Android 开发者来说是基础。而且这类知识在计算机里也是很重要的一环，所以很有必要整理一番。 文章来源：itsCoder 的 WeeklyBolg 项目 itsCoder主页：http://itscoder.com/ 作者：谢三弟 审阅者：Jaeger 目录 目录 多线程的实现 Thread 源码 线程的几个重要的函数 Wait() 的实践 Join() 的实践 Yield() 的实践 总结与参考 多线程的实现来上代码： // 最常见的两种方法启动新的线程public static void startThread() &#123; // 覆盖 run 方法 new Thread() &#123; @Override public void run() &#123; // 耗时操作 &#125; &#125;.start(); // 传入 Runnable 对象 new Thread(new Runnable() &#123; public void run() &#123; // 耗时操作 &#125; &#125;).start();&#125; 其实第一个就是在 Thread 里覆写了 run() 函数，第二个是给 Thread 传了一个 Runnable 对象，在 Runnable 对象 run() 方法里进行耗时操作。以前没有怎么考虑过他们两者的关系，今天我们来具体看看到底是什么鬼？ Thread 源码进入 Thread 源码我们看看： public class Thread implements Runnable &#123; /* What will be run. */ private Runnable target; /* The group of this thread */ private ThreadGroup group; public Thread() &#123; init(null, null, \"Thread-\" + nextThreadNum(), 0); &#125; public Thread(Runnable target) &#123; init(null, target, \"Thread-\" + nextThreadNum(), 0); &#125;&#125; 源码很长，我进行了一点分割。一点一点的来解析看看。我们首先知道 Thread 也是一个 Runnable ，它实现了 Runnable 接口，并且在 Thread 类中有一个 Runnable 类型的 target 对象。 构造方法里我们都会调用 init() 方法，接下来看看在该方法里做了如何的初始化配置。 private void init(ThreadGroup g, Runnable target, String name, long stackSize) &#123; init(g, target, name, stackSize, null); &#125; private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc) &#123; Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); // group 参数如果为 null ，则获得当前线程的 group（线程组） if (g == null) &#123; g = parent.getThreadGroup(); &#125; // 代码省略 this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); // 设置 target（ Runnable 类型 ） this.target = target; &#125; public synchronized void start() &#123; // 将当前线程加入线程组 group.add(this); boolean started = false; try &#123; // 启动 native 方法启动新的线程 start0(); started = true; &#125; finally &#123; // 代码省略 &#125; private native void start0(); @Override public void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 从上我们可以明白，最终被线程执行的任务是 Runnable ，Thread 只是对 Runnable 的一个包装，并且通过一些状态对 Thread 进行管理和调度。当启动一个线程时，如果 Thread 的 target 不为空，则会在子线程中执行这个 target 的 run() 函数，否则虚拟机就会执行该线程自身的 run() 函数。 线程的几个重要的函数 wait() 当一个线程执行到 wait() 方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁，使得其他线程可以访问。用户可以使用 notify 、notifyAll 或者指定睡眠时间来唤醒当前等待池中的线程。 注意：wait() notify() notifyAll() 必须放在 synchronized block 中，否则会抛出异常。 sleep() 该函数是 Thread 的静态函数，作用是使调用线程进入睡眠状态。因为 sleep() 是 Thread 类的静态方法，因此他不能改变对象的机锁。所以，当在一个 synchronized 块中调用 sleep() 方法时，线程虽然休眠了，但是对象的机锁并没有被释放，其他线程无法访问这个对象。 join() 等待目标线程执行完成之后继续执行。 yield() 线程礼让。目前线程由运行状态转换为就绪状态，也就是让出执行权限，让其他线程得以优先执行，但其他线程能否优先执行未知。 在源码中，查看 Thread 里的 State ，对几种状态解释的很清楚。 NEW 状态是指线程刚创建，尚未启动 RUNNABLE 状态是线程正在正常运行中，当然可能会有某种耗时计算 / IO 等待的操作 / CPU 时间片切换等, 这个状态下发生的等待一般是其他系统资源, 而不是锁, Sleep 等 BLOCKED 这个状态下，是在多个线程有同步操作的场景, 比如正在等待另一个线程的 synchronized 块的执行释放，或者可重入的 synchronized 块里别人调用 wait() 方法，也就是这时线程在等待进入临界区 WAITING 这个状态下是指线程拥有了某个锁之后，调用了他的 wait 方法，等待其他线程 / 锁拥有者调用 notify / notifyAll 一遍该线程可以继续下一步操作，这里要区分 BLOCKED 和 WATING ，一个是在临界点外面等待进入， 一个是在临界点里面 wait 等待别人 notify ， 线程调用了 join 方法 进入另外的线程的时候, 也会进入 WAITING 状态，等待被他 join 的线程执行结束 TIMED_WAITING 这个状态就是有限的 (时间限制) 的 WAITING， 一般出现在调用 wait(long), join(long) 等情况下，另外，一个线程 sleep 后, 也会进入 TIMED_WAITING 状态 TERMINATED 这个状态下表示 该线程的 run 方法已经执行完毕了, 基本上就等于死亡了 (当时如果线程被持久持有, 可能不会被回收) Wait() 的实践我们来看一段，wait() 的用途和效果。static void waitAndNotifyAll() &#123; System.out.println(\"主线程运行\"); Thread thread = new WaitThread(); thread.start(); long startTime = System.currentTimeMillis(); try &#123; synchronized (sLockOject) &#123; System.out.println(\"主线程等待\"); sLockOject.wait(); &#125; &#125; catch (Exception e) &#123; &#125; long timeMs = System.currentTimeMillis() - startTime; System.out.println(\"主线程继续 —-&gt; 等待耗时：\" + timeMs + \" ms\");&#125;static class WaitThread extends Thread &#123; @Override public void run() &#123; try &#123; synchronized (sLockOject) &#123; System.out.println(\"进入子线程\"); Thread.sleep(3000); System.out.println(\"唤醒主线程\"); sLockOject.notifyAll(); &#125; &#125; catch (Exception e) &#123; &#125; &#125;&#125; 在 waitAndNotifyAll() 函数里，会启动一个 WaitThread 线程，在该线程中将会调用 sleep 函数睡眠 3 秒。线程启动之后在主线程调用 sLockOject 的 wait() 函数，使主线程进入等待状态，此时将不会继续执行。等 WaitThread 在 run() 函数沉睡了 3 秒后会调用 sLockOject 的 notifyAll() 函数，此时就会重新唤醒正在等待中的主线程，因此会继续往下执行。 结果如下： 主线程运行主线程等待进入子线程唤醒主线程主线程继续 —-&gt; 等待耗时：3005 ms wait()、notify() 机制通常用于等待机制的实现，当条件未满足时调用 wait 进入等待状态，一旦条件满足，调用 notify 或 notifyAll 唤醒等待的线程继续执行。 对于这里细节可能会有一些疑问。在子线程启动的时候，run() 函数里面已经持有了该对象锁。但是真实环境下，其实是主线程先持有对象锁，然后调用 wait() 进入等待区并且释放锁等待唤醒。 这个问题涉及到 JNI 代码，目前我只能从理论上来解释这个问题。我们都知道一个线程 start() 并不是马上启动，而是需要 CPU 分配资源的，根据目前运行来看，分配资源的时间大于 Java 虚拟机运行指令的时间，所以主线程比子线程先拿到锁。我们还可以知道一点，控制台打印出的时间是 3005 ms ，在代码里我们只等待了 3s 多出来的 5ms （这个数字会浮动）我们可以推断是，子线程获取 CPU 的时间加上唤醒主线程的时间。 上述只是自己的一个猜测，能力还有欠缺，准备深入学习。 不过推荐大家看看这篇文章 Synchnornized 在 JVM 下的实现 - 简书。 Join() 的实践join() 的注释上面写着： Waits for this thread to die. 意思是，阻塞当前调用 join() 函数所在的线程，直到接收线程执行完毕之后再继续。我们来看看实践代码： public class JoinThread &#123; public static void main(String[] args) &#123; joinDemo(); &#125; public static void joinDemo() &#123; Worker worker1 = new Worker(\"work-1\"); Worker worker2 = new Worker(\"work-2\"); worker1.start(); System.out.println(\"启动线程 1 \"); try &#123; // 调用 worker1 的 join 函数，主线，程会阻塞直到 woker1 执行完成 worker1.join(); System.out.println(\"启动线程 2\"); // 再启动线程 2 ，并且调用线程 2 的 join 函数，主线程会阻塞直到 woker2 执行完成 worker2.start(); worker2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"主线程继续执行\"); &#125; static class Worker extends Thread &#123; public Worker(String name) &#123; super(name); &#125; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"work in \" + getName()); &#125; &#125;&#125; 运行之后我们得到： 启动线程 1work in work-1启动线程 2work in work-2主线程继续执行 在 joinDemo() 方法里我们创建两个子线程，然后启动了 work1 线程，下一步调用了 woker1 的 join() 函数。此时，主线程会进入阻塞状态，直到 work1 执行完毕之后才开始继续执行。因为 Worker 的 run() 方法里会休眠 2 秒，因此线程每次调用了 join() 方法实际上都会阻塞 2 秒，直到 run() 方法执行完毕再继续。所以，上述代码逻辑其实就是： 启动线程1 —-&gt; 等待线程 1 执行完毕 —-&gt; 启动线程2 —-&gt; 等待线程 2 执行完毕 —-&gt; 继续执行主线程代码 Yield() 的实践yield() 是 Thread 的静态方法，注释上说： A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint. 大致意思是说：当前线程让出执行时间给其他的线程。我们都知道，线程的执行是有时间片的，每个线程轮流占用 CPU 固定时间，执行周期到了之后让出执行权给其他线程。yield() 就是主动让出执行权给其他线程。 来看看我们实践的代码：public class YieldThreadTest &#123; public static void main(String[] args) &#123; YieldTread t1 = new YieldTread(\"thread-1\"); YieldTread t2 = new YieldTread(\"thread-2\"); t1.start(); t2.start(); &#125; public static class YieldTread extends Thread &#123; public YieldTread(String name) &#123; super(name); &#125; public synchronized void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.printf(\"%s 优先级为 [%d] -------&gt; %d\\n\", this.getName(), this.getPriority(), i); // 当 i 为 2 时，调用当前线程的 yield 函数 if (i == 2) &#123; Thread.yield(); &#125; &#125; &#125; &#125;&#125; 在 main() 方法里创建了两个 YieldTread 线程，控制台输出结果如下： thread-1 优先级为 [5] ——-&gt; 0thread-1 优先级为 [5] ——-&gt; 1thread-1 优先级为 [5] ——-&gt; 2 thread-2 优先级为 [5] ——-&gt; 0thread-2 优先级为 [5] ——-&gt; 1thread-2 优先级为 [5] ——-&gt; 2 thread-1 优先级为 [5] ——-&gt; 3thread-1 优先级为 [5] ——-&gt; 4thread-2 优先级为 [5] ——-&gt; 3thread-2 优先级为 [5] ——-&gt; 4 通常情况下 t1 首先执行，让 t1 的 run() 函数执行到了 i 等于 2 时让出当前线程的执行时间。所以我们看到前三行都是 t1 在执行，让出执行时间后 t2 开始执行。后面逻辑简单思考下就得知了，这里也不做过多诠释。 因此，调用 yield() 就是让出当前线程的执行权，这样一来让其他线程得到优先执行。 总结与参考本章内容属于线程的基础，本系列会更新到线程池相关。这章内容也及其重要，因为它是后面的基础。正确理解才能让我们对各种线程问题有方向和思路。 参考读物： Android 开发进阶 — 从小工到专家 我是一个线程"},{"title":"Java 基础复习实践 --- Hashcode Equals","date":"2016-07-18T06:14:31.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/Review-the-Java-basic-equals-hashcode.html","permalink":"http://imxie.cc/hide/Review-the-Java-basic-equals-hashcode.html","excerpt":"虽然很多知识点书籍都有整理，但是记性总是不好，所以决定将一些细小容易混淆的概念，通过简单的 Demo 实践，加深复习。特此开一个坑，坚持就是胜利。 本章内容主要为了理解以下几个知识点： equals() 的作用是什么？ equals() 与 “==”的区别是什么？ hashcode() 的作用是什么？ hashcode() 与 equals（）之间有什么联系？","text":"虽然很多知识点书籍都有整理，但是记性总是不好，所以决定将一些细小容易混淆的概念，通过简单的 Demo 实践，加深复习。特此开一个坑，坚持就是胜利。 本章内容主要为了理解以下几个知识点： equals() 的作用是什么？ equals() 与 “==”的区别是什么？ hashcode() 的作用是什么？ hashcode() 与 equals（）之间有什么联系？ 目录 目录 0x01 equals() 的作用 没有覆盖 equals() 方法 覆盖 equals() 方法 Tips 0x02 equals() 与 == 的区别 0x03 hashcode() 的作用 0x04 hashCode() 和 equals() 的关系 参考文档 0x01 equals() 的作用 Indicates whether some other object is “equal to” this one. equals()是用来 判断两个对象是否相等。 equals() 定义在 JDK 的 Object.java 中。通过判断两个对象的地址是否相等(即，是否是同一个对象)来区分它们是否相等。源码如下： public boolean equals(Object obj) &#123; return (this == obj);&#125; 既然是在 Object 类中定义了该方法，就表明了 Java 所有类都实现了 equals() 方法，所以所有类都可以通过该方法去判断两个对象是否相等。默认的 equals（） 方法等同于 ”==” 方法，所以我们一般会重写 equals（） 方法 —-&gt; 两个对象的内容相等，返回 true ，否则返回 false。 所以我们可以根据是否 重写 equals() 方法将类分为两类： 1.若某个类没有覆盖 equals() 方法，当它的通过 equals() 比较两个对象时，实际上是比较两个对象是不是同一个对象。这时，等价于通过“==”去比较这两个对象 2.覆盖类的 equals() 方法，来让 equals() 通过其它方式比较两个对象是否相等。通常的做法是：若两个对象的内容相等，则 equals()方法返回true；否则，返回 false 。 没有覆盖 equals() 方法public class HashcodeAndEquals &#123; private static &lt;T&gt; void out(T t) &#123; System.out.println(t); &#125; public static void main(String[] args) &#123; // 实例化两个 Person 对象 Person p1 = new Person(\"小明\", 12); Person p2 = new Person(\"小明\", 12); // 通过 equals() 比较他们是否相等 out(p1.equals(p2)); &#125; private static class Person &#123; int age; String name; public Person(String name, int age) &#123; this.age = age; this.name = name; &#125; @Override public String toString() &#123; return name + \"--- age:\" + age; &#125; &#125;&#125; 输出为false 结论： 当我们使用 p1.equals(p2) 来比较 p1 和 p2 是否相等时，实际上是调用了 object 类的 equals() 方法，即 “p1==p2”，它是比较 p1 和 p2 是否为一个对象。由定义可知，p1 和 p2 虽然内容相同，但是它们是两个不同的对象。因此，返回 false 。 覆盖 equals() 方法我们简单修改下 HashcodeAndEquals.java 文件，覆盖 equals() 方法： public class HashcodeAndEquals &#123; private static &lt;T&gt; void out(T t) &#123; System.out.println(t); &#125; public static void main(String[] args) &#123; // 实例化两个 Person 对象 Person p1 = new Person(\"小明\", 12); Person p2 = new Person(\"小明\", 12); // 通过 equals() 比较他们是否相等 out(p1.equals(p2)); &#125; private static class Person &#123; int age; String name; public Person(String name, int age) &#123; this.age = age; this.name = name; &#125; @Override public String toString() &#123; return name + \"--- age:\" + age; &#125; @Override public boolean equals(Object obj) &#123; if (obj == null) &#123; return false; &#125; // 如果是同一对象，返回 true if (this == obj) &#123; return true; &#125; // 判断是否类型相同 if (this.getClass() != obj.getClass()) &#123; return false; &#125; // 只有一下三种情况才能通过编译 // 1.instanceof前面的类型与后面的类型相同 // 2.instanceof前面的类型是后面的类型父类 // 3.instanceof前面的类型是后面的类型子类 // 故与我们判断类型相同有一点偏差 // // 这一点我们可以自己定义一个 Student 类继承 Person 类来进行实验 // if (!(obj instanceof Person)) &#123; // return false; // &#125; Person per = (Person) obj; return name.equals(per.name) &amp;&amp; age == per.age; &#125; &#125;&#125; 输出为true 结论： 我们在新的 HashcodeAndEquals.java 文件中重写了 Person 类的 equals() 函数：当两个 Person 对象 name 和 age 都相等时，则返回 true ，因此结果为 true 。 Tips Java 对 equals() 的要求 对称性：如果 x.equals(y) 返回是” true “，那么 y.equals(x) 也应该返回是”true”。 反射性：x.equals(x) 必须返回是 “true” 。 类推性：如果 x.equals(y) 返回是”true”，而且 y.equals(z) 返回是”true”，那么 z.equals(x) 也应该返回是”true”。 一致性：如果 x.equals(y) 返回是”true”，只要x和y内容一直不变，不管你重复 x.equals(y) 多少次，返回都是”true”。 非空性，x.equals(null)，永远返回是”false”；x.equals (和x不同类型的对象)永远返回是”false”。 0x02 equals() 与 == 的区别equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况(前面第1部分已详细介绍过) == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是否为同一个对象。 只用修改下HashcodeAndEquals.java 主函数为：public static void main(String[] args) &#123; // 实例化两个 Person 对象 Person p1 = new Person(\"小明\", 12); Person p2 = new Person(\"小明\", 12); // 分别用 equals() 和 == 来判断 out(\"equals: \" + p1.equals(p2)); out(\"==: \" + (p1 == p2));&#125; 输出为：equals: true==: false 结果与我们预想的一样，因为我们是复写了 Person 类的 equals() 方法，而且 p1 p2 内容相同所以返回 true ，而 p1 p2 并是两个不同对象，所以 == 判断它们地址不相同，返回 false。 0x03 hashcode() 的作用hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。 hashCode() 定义在 JDK 的 Object.java 中，这就意味着Java中的任何类都包含有 hashCode() 函数。 虽然，每个 Java 类都包含 hashCode() 函数。但是，仅仅当创建并某个“类的散列表”(关于“散列表”见下面说明)时，该类的 hashCode() 才有用(作用是：确定该类的每一个对象在散列表中的位置；其它情况下(例如，创建类的单个对象，或者创建类的对象数组等等)，类的 hashCode() 没有作用。 上面的散列表，指的是：Java集合中本质是散列表的类，如HashMap，Hashtable，HashSet。也就是说：hashCode() 在散列表中才有用，在其它情况下没用。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。 散列码的解释： 我们都知道，散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！散列表的本质是通过数组实现的。当我们要获取散列表中的某个“值”时，实际上是要获取数组中的某个位置的元素。而数组的位置，就是通过“键”来获取的；更进一步说，数组的位置，是通过“键”对应的散列码计算得到的。 我们以 Hashset 为例来说明下 hashcode() 的作用：首先我们都知道 HashSet 是 Set 的集合，不允许有重复的元素。当该 Set 已经有了 1000 个元素时，当插入第1001个元素时，需要怎么处理？ “将第1001个元素逐个的和前面1000个元素进行比较”？显然，这个效率是相等低下的。散列表很好的解决了这个问题，它根据元素的散列码计算出元素在散列表中的位置，然后将元素插入该位置即可。对于相同的元素，自然是只保存了一个。由此可知，若两个元素相等，它们的散列码一定相等；但反过来确不一定。在散列表中， 如果两个对象相等，那么它们的hashCode()值一定要相同； 如果两个对象hashCode()相等，它们并不一定相等。注意：这是在散列表中的情况。在非散列表中一定如此！ 0x04 hashCode() 和 equals() 的关系我们修改主函数为：public static void main(String[] args) &#123; Person p1 = new Person(\"小明\", 12); // HashMap HashMap&lt;Person, Integer&gt; map = new HashMap&lt;&gt;(); map.put(p1, 1); out(map.get(new Person(\"小明\", 12)));&#125; 按照理想中，我们输出的结果应该为 “1”，因为我们存入的 Person 和查找的 Person 都是“小明”，是同一个人。但是最终运行该程序输出结果为： null 所以按照设计标准我们应该在重写 equals() 方法的同时也要写重写 hashcode()。 虽然通过重写equals方法使得逻辑上姓名和年龄相同的两个对象被判定为相等的对象（跟String类类似），但是要知道默认情况下，hashCode 方法是将对象的存储地址进行映射。那么上述代码的输出结果为“null”就不足为奇了。 因为 p1 对象和 new Person(&quot;小明&quot;, 12) 生成的对象是两个不同的对象，它们的存储地址肯定不同，所以得到的 hashcode 值不同（不绝对，因为有哈希冲突的情况）。 所以现在重写下我们的 Person 类的 hashcode() 方法，利用 eclipse 自动生成如下： @Overridepublic int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result;&#125; 现在我们再次运行程序得到结果： 1 与预期一致。 摘自Effective Java一书： 在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。 如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。 如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。 对于第一条，我们通过一个例子来验证：public static void main(String[] args) &#123; Person p1 = new Person(\"小明\", 12); out(\"初始值：\" + p1.hashCode()); HashMap&lt;Person, Integer&gt; map = new HashMap&lt;&gt;(); map.put(p1, 1); p1.age = 13; out(\"更新后：\" + p1.hashCode()); out(map.get(p1));&#125; 输出结果为： 初始值：758036更新后：758067null 其中原因我就不用多说了，因此，在设计 hashCode 方法和 equals 方法的时候，如果对象中的数据易变，则最好在 equals 方法和 hashCode 方法中不要依赖于该字段。 参考文档 如何生成一个合适的hashcode方法 Java hashCode() 和 equals()"},{"title":"数据结构和算法的个人路程","date":"2016-05-17T11:15:57.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/algorithm-learning.html","permalink":"http://imxie.cc/hide/algorithm-learning.html","excerpt":"数据结构和算法一直都是自己的一个痛点。但是当自己沉下心，慢慢去学习或者复习的时候，反而开始体会到其中的一二乐趣。我并不怎么聪慧，所以一点一点的开始学习。很多解法肯定不是最优的，以后功力足够再进行优化。 这篇是自己的学习算法的路程。最基本的我不会过多阐述，一些思路和过程会通过注释的形式写出。 书籍阅读： 算法（第四版） 剑指 Offer 大话数据结构","text":"数据结构和算法一直都是自己的一个痛点。但是当自己沉下心，慢慢去学习或者复习的时候，反而开始体会到其中的一二乐趣。我并不怎么聪慧，所以一点一点的开始学习。很多解法肯定不是最优的，以后功力足够再进行优化。 这篇是自己的学习算法的路程。最基本的我不会过多阐述，一些思路和过程会通过注释的形式写出。 书籍阅读： 算法（第四版） 剑指 Offer 大话数据结构 目录 目录 基本算法 二分查找 简单选择排序 直接插入排序 快速排序 题目 在 O(1) 时间删除链表结点 调整数组顺序使奇数位于偶数前面 链表中倒数第k个结点 逆序链表 反转链表 合并两个有序链表形成一个有序链表 高质量代码 规范性 完整性 鲁棒性 额外读物 基本算法二分查找/** * @param left 左边开始的 index * @param right 右边最后的 index * @param object 需要查找的数字 * @param array 该数字容器 */private static void find(int left, int right, int object, int array[]) &#123; // 找到这个数组中间 index int middle = (left + right) / 2; if (array[middle] == object) &#123; System.out.println(\"找到这个数字的位置在:\" + middle); // array[middle] 大于需要查找的值 &#125; else if (array[middle] &gt; object) &#123; // 故该值在 0 —-&gt; middle 这个区间 right = middle - 1; // 递归 find(0, right, object, array); &#125; else &#123; // 否则该值在 middle —-&gt; 最右 这个区间,递归 find(middle, right, object, array); &#125;&#125; 简单选择排序 维基百科) 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 代码实现如下： private static void sort(int[] data) &#123; int size = data.length; for (int i = 0; i &lt; size; i++) &#123; int min = i; for (int j = i + 1; j &lt; size; j++) &#123; // 交换位置 if (data[j] &lt; data[min]) &#123; int temp = data[j]; data[j] = data[min]; data[min] = temp; &#125; &#125; &#125;&#125; 直接插入排序 维基百科 插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序 在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 一般来说，插入排序 都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。 代码实现如下： public static void insertion_sort( int[] arr ) &#123; for( int i=0; i&lt;arr.length-1; i++ ) &#123; for( int j=i+1; j&gt;0; j-- ) &#123; if( arr[j-1] &lt;= arr[j] ) break; int temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; &#125; &#125;&#125; 快速排序算法概述 / 思路快速排序一般基于递归实现。其思路是这样的： 选定一个合适的值（理想情况中值最好，但实现中一般使用数组第一个值）, 称为 “枢轴”(pivot)。 基于这个值，将数组分为两部分，较小的分在左边，较大的分在右边。 可以肯定，如此一轮下来，这个枢轴的位置一定在最终位置上。 对两个子数组分别重复上述过程，直到每个数组只有一个元素。 排序完成。 public static void quickSort(int[] arr)&#123; qsort(arr, 0, arr.length-1);&#125;private static void qsort(int[] arr, int low, int high)&#123; if (low &lt; high)&#123; int pivot=partition(arr, low, high); //将数组分为两部分 qsort(arr, low, pivot-1); //递归排序左子数组 qsort(arr, pivot+1, high); //递归排序右子数组 &#125;&#125;private static int partition(int[] arr, int low, int high)&#123; int pivot = arr[low]; //枢轴记录 while (low&lt;high)&#123; while (low&lt;high &amp;&amp; arr[high]&gt;=pivot) --high; arr[low]=arr[high]; //交换比枢轴小的记录到左端 while (low&lt;high &amp;&amp; arr[low]&lt;=pivot) ++low; arr[high] = arr[low]; //交换比枢轴小的记录到右端 &#125; //扫描完成，枢轴到位 arr[low] = pivot; //返回的是枢轴的位置 return low;&#125; 上面这个快速排序算法可以说是最基本的快速排序，因为它并没有考虑任何输入数据。但是，我们很容易发现这个算法的缺陷：这就是在我们输入数据基本有序甚至完全有序的时候，这算法退化为冒泡排序，不再是 O(n㏒n)，而是 O(n^2) 了。 更多可以参考用 Java 写算法之五：快速排序题目 在 O(1) 时间删除链表结点 给定单向链表的头指针和一个结点指针，定义一个函数在 O(1) 时间删除该结点。 public static void deletNode(Node head, Node target) &#123; // 先判空 if (head == null || target == null) &#123; throw new RuntimeException(\"不能为空\"); &#125; // 如果要删除的不是尾结点 此时时间复杂度 O(1) // 我觉得这里的思路很好，直接把下一个结点内容覆盖目标结点，不用遍历 if (target.next != null) &#123; // 找到 target 结点的下一个结点 next Node next = target.next; // 将 next 的值和指向都赋值给 target target.value = next.value; target.next = next.next; &#125; // 链表只有一个结点 删除头结点(同样是尾结点) else if (head == target) &#123; // 这里在 Java 引用传递的原因，如果要删除这种情况下的结点，需要有返回值。 // 先这样的思路即可 head = target = null; &#125; // 多个结点 删除尾部结点 else &#123; Node temp = head; while (temp != null) &#123; // 在当前结点的下一个结点是 target 的时候 if (temp.next == target) &#123; // 将当前结点的 next 指向 null 即可删除 target temp.next = null; &#125; temp = temp.next; &#125; &#125; &#125; 调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 public static int[] reOrderArray(int[] array) &#123; // 这个方法比较笨 ArrayList&lt;Integer&gt; oddList = new ArrayList&lt;Integer&gt;(); ArrayList&lt;Integer&gt; evenList = new ArrayList&lt;Integer&gt;(); for (int anArray : array) &#123; if (anArray % 2 == 0) &#123; // 偶数 evenList.add(anArray); &#125; else &#123; // 奇数 oddList.add(anArray); &#125; &#125; System.out.println(\"奇数:\"+oddList.size()); System.out.println(\"偶数:\"+evenList.size()); for (int i = 0; i &lt; oddList.size(); i++) &#123; array[i] = oddList.get(i); &#125; for (int i = oddList.size(); i &lt; evenList.size() + oddList.size(); i++)&#123; array[i] = evenList.get(i-oddList.size()); &#125; return array;&#125; 链表中倒数第k个结点 输入一个链表，输出该链表中倒数第k个结点。 public static ListNode findKthToTail(ListNode head, int k) &#123; // 利用栈的先进后出特性 Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;(); // 判空 if (head == null || k &lt;= 0) return null; // 依次入栈 while (head != null) &#123; stack.push(head); head = head.next; &#125; // 判断临界值 if (k &gt; stack.size()) return null; for (int i = 0; i &lt; k - 1; i++) &#123; stack.pop(); &#125; return stack.pop();&#125; 接受老司机指导，推荐用快慢指针（记住这个经典的方法）来做这个问题，自己下来用代码实现了下： public static ListNode findKthToTail2(ListNode head, int k) &#123; // 两个指针的经典问题 找到倒数第 K 个 我们可以将 after 指针慢 first K 个结点 // 当 first == null 的时候 此时 after 就是倒数第 K 个了 ListNode first; ListNode after = null; int count = 0; first = head; while (first != null) &#123; count++; if (count &gt;= k) &#123; after = head; head = head.next; &#125; first = first.next; &#125; return after;&#125; 逆序链表 输入一个链表的头结点，从尾到头打印每个结点的值 最开始我很容易想到是用栈。public static void printListFromTailToHead(ListNode listNode) &#123; if (listNode == null) return; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); // 尾巴就是 node.next == null while (listNode != null) &#123; stack.push(listNode.val); listNode = listNode.next; &#125; while (!stack.isEmpty()) &#123; System.out.println(stack.pop()); &#125;&#125; 后来想了下，递归的本质就是栈的结构，所以可以用递归来：static void printListFromTailToHead2(ListNode listNode)&#123; // 递归的方式 if (listNode!=null)&#123; if (listNode.next!=null)&#123; printListFromTailToHead2(listNode.next); &#125; &#125; System.out.println(listNode.val);&#125; 反转链表 输入一个链表，反转链表后，输出链表的所有元素。 public ListNode ReverseList(ListNode head) &#123; //当前节点是head，pre为当前节点的前一节点，next为当前节点的下一节点 // pre --&gt; head --&gt; next1 --&gt; next2 if (head == null) return null; ListNode pre = null; ListNode next = null; while (head != null) &#123; // 先暂存 当前结点(head) 的下一个结点 next next = head.next; // 然后将 当前结点(head) 的下一个结点指向上一个结点 pre head.next = pre; // 因为遍历,下一轮中的结点的上一个结点就是当前结点 pre = head; // 然后把暂存的结点赋值给当前结点,让遍历继续 head = next; &#125; return pre;&#125; 合并两个有序链表形成一个有序链表public static Node merge(Node list1, Node list2) &#123; if (list1 == null) return list2; if (list2 == null) return list1; Node mergeHead = null; if (list1.value &lt; list2.value) &#123; mergeHead = list1; mergeHead.next = merge(list1.next, list2); &#125; else &#123; mergeHead = list2; mergeHead.next = merge(list1, list2.next); &#125; return mergeHead;&#125; 这里用到了递归，首先我们会找到一个头结点，进行同样的判断递归合并排序。 高质量代码规范性 书写清晰 布局清晰 命名合理 完整性 完成基本功能 考虑边界条件 做好错误处理 鲁棒性 采取防御式编程 处理无效的输入 额外读物 算法时间复杂度计算"},{"title":"细致一点地看看 Handler 和它的伙伴们","date":"2016-09-17T09:48:06.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/deep-into-handler-source.html","permalink":"http://imxie.cc/hide/deep-into-handler-source.html","excerpt":"Handler 对于 Android 开发来说简直就是家常便饭，它的原理自然都很熟悉，这篇文章不会宏观地去介绍它的原理，而是细节深入到各个组成。","text":"Handler 对于 Android 开发来说简直就是家常便饭，它的原理自然都很熟悉，这篇文章不会宏观地去介绍它的原理，而是细节深入到各个组成。 目录 目录 关系 分析 0x01 0x02 0x03 0x04 总结 参考 关系开始深入细节的时候，我们可以先复习下 Handler 、Looper 和 MessageQueue 三者的关系。 Handler 必须在 Looper.prepare() 之后才能创建使用 Looper 与当前线程关联，并且管理着一个 MessageQueue Message 是实现 Parcelable 接口的类 以一个线程为基准，他们的数量级关系是：Handler(N) : Looper(1) : MessageQueue(1) : Thread(1) 他们的调用关系可以参考这张图： 分析0x01public Handler(Callback callback, boolean async) &#123; // 代码省略 mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 从 Handler 默认的构造函数我们可以看到，Handler 内部会通过 Looper.myLooper() 来获取 Looper 对象，从而与之关联。 0x02我们之前已经知道 Looper 管理着消息队列，从这里深入进去看看是如何跟 MessageQueue 建立联系。 public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125;public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125;&#125; 在 Looper.myLooper() 里我们看到，Looper 是通过 sThreadLocal.get() 来获取，那么我们又是何时将 Looper 设置给 sThreadLocal 的呢？答案就在 prepare() 方法里。我们看到 sThreadLocal.set(new Looper(quitAllowed)); 实例化了一个 Looper 对象给 sThreadLocal 并且一个线程只有一个 Looper 。 同时我也贴出了 prepareMainLooper() 方法，根据名字大家都可以猜到，这个方法就是在 Android 主线程(UI)线程调用的方法，而在这个方法里也调用了 prepare(false) 我们看到这里传入的是 false ，表明主线程这里的 Looper 是无法执行 quit() 方法。我在这里贴出 ActivityThread 的 Main() 方法的部分代码，这也是我们程序的入口：public static void main(String[] args) &#123; // 代码省略 Looper.prepareMainLooper(); // 创建消息循环 Looper ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); // UI 线程的 Handler &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; Looper.loop(); // 执行消息循环&#125; 在这里我们更清楚了为什么可以直接在主线程创建 Handler ，而不会发生异常。 以上，我们明白了 Looper 是通过 prepare() 方法与线程建立联系，同时不同线程是无法访问对方的消息队列。 为什么 Handler 要在主线程创建才能更新 UI 呢？ 因为 Handler 要与主线程的消息队列关联上，这样 handleMessage() 才会执行在 UI 线程。 0x03Looper 的核心其实是它循环取出消息的代码：public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // 死循环 for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; /// Handler msg.target msg.target.dispatchMessage(msg); // 派发消息 // 代码省略 msg.recycleUnchecked(); &#125;&#125; 从上面代码我们可以看到，Looper 在 loop() 方法里建立了一个死循环，通过消息队列里不断的取出消息，交给 Handler 去处理。 这个时候你可能会有一个问题： Android 中为什么主线程不会因为 Looper.loop() 里的死循环卡死？ 我比较推荐 Gityuan 的回答 回到我们这里，在循环中是通过 msg.target.dispatchMessage(msg); 派发消息。其中 msg 是 Message 类型，简单看看它的成员：public final class Message implements Parcelable &#123; Handler target; Runnable callback; Message next; public Object obj; public int arg1; public int arg2; // 代码省略&#125; 可以知道消息队列是链表实现的，并且 target 是 Handler 类型。 现在就可以连通了，通过 Handler 将 Message 投递给消息队列（链表），Looper.loop() 循环从消息队列里取出消息，又将消息分发给 Handler 去处理。通过这个 target 我们也可以知道一个小细节，Handler 只能处理自己所发出的消息。 0x04理解清楚之后我们跟着顺序，看看 Handler 是如何处理和分发消息的。 // 处理消息方法，交给子类复写public void handleMessage(Message msg) &#123;&#125;public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125;private static void handleCallback(Message message) &#123; message.callback.run();&#125; 我们看到 dispatchMessage() 只是一个分发方法，如果 Runnable 类型的 callback 为空，则执行 handleMessage(msg) 处理信息，该方法为空，是交给子类进行复写，并且执行线程是在 Handler 所创建的线程。如果 callback 不为空，则会执行 handleCallback(msg) 来处理信息，该方法会调用 callback 的 run() 方法。 其实说简单一点，就是 Handler 的两种分发类型。一种是 post(r) 另一种是 sendMessage(msg)。 我们具体看看这两个方法： public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;private static Message getPostMessage(Runnable r)&#123; Message m = Message.obtain(); m.callback = r; return m;&#125;public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; // 与当前 Handler 绑定 if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 做了一个导图，方便理解下： 从中我们可以看到，在 post(r) 时，会将 Runnable 包装成 Message 对象，并且赋值给 Message 的 callback 字段，最后跟 sendMessage(msg) 方法一样将消息插入队列。 根据代码和导图，无论是 post(r) 还是 sendMessage(msg) 都会最终调用 sendMessageAtTime(msg,time) 总结Handler 最终将消息追加到 MessageQueue 中，而 Looper 不断的从 MessageQueue 中读取消息，并且调用 Handler 的 dispatchMessage 分发消息，最后交给上层处理消息。 参考 Android 开发进阶 从小工到专家 Android 开发艺术探索"},{"title":"从 RxBus 这辆兰博基尼深入进去","date":"2016-06-02T12:24:41.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/deep-understanding-of-RxBus.html","permalink":"http://imxie.cc/hide/deep-understanding-of-RxBus.html","excerpt":"很早之前有看过别人实现的 RxBus , 当初也只是随意用用而已，没有想过去研究。今天看到 brucezz 天哥在群里分享了一把，自己也加入了讨论，下来还实践了一把，所以想借此篇进入到源码层，深刻体验下 RxBus 这辆 “兰博基尼” 的设计美感和独特魅力。 本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布","text":"很早之前有看过别人实现的 RxBus , 当初也只是随意用用而已，没有想过去研究。今天看到 brucezz 天哥在群里分享了一把，自己也加入了讨论，下来还实践了一把，所以想借此篇进入到源码层，深刻体验下 RxBus 这辆 “兰博基尼” 的设计美感和独特魅力。 本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布 RxBus 准备 解剖 从 Subject 开始发车 官方解释 Subject 源码 PublishSubject 解释 串行化 SerializedSubject SerializedObserver NotificationLite CompositeSubscription 参考文章 熄火休息 RxBus准备关于简单的实现和用法，这篇文章已经很好的说明了。 推荐先看看 RxBus 的简单实现和用法。 地址在这里：RxBus 的简单实现 解剖 让我们看看这辆车到底用了些什么？ Subject SerializedSubject PublishSubject CompositeSubscription 从 Subject 开始发车官方解释这是 Subject 的中文解释： Subject可以看成是一个桥梁或者代理，在某些ReactiveX实现中（如RxJava），它同时充当了Observer和Observable的角色。因为它是一个Observer，它可以订阅一个或多个Observable；又因为它是一个Observable，它可以转发它收到(Observe)的数据，也可以发射新的数据。 由于一个Subject订阅一个Observable，它可以触发这个Observable开始发射数据（如果那个Observable是”冷”的–就是说，它等待有订阅才开始发射数据）。因此有这样的效果，Subject可以把原来那个”冷”的Observable变成”热”的。 Subject 源码源码： public abstract class Subject&lt;T, R&gt; extends Observable&lt;R&gt; implements Observer&lt;T&gt; &#123; protected Subject(OnSubscribe&lt;R&gt; onSubscribe) &#123; super(onSubscribe); &#125; public abstract boolean hasObservers(); public final SerializedSubject&lt;T, R&gt; toSerialized() &#123; if (getClass() == SerializedSubject.class) &#123; return (SerializedSubject&lt;T, R&gt;)this; &#125; return new SerializedSubject&lt;T, R&gt;(this); &#125; Subject 只有两个方法。 hasObservers()方法的解释是: Indicates whether the {@link Subject} has {@link Observer Observers} subscribed to it.判断 Subject 是否已经有 observers 订阅了 有则返回 ture toSerialized() 方法的解释是： Wraps a {@link Subject} so that it is safe to call its various {@code on} methods from different threads.包装 Subject 后让它可以安全的在不同线程中调用各种方法 为什么这个方法后就可以是线程安全了呢？ 我们看到 toSerialized() 返回了 SerializedSubject&lt;T, R&gt; 。我们先到这里打住，稍后我们再看看该类做了什么。 PublishSubject 解释 在 RxJava 里有一个抽象类 Subject，既是 Observable 又是 Observer，可以把 Subject 理解成一个管道或者转发器，数据从一端输入，然后从另一端输出。 Subject 有好几种，这里可以使用最简单的 PublishSubject。订阅之后，一旦数据从一端传入，结果会里立刻从另一端输出。 源码里给了用法例子： PublishSubject&lt;Object&gt; subject = PublishSubject.create();// observer1 will receive all onNext and onCompleted eventssubject.subscribe(observer1);subject.onNext(\"one\");subject.onNext(\"two\");// observer2 will only receive \"three\" and onCompletedsubject.subscribe(observer2);subject.onNext(\"three\");subject.onCompleted(); 串行化官方文档推荐我们： 如果你把 Subject 当作一个 Subscriber 使用，注意不要从多个线程中调用它的onNext方法（包括其它的on系列方法），这可能导致同时（非顺序）调用，这会违反Observable协议，给Subject的结果增加了不确定性。 要避免此类问题，你可以将 Subject 转换为一个 SerializedSubject ，类似于这样：mySafeSubject = new SerializedSubject( myUnsafeSubject ); 所以我们可以看到在 RxBus 初始化的时候我们做了这样一件事情： private final Subject&lt;Object, Object&gt; BUS;private RxBus() &#123; BUS = new SerializedSubject&lt;&gt;(PublishSubject.create());&#125; 为了保证多线程的调用中结果的确定性，我们按照官方推荐将 Subject 转换成了一个 SerializedSubject 。 SerializedSubject 该类同样是 Subject 的子类，这里贴出该类的构造方法。 private final SerializedObserver&lt;T&gt; observer;private final Subject&lt;T, R&gt; actual;public SerializedSubject(final Subject&lt;T, R&gt; actual) &#123; super(new OnSubscribe&lt;R&gt;() &#123; @Override public void call(Subscriber&lt;? super R&gt; child) &#123; actual.unsafeSubscribe(child); &#125; &#125;); this.actual = actual; this.observer = new SerializedObserver&lt;T&gt;(actual);&#125; 我们发现，Subject 最后转化成了 SerializedObserver. SerializedObserver When multiple threads are emitting and/or notifying they will be serialized by:Allowing only one thread at a time to emitAdding notifications to a queue if another thread is already emittingNot holding any locks or blocking any threads while emitting 一次只会允许一个线程进行发送事物如果其他线程已经准备就绪，会通知给队列在发送事物中，不会持有任何锁和阻塞任何线程 通过介绍可以知道是通过 notifications 来进行并发处理的。 SerializedObserver 类中private final NotificationLite&lt;T&gt; nl = NotificationLite.instance(); 重点看看 nl 在 onNext() 方法里的使用： @Override public void onNext(T t) &#123; // 省略一些代码 for (;;) &#123; for (int i = 0; i &lt; MAX_DRAIN_ITERATION; i++) &#123; FastList list; synchronized (this) &#123; list = queue; if (list == null) &#123; emitting = false; return; &#125; queue = null; &#125; for (Object o : list.array) &#123; if (o == null) &#123; break; &#125; // 这里的 accept() 方法 try &#123; if (nl.accept(actual, o)) &#123; terminated = true; return; &#125; &#125; catch (Throwable e) &#123; terminated = true; Exceptions.throwIfFatal(e); actual.onError(OnErrorThrowable.addValueAsLastCause(e, t)); return; &#125; &#125; &#125; &#125; &#125; NotificationLite知道哪里具体调用了之后，我们再仔细看看 NotificationLite 。 先来了解它到底是什么： For use in internal operators that need something like materialize and dematerialize wholly within the implementation of the operator but don’t want to incur the allocation cost of actually creating {@link rx.Notification} objects for every {@link Observer#onNext onNext} and {@link Observer#onCompleted onCompleted}.It’s implemented as a singleton to maintain some semblance of type safety that is completely non-existent. 大致意思是：作为一个单例类保持这种完全不存在的安全类型的表象。 刚我们在 SerializedObserver 的 onNext() 方法中看到 nl.accept(actual, o)所以我们再深入到 accept() 方法中： public boolean accept(Observer&lt;? super T&gt; o, Object n) &#123; if (n == ON_COMPLETED_SENTINEL) &#123; o.onCompleted(); return true; &#125; else if (n == ON_NEXT_NULL_SENTINEL) &#123; o.onNext(null); return false; &#125; else if (n != null) &#123; if (n.getClass() == OnErrorSentinel.class) &#123; o.onError(((OnErrorSentinel) n).e); return true; &#125; o.onNext((T) n); return false; &#125; else &#123; throw new IllegalArgumentException(\"The lite notification can not be null\"); &#125; &#125; Unwraps the lite notification and calls the appropriate method on the {@link Observer}.判断 lite 通知类别，通知 observer 执行适当方法。 通过 NotificationLite 类图可以看到有三个标识 ON_NEXT_NULL_SENTINEL （onNext 标识） ON_COMPLETED_SENTINEL （onCompleted 标识) OnErrorSentinel (onError 标识) 与 Observer 回调一致。通过分析得知 accept() 就是通过标识来判断，然后调用 Observer 相对应的方法。 CompositeSubscriptionRxBus 这辆”兰博基尼”与 CompositeSubscription 车间搭配更好。 构造函数： private Set&lt;Subscription&gt; subscriptions;private volatile boolean unsubscribed;public CompositeSubscription() &#123;&#125;public CompositeSubscription(final Subscription... subscriptions) &#123; this.subscriptions = new HashSet&lt;Subscription&gt;(Arrays.asList(subscriptions));&#125; 内部是初始化了一个 HashSet ，按照哈希算法来存取集合中的对象，存取速度比较快，并且没有重复对象。 所以我们推荐在基类里实例化一个 CompositeSubscription 对象，使用 CompositeSubscription 来持有所有的 Subscriptions ，然后在 onDestroy()或者 onDestroyView()里取消所有的订阅。 参考文章 http://blog.csdn.net/lzyzsd/article/details/45033611 https://mcxiaoke.gitbooks.io/rxdocs/content/Subject.html 熄火休息能力有限，文章错误还望指出，有任何问题都欢迎讨论 :) 转载请注明出处。 最后送上我女神 Gakki , 开心最好 ( ´͈ｖ `͈ )◞。"},{"title":"RxJava 线程切换源码的一些体会和思考","date":"2016-12-25T08:02:31.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/how_the_rxjava_thread_work.html","permalink":"http://imxie.cc/hide/how_the_rxjava_thread_work.html","excerpt":"前言RxJava 是在今年年初的时候上的车，接触也快要满一年了。从最初只知道几个操作符，写写 Demo ，或者跟着别人的项目和经验依葫芦画瓢，到目前终于有点初窥门径的地步。 RxJava 对于 Android 来说，最直观地便利就在于线程切换。所以本篇内容就是学习 RxJava 是如何实现切换线程。 希望读者阅读此篇文章，是有用过 RxJava 的童鞋。 本章内容基于源码版本 RxJava: 1.2.4","text":"前言RxJava 是在今年年初的时候上的车，接触也快要满一年了。从最初只知道几个操作符，写写 Demo ，或者跟着别人的项目和经验依葫芦画瓢，到目前终于有点初窥门径的地步。 RxJava 对于 Android 来说，最直观地便利就在于线程切换。所以本篇内容就是学习 RxJava 是如何实现切换线程。 希望读者阅读此篇文章，是有用过 RxJava 的童鞋。 本章内容基于源码版本 RxJava: 1.2.4 文章来源：itsCoder 的 WeeklyBolg 项目 itsCoder主页：http://itscoder.com/ 作者：谢三弟 审阅者： 用语 JasonThink 目录 目录 前言 切换 SubscribeOn ObserveOn 共用时各自的作用域 思考 参考 准备答案我会放在文章末尾 先来一道开胃菜： 指出下列程序操作符所运行的线程。 Observable.just() //1 .subscribeOn(Schedulers.newThread()) .map() //2 .subscribeOn(Schedulers.io()) .map() //3 .observeOn(Schedulers.computation()) .map() //4 .observeOn(Schedulers.newThread()) .subscribe() //5 开胃菜就到上面结束，如果你能够清楚明白每个操作运行的线程，说明对于 RxJava 的线程切换的理解很正确。 再具体分析 RxJava 是如何线程切换的，希望能清楚以下几个 RxJava 中名词的意思。 Create() OnSubscribe Operator 如果你特别明白这几个 RxJava 类/方法的作用，可以直接跳过看切换这部分。 Create() /** * Returns an Observable that will execute the specified function when a &#123;@link Subscriber&#125; subscribes to * it. */public static &lt;T&gt; Observable&lt;T&gt; create(OnSubscribe&lt;T&gt; f) &#123; return new Observable&lt;T&gt;(RxJavaHooks.onCreate(f));&#125; 方法注释上说明，当订阅者订阅之后，该函数会返回将会执行具体功能的流。操作符进入源码会发现他们最终都会调用到 create() 函数。 OnSubscribe /** * Invoked when Observable.subscribe is called. * @param &lt;T&gt; the output value type */public interface OnSubscribe&lt;T&gt; extends Action1&lt;Subscriber&lt;? super T&gt;&gt; &#123;&#125; 首先我们知道这是一个继承 Action1 的接口，并且是在 Observable.subscribe 流进行订阅操作后回调。而且回顾刚刚 create() 源码中也发现参数就是这个 OnSubscribe 。 Action 的作用就是执行其中的 call() 方法。 Observable.OnSubscribe 有点像 Todo List ，里面都是一个一个待处理的事务，并且这个 List 是有序的（这个很关键）。 Operator public interface Operator&lt;R, T&gt; extends Func1&lt;Subscriber&lt;? super R&gt;, Subscriber&lt;? super T&gt;&gt; &#123; // cover for generics insanity&#125; 简单来说它的职责就是将一个 Subscriber 变成另外一个 Subscriber。 切换上面知识点是一些小铺垫，因为后面的内容核心其实就是上面几个类的作用。 SubscribeOn追踪这个方法，核心是在这个类： public final class OperatorSubscribeOn&lt;T&gt; implements OnSubscribe&lt;T&gt; &#123; final Scheduler scheduler; final Observable&lt;T&gt; source; public OperatorSubscribeOn(Observable&lt;T&gt; source, Scheduler scheduler) &#123; this.scheduler = scheduler; this.source = source; &#125;&#125; 我先贴出这个类的，构造方法和成员变量，因为很重要，我们先把前因弄清楚。 首先我们发现这个类是实现了 OnSubscribe 接口，之前复习到这个的作用就是在该流被订阅之后执行 call() 方法，这里面就是后果，待会我们来看。 前因其实很简单，就是传入两个参数： 一个是 Scheduler ，调度器，它的具体实现在 Schedulers 里。 Observable&lt;T&gt; source 这个其实就是当前这个流。 public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; if (this instanceof ScalarSynchronousObservable) &#123; return ((ScalarSynchronousObservable&lt;T&gt;)this).scalarScheduleOn(scheduler); &#125; return create(new OperatorSubscribeOn&lt;T&gt;(this, scheduler));&#125; 接下来看看 call() 核心代码里做的事情： // 因为是 OnSubscribe 类，这里 call() 中传入的参数是 Observable.subscribe(s) 中的 s@Override public void call(final Subscriber&lt;? super T&gt; subscriber) &#123; // 根据传入的调度器，创建一个 Worker 对象 inner final Worker inner = scheduler.createWorker(); subscriber.add(inner); // 在 Worker 对象 inner 中执行（意思就是，在我们指定的调度器创建的线程中运行） inner.schedule(new Action0() &#123; @Override public void call() &#123; final Thread t = Thread.currentThread(); // 对订阅者包装 Subscriber&lt;T&gt; s = new Subscriber&lt;T&gt;(subscriber) &#123; @Override public void onNext(T t) &#123; subscriber.onNext(t); &#125; ······ &#125;; // 这一句位置很关键 // 首先 source 是之前传入的流（也就是当前流），在 Worker 内部进行了订阅操作，所以该流所有操作都执行在其中 source.unsafeSubscribe(s); &#125; &#125;); &#125; 通过我们指定的调度器，创建好 Worker ，之前传入的流在 Worker 内部，对重新包裹的 subscriber 进行订阅操作。 所以 SubscribeOn()最关键的地方其实是因为这行代码在调度器创建的 Worker 的 call() 中 source.unsafeSubscribe(s); 总结： subscribeOn 其实是改变了调用前序列所运行的线程。 ObserveOn同样的方法来分析，最终的回调会到： public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; if (this instanceof ScalarSynchronousObservable) &#123; return ((ScalarSynchronousObservable&lt;T&gt;)this).scalarScheduleOn(scheduler); &#125; return lift(new OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));&#125; 其实看到关键字 lift 和 operator 就大约可以猜到是做什么的了。 接下来我们进入到 OperatorObserveOn 类中： public final class OperatorObserveOn&lt;T&gt; implements Operator&lt;T, T&gt; &#123; private final Scheduler scheduler; // 省略不必要的代码 @Override public Subscriber&lt;? super T&gt; call(Subscriber&lt;? super T&gt; child) &#123; // 省略 ··· ObserveOnSubscriber&lt;T&gt; parent = new ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize); parent.init(); return parent; &#125; &#125;&#125; 我们首先会注意到它是一个 Operator ，并且没有对上层 Observale 做任何修改和包装。那么它的作用就是将一个 Subscriber 变成另外一个 Subscriber。所以接下来我们的首要任务就是看转换后的 Subscriber 做了什么改变。 关键代码在 ObserveOnSubscriber&lt;T&gt; parent = new ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);parent.init(); child 是改变前的 Subscriber ，最后返回了 parent 。 我们发现 ObserveOnSubscriber 同样也是一个 Subscriber 类，所以肯定含有 onNext/onError/onComplete 这三个标准方法，重要的肯定是 onNext ，所以我只贴上了该类三个有关函数。 void init() &#123; Subscriber&lt;? super T&gt; localChild = child; localChild.setProducer(new Producer() &#123; @Override public void request(long n) &#123; if (n &gt; 0L) &#123; BackpressureUtils.getAndAddRequest(requested, n); // 执行 schedule(); &#125; &#125; &#125;); // recursiveScheduler 这个是构造函数时传入调度器创建的 worker localChild.add(recursiveScheduler); localChild.add(this);&#125;@Overridepublic void onNext(final T t) &#123; if (isUnsubscribed() || finished) &#123; return; &#125; // 条件判断里先将之前流的结果缓存进队列 if (!queue.offer(on.next(t))) &#123; onError(new MissingBackpressureException()); return; &#125; // 执行 schedule();&#125;protected void schedule() &#123; if (counter.getAndIncrement() == 0) &#123; // 在当前 worker 上执行该类的 call 方法 recursiveScheduler.schedule(this); &#125;&#125; call() 方法有点冗长，做的事情其实很简单，就是取出我们缓存之前流的所有值，然后在 Worker 工作线程中传下去。 总结： ObserveOn 不会关心之前的流的线程 ObserveOn 会先将之前的流的值缓存起来，然后再在指定的线程上，将缓存推送给后面的 Subscriber 共用时各自的作用域Observable.just() //1 .subscribeOn(Schedulers.newThread()) .map() //2 .map() //3 .observeOn(Schedulers.computation()) .map() //4 .observeOn(Schedulers.newThread()) .subscribe() //5 如果分析这个流各个操作符的执行线程，我们先把第一个 subscribeOn() 之前和第一个 observeOn() 之前的 Todo Items 找出来然后求并集： 得到的结果就是 subscribeOn() 的作用域。 之后的线程切换简单了，遇到 observeOn() 就切换一次。 思考为什么subscribeOn 只有第一次调用生效？我的理解如下： subscribeOn 的作用域就是调用前序列中所有的 Todo List 任务清单（Observable.OnSubscribe），当我们执行 subscribe() 时，这些任务清单就会执行在 subscribeOn 指定的工作线程，而第二个 subscribeOn 早就没有任务可做了，所以无法生效。 知乎里这段说的比我专业： 正像 StackOverflow 上那段描述的，整个 Observable 数据流工作起来是分为两个阶段（或者说是两个 lifecycle）：upstream 的 subscription-time 和 downstream 的 runtime。 subscription-time 的阶段，是为了发起和驱动数据流的启动，在内部实现上体现为 OnSubscribe 向上游的逐级调用（控制流向上游传递）。支持 backpressure 的 producer request 也属于这个阶段。除了 producer request 的情况之外，subscription-time 阶段一般就是从下游到上游调用一次就结束了，最终到达生产者（以最上游的那个 OnSubscribe 来体现）。接下来数据流就开始向下游流动了。 Rxjava 中， subscribeOn 及 observeOn 方法切换线程发生的位置为什么设计为不同的？ - 知乎 doOnSubscribe 的例外我们再改动下开胃菜的代码： Observable.just() //1 .subscribeOn(Schedulers.newThread()) .map() //2 .subscribeOn(Schedulers.io()) .map() //3 .observeOn(Schedulers.computation()) .map() //4 .doOnSubscribe() //6 .observeOn(Schedulers.newThread()) .subscribe() //5 只添加了一行.doOnSubscribe() //6 ，也是探讨这个操作符执行的线程。 public class OperatorDoOnSubscribe&lt;T&gt; implements Operator&lt;T, T&gt; &#123; private final Action0 subscribe; public OperatorDoOnSubscribe(Action0 subscribe) &#123; this.subscribe = subscribe; &#125; @Override public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super T&gt; child) &#123; // 执行我们的 Action subscribe.call(); // Wrap 里面是包装成一个新的 Subscriber 返回，不对这个流做任何改变 return Subscribers.wrap(child); &#125;&#125; doOnSubscribe 执行的线程其实就是 subscribe.call(); 所在的线程。这里触发的时机就是，当我们进行 Observable.subscribe() 时，如果我们没有在紧接之后SubscribeOn 指定线程，那么它就会运行在默认线程，然后返回一个新的流。 关于 doOnSubscribe() 留一个问题 Observable.just() .doOnSubscribe() // 1 .doOnSubscribe() // 2 .subscribe() 问题是，对于 1 和 2 的执行顺序？ 在开发中，我们肯定不会像问题那样写代码，只是自己在看 doOnSubscribe 源码的时候，在问自己为什么它在其他操作符之前，拓展到了 RxJava 流的一个执行顺序，也是自己想要明白的地方。所以下次准备探讨学习。 对了，老司机说 RxJava 很像洋葱，一层一层。 进行分析学习的时候可以类比帮助理解。 参考Thomas Nield: RxJava- Understanding observeOn() and subscribeOn() SubscribeOn 和 ObserveOn |Piasy Blog 答案： 1 newThread 2 newThread 3 newThread 4 computation 5 newThread"},{"title":"Android 初阶自定义 View 字符头像","date":"2016-09-14T14:37:10.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/let-s-practise-custom-view.html","permalink":"http://imxie.cc/hide/let-s-practise-custom-view.html","excerpt":"自己很少做自定义 View ，只有最开始的时候跟着郭神写了一个小 Demo ，后来随着见识的越来越多，特别是在开源社区看到很多优秀的漂亮的控件，都是羡慕的要死，但是拉下来的代码还是看不明白，而且当时因为时间因素，没有深入学习和研究控件和动画方面的知识，而是把更多时间花在了 Android 的异步通信和网络框架这一块。因为想起暑假实习的时候有个小需求，当时因为忙着主要的业务，一直搁浅没有做，回到学校发现其实不难。索性从这个人生第一个上架的小控件慢慢深入一点，顺带复习 View 的绘制原理。","text":"自己很少做自定义 View ，只有最开始的时候跟着郭神写了一个小 Demo ，后来随着见识的越来越多，特别是在开源社区看到很多优秀的漂亮的控件，都是羡慕的要死，但是拉下来的代码还是看不明白，而且当时因为时间因素，没有深入学习和研究控件和动画方面的知识，而是把更多时间花在了 Android 的异步通信和网络框架这一块。因为想起暑假实习的时候有个小需求，当时因为忙着主要的业务，一直搁浅没有做，回到学校发现其实不难。索性从这个人生第一个上架的小控件慢慢深入一点，顺带复习 View 的绘制原理。 文章来源：itsCoder 的 WeeklyBolg 项目 itsCoder主页：http://itscoder.com/ 作者：谢三弟 审阅者：Brucezz 目录 目录 目标效果 继承 ImageView 开始 工作流程 onMeasure() onLayout() onDraw() 使用 额外阅读 目标效果 需求：实习公司一个产品，因为很多是临时用户，需要为这些没有自觉设置头像的用户，给予随机头像。生成的规则是根据用户用户名的第一个字符随机匹配颜色集。 从需求中我们可以知道： 该控件需要展示图片 该控件需要按照规则生成图像 一般头像都是圆形 大致上可以知道是这样的。开搞！ 继承 ImageView 开始我们都知道 Android 自带了很多控件，我们自定义控件的出发点只是官方提供的控件无法满足业务需求的时候。从我们的需求来看，该控件是图片展示类的，所以我们很自然想到了只需要在系统 ImageView 上进行功能拓展即可，这样就可以满足新的需求又不会失去 ImageView 自带的功能。 public class CharAvatarView extends ImageView &#123; private static final String TAG = CharAvatarView.class.getSimpleName(); // 颜色画板集 private static final int[] colors = &#123; 0xff1abc9c, 0xff16a085, 0xfff1c40f, 0xfff39c12, 0xff2ecc71, 0xff27ae60, 0xffe67e22, 0xffd35400, 0xff3498db, 0xff2980b9, 0xffe74c3c, 0xffc0392b, 0xff9b59b6, 0xff8e44ad, 0xffbdc3c7, 0xff34495e, 0xff2c3e50, 0xff95a5a6, 0xff7f8c8d, 0xffec87bf, 0xffd870ad, 0xfff69785, 0xff9ba37e, 0xffb49255, 0xffb49255, 0xffa94136 &#125;; private Paint mPaintBackground; private Paint mPaintText; private Rect mRect; private String text; private int charHash; public CharAvatarView(Context context) &#123; this(context, null); &#125; public CharAvatarView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public CharAvatarView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mPaintBackground = new Paint(Paint.ANTI_ALIAS_FLAG); mPaintText = new Paint(Paint.ANTI_ALIAS_FLAG); mRect = new Rect(); &#125;&#125; 在这里我做了一些初始化工作，并且在其中的一个构造函数中实例化了 Paint 和 Rect 。 关于 View 的构造函数的区别： public CharAvatarView(Context context) &#123; super(context);&#125;public CharAvatarView(Context context, AttributeSet attrs) &#123; super(context, attrs);&#125;public CharAvatarView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr);&#125; 第一种属于程序内实例化时采用，之传入 Context 即可CharAvatarView avatarView = new CharAvatarView(this); 这样我们的 View 就新建出来了，根据需求添加到布局即可。 第二种用于 layout 文件实例化，会把 XML 内的参数通过 AttributeSet 带入到 View 内。 第三个主题的 style 信息，也会从 XML 里带入 为了自定义的 View 兼容 Java 和 Xml 两种代码的使用方式，一般推荐这样写构造方法：public CharAvatarView(Context context) &#123; this(context, null); &#125; public CharAvatarView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public CharAvatarView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mPaintBackground = new Paint(Paint.ANTI_ALIAS_FLAG); mPaintText = new Paint(Paint.ANTI_ALIAS_FLAG); mRect = new Rect(); &#125; 工作流程我们的 View 系统是如何将它绘制到屏幕上的呢？ View 的绘制流程是从 ViewRoot 的 performTraversals 方法开始，它经过 measure 、 layout 和 draw 三个过程才能最终将一个 View 绘制出来，其中 measure 用来测量 View 的宽和高，layout 用来确定 View 在父容器中的放置位置，而 draw 则负责将 View 绘制在屏幕上。针对 performTraversals 的大致流程如图： Measure 过程决定了 View 的宽/高， Measure 完成以后，可以通过 getMeasuredWidth 和 getMeasuredHeight 方法来获取到 View 测量后的宽/高，在几乎所有的情况下它都等同于 View 最终的宽/高，但是特殊情况除外。Layout 过程 决定了 View 的四个顶点的坐标和实际的 View 的宽/高，完成以后，可以通过 getTop、getBottom、getLeft、getRight 来拿到 View 的四个顶点的位置，并可以通过 getWidth 和 getHeight 方法拿到 View 最终的宽/高。Draw 过程则决定了 View 的显示，只有 draw 方法完成以后 View 的内容才能呈现在屏幕上。 关于 View 工作流程的深入我们在以后另外开篇进行研究。目前我们已经从宏观了解到了 View 会经历三个过程绘制出来，而且清楚了其中不同方法中的用途。接下来我们看看 CharAvatarView 在这三个流程中分别做了什么。 onMeasure()@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, widthMeasureSpec); // 宽高相同&#125; 让宽高相同，我在这里是只直接传入宽度进行测量。这样会得到一个正方形的 View。 onLayout()@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom);&#125; 我在这里什么也没有做，因为需求里对 View 的位置没有什么需要特殊的处理。 onDraw()大部分自定义控件，最核心的代码就是在 onDraw() 里了。 protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (null != text) &#123; int color = colors[charHash % colors.length]; // 画圆 mPaintBackground.setColor(color); canvas.drawCircle(getWidth() / 2, getWidth() / 2, getWidth() / 2, mPaintBackground); // 写字 mPaintText.setColor(Color.WHITE); mPaintText.setTextSize(getWidth() / 2); mPaintText.setStrokeWidth(3); mPaintText.getTextBounds(text, 0, 1, mRect); // 垂直居中 Paint.FontMetricsInt fontMetrics = mPaintText.getFontMetricsInt(); int baseline = (getMeasuredHeight() - fontMetrics.bottom - fontMetrics.top) / 2; // 左右居中 mPaintText.setTextAlign(Paint.Align.CENTER); canvas.drawText(text, getWidth() / 2, baseline, mPaintText); &#125;&#125; 首先从颜色数组里根据 hash 取余得到背景颜色 然后画出背景圆 接下来就是写字 最后是对字居中的处理 /** * @param content 传入字符内容 * 只会取内容的第一个字符,如果是字母转换成大写 */public void setText(String content) &#123; if (content == null) &#123; content=\" \"; &#125; this.text = String.valueOf(content.toCharArray()[0]); this.text = text.toUpperCase(); charHash = this.text.hashCode(); // 重绘 invalidate();&#125; 这是暴露给外部的方法，我们也是在这里得到要画的字符。 使用在 gradle 依赖里添加: compile 'com.github.xcc3641:charavatarview:0.1' &lt;com.hugo.charavatarview.CharAvatarView android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:id=\"@+id/avatar\"/&gt; CharAvatarView mAvatarView;mAvatarView = (CharAvatarView) findViewById(R.id.avatar);mAvatarView.setText(\"谢三弟\"); 运行： 人生第一个自定义 View 就完成了。 上传到可以参考司机的这篇文章码农必知之上传开源库到 jcenter，配置好各种参数。以后更新版本就执行一行代码就行啦。 ./gradlew install // 只需要第一次执行./gradlew bintrayUpload 开源地址：GitHub 地址 额外阅读 讲解 Canvas 中的一些重要方法 教你步步为营掌握自定义 View"},{"title":"【校对】世界级Android测试开发流程（二）","date":"2016-02-24T14:00:07.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/【校对】世界级Android测试开发流程(二).html","permalink":"http://imxie.cc/hide/【校对】世界级Android测试开发流程(二).html","excerpt":"原文链接 : World-Class Testing Development Pipeline for Android - Part 2. 原文作者 : Karumi 译文出自 : 掘金翻译计划 译者 : markzhai 校对者: JustWe, Hugo Xie","text":"原文链接 : World-Class Testing Development Pipeline for Android - Part 2. 原文作者 : Karumi 译文出自 : 掘金翻译计划 译者 : markzhai 校对者: JustWe, Hugo Xie 在我们的上一篇博客文章，“世界级的Android测试开发流程（一）”，我们开始讨论一个Android的测试开发流程。我们讨论了一个软件工程师从开始写测试到找到测试开发的一些问题的演化过程。我们获得了以下结论，概括如下： 自动化测试是成功的软件开发的关键。 为了写特定类型的测试，可测试的代码是必须的。 一些开发者对测什么与怎么测一无所知，就开始写测试。 我们的测试的质量与可读性并不总是能达到预期。 一个测试开发流程对定义测什么与怎么测来说是必须的。 相应地，任何应用的测试关键部分是： 独立于框架或者库去测试业务逻辑。 测试服务器端的API集成。 在黑盒场景测试下，从用户角度写的的接收准则。 在这篇文章中，我们将会看到几个测试方法，它们覆盖了上述部分并保证了一个稳若盘石的测试开发流程。 独立于框架或者库去测试业务逻辑：至关重要的是检查业务逻辑是否确实实现了预定的产品需求。我们需要隔离想要测试的代码，模拟不同的初始场景，以设置运行时的一些组件的行为。接着，我们将会通过选择想要练习的部分来测试代码。一旦完成，我们需要检查软件状态在训练该测试主题后是否正确。 这个测试方法的关键是 依赖倒置原则。通过写依赖于抽象的代码，我们将可以把我们的软件分离为不同的层次。为了获得一个依赖的实例，我们需要从某个地方去请求它。或者，我们可以在实例被创建的时候获得它。我们软件的一部分要求我们创建代码来获取协作者的实例。在这些点，我们将会引入测试替身(Test Double)来模拟初始场景或编写不同行为来设计我们的测试。通过使用 测试替身，我们将能模拟生产环境代码的行为与状态。同时，它能帮助我们选择测试的范围（从根本上代表了要测试的代码的数量）。如果没有依赖倒置，所有类就需要各自去获得它们的依赖。从而导致类实现和依赖的实现相互耦合，进而无法引入测试替身来切断生产环境代码的执行流。 通常在构造中传递类依赖是最有效的应用依赖倒置的机制。该机制足够用来引入测试替身。在构造中传递类依赖会帮助我们创建实例来替代对应测试替身的依赖。尽管并不是强制的，记住服务定位器(Service Locator)或者依赖注入框架的用法对帮助减少样板代码以应用依赖倒置仍然很重要。 我们将会用一个具体的例子 (关于 我几个月前开始做的Android GameBoy模拟器 的测试) 来展示如何测试我们的业务需求。 以下测试有关于GameBoy内存管理单元和GameBoy BIOS执行。我们将会检查产品需求（硬件模拟）是否被正确实现。 public class MMUTest { private static final int MMU_SIZE = 65536; private static final int ANY_ADDRESS = 11; private static final byte ANY_BYTE_VALUE = 0x11; @Test public void shouldInitializeMMUFullOfZeros() { MMU mmu = givenAMMU(); assertMMUIsFullOfZeros(mmu); } @Test public void shouldFillMMUWithZerosOnReset() { MMU mmu = givenAMMU(); mmu.writeByte(ANY_ADDRESS, ANY_BYTE_VALUE); mmu.reset(); assertMMUIsFullOfZeros(mmu); } @Test public void shouldWriteBigBytesValuesAndRecoverThemAsOneWord() { MMU mmu = givenAMMU(); mmu.writeByte(ANY_ADDRESS, (byte) 0xFA); mmu.writeByte(ANY_ADDRESS +1, (byte) 0xFB); assertEquals(0xFBFA, mmu.readWord(ANY_ADDRESS)); } } 前三个测试是检查GameBoy MMU（内存管理单元）是否正确实现。成功的关键在于检查测试执行的最后MMU状态是否正确。所有的测试检查MMU是否被正确初始化。如果reset后，MMU被清理了，或者写了2个字节后和期望的词相等，则最后的读取是正确的。为了测试模拟器软件的这部分，我们缩小了测试范围，仅有一个类作为测试对象。 public class GameBoyBIOSExecutionTest { @Test public void shouldIndicateTheBIOSHasBeenLoadedUnlockingTheRomMapping() { GameBoy gameBoy = givenAGameBoy(); tickUntilBIOSLoaded(gameBoy); assertEquals(1, mmu.readByte(UNLOCK_ROM_ADDRESS) &amp; 0xFF); } @Test public void shouldPutTheNintendoLogoIntoMemoryDuringTheBIOSThirdStage() { GameBoy gameBoy = givenAGameBoy(); tickUntilThirdStageFinished(gameBoy); assertNintendoLogoIsInVRAM(); } private GameBoy givenAGameBoy() { z80 = new GBZ80(); mmu = new MMU(); gpu = new GPU(mmu); GameLoader gameLoader = new GameLoader(new FakeGameReader()); GameBoy gameBoy = new Gameboy(z80, mmu, gpu, gameLoader); return gameboy; } } 在这两个测试中，我们检查了跨越不同阶段的BIOS是否执行正确。在BIOS执行的最后，内存中具体位置的一个字节必须被初始化为具体的一个值。接着，在第三阶段的最后，任天堂的logo必须被读取到VRAM。我们决定扩大测试的范围，因为整个BIOS执行是任何模拟器开发的关键部分之一。关于该测试的主题是CPU，CPU指令集的部分（只包括BIOS执行相关的指令），以及MMU。为了检查执行的状态是否正确，我们必须在MMU状态上进行assert。一个能显著提升测试质量的关键就是检查执行最后的软件状态，而避免去验证和其他组件的交互。这是因为即便和你的组件交互正确，状态仍然可能错误。 知道这些测试的部分是独立的也很重要，像是CPU指令。 这些测试的另一个主要亮点是使用了测试替身，以模拟Android SDK使用相关的那些代码。在执行BIOS之前，GameBoy游戏必须被读取到GameBoy MMU里。然后，在测试期间，Android SDK将会变得不可用，作为一种变通方法，我们将不得不替换为从测试环境读取GameBoy rom。* 我们使用了依赖倒置原则不仅仅是为了隐藏实现细节或者定义边界，— 也是为了替代实际生产环境的AndroidGameReader为FakeGameReader，一个测试替身，*从而不依赖于框架和库去测试代码。这样，我们创建了一个隔离的测试环境，并调整了测试范围。 范围：调整测试范围是极其重要的。在写测试前，我们必须记住测试范围会帮助我们认识代码里的缺陷（取决于测试范围的大小）。简化的范围将会给我们更丰富的错误反馈，而大范围的测试则无法提供bug位置的准确信息。测试的粒度必须跟考虑中的测试范围一样小。 基础：写这些测试的基础很明确。我们需要写出在依赖倒置原则下可测试的代码，并结合mocking库使用测试框架。mocking库将会帮助我们创建模拟场景下的测试替身，或替换我们部分的生产代码。请注意这些框架和库的使用不是必须的，但我们推荐使用。 结果：这个方法的结果很有趣。在遵循依赖倒置原则后，我们可以独立于框架或库去测试我们的业务逻辑。我们可以创建一个具有可重复性的 隔离环境 来实现和设计测试。另外，我们可以简单地 选择需要测试的生产环境代码的量 并把它们替换为 测试替身来模拟行为和不同场景。 既然我们已经可以测试产品需求是否被正确实现，我们便需要继续致力于测试开发流程。下个我们要测试的是与被测试替身替换的外部组件的集成是否正确。这是我们将会在下一篇博客文章中回顾的东西，敬请期待！;) 参考： 世界级的Android测试开发流程（一）by Pedro Vicente Gómez Sánchez. http://www.slideshare.net/PedroVicenteGmezSnch/worldclass-testing-development-pipeline-for-android Android GameBoy 模拟器 GitHub Repository by Pedro Vicente Gómez Sánchez. https://github.com/pedrovgs/AndroidGameBoyEmulator 控制反转容器和依赖注入模式 by Martin Fowler. http://martinfowler.com/articles/injection.html 在野外的DIP by Martin Fowler.http://martinfowler.com/articles/dipInTheWild.html 测试替身 by Martin Fowler. http://www.martinfowler.com/bliki/TestDouble.html"},{"title":"【自整理】Android开发中的Tips","date":"2015-12-17T11:24:00.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/【自整理】Android开发中的Tips.html","permalink":"http://imxie.cc/hide/【自整理】Android开发中的Tips.html","excerpt":"本文是为了记录自己开发过程中遇到的坑和写过的可复用代码块。updata: 2015.12.17","text":"本文是为了记录自己开发过程中遇到的坑和写过的可复用代码块。updata: 2015.12.17 代码部分双击退出public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.getRepeatCount() == 0) &#123; if ((System.currentTimeMillis() - exitTime) &gt; 2000) &#123; Toast.makeText(this, &quot;再按一次退出程序&quot;, Toast.LENGTH_SHORT).show(); exitTime = System.currentTimeMillis(); &#125; else &#123; finish(); &#125; &#125; return false; &#125; 获取时间Calendar c = Calendar.getInstance();c.add(Calendar.DATE, -1);//获取昨天time = new SimpleDateFormat(&quot;yyyyMMdd&quot;).format(c.getTime()); [^ 最开始的时候自己不知道Calendar有这个方法，自己写获取昨天实在麻烦，因为需要考虑跨月和跨年] /** * 判断当前日期是星期几 * * @param pTime 修要判断的时间 * @return dayForWeek 判断结果 * @Exception 发生异常 */public static int dayForWeek(String pTime) throws Exception &#123; SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\"); Calendar c = Calendar.getInstance(); c.setTime(format.parse(pTime)); int dayForWeek = 0; if(c.get(Calendar.DAY_OF_WEEK) == 1)&#123; dayForWeek = 7; &#125;else&#123; dayForWeek = c.get(Calendar.DAY_OF_WEEK) - 1; &#125; return dayForWeek; &#125; 检测是否已经连接到网络//需要权限&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; 只关注是否联网：public boolean isNetworkConnected(Context context) &#123; if (context != null) &#123; ConnectivityManager mConnectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo mNetworkInfo = mConnectivityManager.getActiveNetworkInfo(); if (mNetworkInfo != null) &#123; return mNetworkInfo.isAvailable(); &#125; &#125; return false;&#125; WIFI或者Internet：ConnectivityManager con=(ConnectivityManager)getSystemService(Activity.CONNECTIVITY_SERVICE);boolean wifi=con.getNetworkInfo(ConnectivityManager.TYPE_WIFI).isConnectedOrConnecting();boolean internet=con.getNetworkInfo(ConnectivityManager.TYPE_MOBILE).isConnectedOrConnecting(); 发送短信public static void sendSms(Context context, String phoneNumber, String content) &#123; Uri uri = Uri.parse(&quot;smsto:&quot; + (TextUtils.isEmpty(phoneNumber) ? &quot;&quot; : phoneNumber)); Intent intent = new Intent(Intent.ACTION_SENDTO, uri); intent.putExtra(&quot;sms_body&quot;, TextUtils.isEmpty(content) ? &quot;&quot; : content); context.startActivity(intent); &#125; 唤醒屏幕并解锁public static void wakeUpAndUnlock(Context context)&#123; KeyguardManager km= (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE); KeyguardManager.KeyguardLock kl = km.newKeyguardLock(&quot;unLock&quot;); //解锁 kl.disableKeyguard(); //获取电源管理器对象 PowerManager pm=(PowerManager) context.getSystemService(Context.POWER_SERVICE); //获取PowerManager.WakeLock对象,后面的参数|表示同时传入两个值,最后的是LogCat里用的Tag PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_DIM_WAKE_LOCK,&quot;bright&quot;); //点亮屏幕 wl.acquire(); //释放 wl.release(); &#125; 需要添加权限：&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.DISABLE_KEYGUARD&quot; /&gt; 判断当前设备是否为手机public static boolean isPhone(Context context) &#123; TelephonyManager telephony = (TelephonyManager) context .getSystemService(Context.TELEPHONY_SERVICE); if (telephony.getPhoneType() == TelephonyManager.PHONE_TYPE_NONE) &#123; return false; &#125; else &#123; return true; &#125; &#125; 获取当前设备的IMEI，与上面的isPhone()一起使用@TargetApi(Build.VERSION_CODES.CUPCAKE) public static String getDeviceIMEI(Context context) &#123; String deviceId; if (isPhone(context)) &#123; TelephonyManager telephony = (TelephonyManager) context .getSystemService(Context.TELEPHONY_SERVICE); deviceId = telephony.getDeviceId(); &#125; else &#123; deviceId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID); &#125; return deviceId; &#125; 获取当前程序的版本号public static String getAppVersion(Context context) &#123; String version = &quot;0&quot;; try &#123; version = context.getPackageManager().getPackageInfo( context.getPackageName(), 0).versionName; &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; return version; &#125; 获取当前设备宽高，单位pxpublic static int getDeviceWidth(Context context) &#123; WindowManager manager = (WindowManager) context .getSystemService(Context.WINDOW_SERVICE); return manager.getDefaultDisplay().getWidth(); &#125; public static int getDeviceHeight(Context context) &#123; WindowManager manager = (WindowManager) context .getSystemService(Context.WINDOW_SERVICE); return manager.getDefaultDisplay().getHeight(); &#125; Retrofit 2.0//baseUrl=&quot;http://example/SaveImg/&quot;public interface imgApi &#123; @GET(&quot;DouBanGirl&quot;) Call&lt;Img&gt; getImg(@Query(&quot;date&quot;) String date);&#125;//假设传入date=20150101 最后实际访问的地址是：http://example/SaveImg/DouBanGirl?date=20150101这个地址拼接最开始的时候坑了自己很久，官方也没有仔细讲明白。 Jsoup自己还是习惯Python里的正则或者bs4进行匹配，Java里目前只接触了Jsoup，每次都要去查阅用法。最近查看Jsoup源码的时候好像发现Jsoup也是可以用正则匹配的。顺便说下当发现Android.text下的HTML.fromHtml()方法的时候，简直开心。//&lt;img class=&quot;xx&quot; title=&quot;xx&quot; alt=&quot;xx&quot; onerror=&quot;img_error(this);&quot; src=&quot;http://ww2.sinaimg.cn/bmiddle/xxx.jpg&quot;&gt;//目标是img标签中的src图片地址Document doc = Jsoup.parse(content);Elements elements = doc.select(&quot;img[src$=.jpg]&quot;);for (Element src : elements) &#123; Log.d(TAG, src.attr(&quot;abs:src&quot;));｝ 圆角+点击变色（非监听）ButtonAndroid中常常使用shape来定义控件的一些显示属性，今天看了一些shape的使用，对shape有了大体的了解，稍作总结：在android的project中新建一个drawable文件夹（此文件夹位于res下），存放定义了shape的.xml文件，然后在其他xml文件中引用，如，android:background=@drawable/**.xml&lt;shape&gt;&lt;!-- 实心 --&gt;&lt;solid android:color=\"#ff9d77\"/&gt;&lt;!-- 渐变 --&gt;&lt;gradientandroid:startColor=\"#ff8c00\"android:endColor=\"#FFFFFF\"android:angle=\"270\" /&gt;&lt;!-- 描边 --&gt;&lt;strokeandroid:width=\"2dp\"android:color=\"#dcdcdc\" /&gt;&lt;!-- 圆角 --&gt;&lt;cornersandroid:radius=\"2dp\" /&gt;&lt;!-- padding：Button里面的文字与Button边界的间隔 --&gt;&lt;paddingandroid:left=\"10dp\"android:top=\"10dp\"android:right=\"10dp\"android:bottom=\"10dp\" /&gt;&lt;/shape&gt; 组合起来&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_pressed=\"false\"&gt; &lt;shape&gt; &lt;!-- 填充的颜色 --&gt; &lt;solid android:color=\"@color/loginButtonColor\"/&gt; &lt;!-- 设置按钮的四个角为弧形 --&gt; &lt;!-- android:radius 弧形的半径 --&gt; &lt;corners android:radius=\"8dp\"/&gt; &lt;!-- padding：Button里面的文字与Button边界的间隔 --&gt; &lt;padding android:left=\"10dp\" android:top=\"10dp\" android:right=\"10dp\" android:bottom=\"10dp\"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:state_pressed=\"true\"&gt; &lt;shape&gt; &lt;!-- 填充的颜色 --&gt; &lt;solid android:color=\"@color/loginButtonColor\"/&gt; &lt;!-- 设置按钮的四个角为弧形 --&gt; &lt;!-- android:radius 弧形的半径 --&gt; &lt;corners android:radius=\"8dp\"/&gt; &lt;!-- padding：Button里面的文字与Button边界的间隔 --&gt; &lt;padding android:left=\"10dp\" android:top=\"10dp\" android:right=\"10dp\" android:bottom=\"10dp\"/&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/selector&gt; DP和PXpublic class DensityUtil &#123; /** * 根据手机的分辨率从 dp 的单位 转成为 px(像素) */ public static int dip2px(Context context, float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; /** * 根据手机的分辨率从 px(像素) 的单位 转成为 dp */ public static int px2dip(Context context, float pxValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125;&#125; 高斯模糊（配合Glide效果拔群）public class BlurImageview &#123; /** 水平方向模糊度 */ private static float hRadius = 25; /** 竖直方向模糊度 */ private static float vRadius = 25; /** 模糊迭代度 */ private static int iterations = 25; /** * 图片高斯模糊处理  */ public static Drawable BlurImages(Bitmap bmp, Context context) &#123; int width = bmp.getWidth(); int height = bmp.getHeight(); int[] inPixels = new int[width * height]; int[] outPixels = new int[width * height]; Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888); bmp.getPixels(inPixels, 0, width, 0, 0, width, height); for (int i = 0; i &lt; iterations; i++) &#123; blur(inPixels, outPixels, width, height, hRadius); blur(outPixels, inPixels, height, width, vRadius); &#125; blurFractional(inPixels, outPixels, width, height, hRadius); blurFractional(outPixels, inPixels, height, width, vRadius); bitmap.setPixels(inPixels, 0, width, 0, 0, width, height); Drawable drawable = new BitmapDrawable(context.getResources(), bitmap); return drawable; &#125; /** * 图片高斯模糊算法 */ public static void blur(int[] in, int[] out, int width, int height, float radius) &#123; int widthMinus1 = width - 1; int r = (int) radius; int tableSize = 2 * r + 1; int divide[] = new int[256 * tableSize]; for (int i = 0; i &lt; 256 * tableSize; i++) &#123; divide[i] = i / tableSize; &#125; int inIndex = 0; for (int y = 0; y &lt; height; y++) &#123; int outIndex = y; int ta = 0, tr = 0, tg = 0, tb = 0; for (int i = -r; i &lt;= r; i++) &#123; int rgb = in[inIndex + clamp(i, 0, width - 1)]; ta += (rgb &gt;&gt; 24) &amp; 0xff; tr += (rgb &gt;&gt; 16) &amp; 0xff; tg += (rgb &gt;&gt; 8) &amp; 0xff; tb += rgb &amp; 0xff; &#125; for (int x = 0; x &lt; width; x++) &#123; out[outIndex] = (divide[ta] &lt;&lt; 24) | (divide[tr] &lt;&lt; 16) | (divide[tg] &lt;&lt; 8) | divide[tb]; int i1 = x + r + 1; if (i1 &gt; widthMinus1) i1 = widthMinus1; int i2 = x - r; if (i2 &lt; 0) i2 = 0; int rgb1 = in[inIndex + i1]; int rgb2 = in[inIndex + i2]; ta += ((rgb1 &gt;&gt; 24) &amp; 0xff) - ((rgb2 &gt;&gt; 24) &amp; 0xff); tr += ((rgb1 &amp; 0xff0000) - (rgb2 &amp; 0xff0000)) &gt;&gt; 16; tg += ((rgb1 &amp; 0xff00) - (rgb2 &amp; 0xff00)) &gt;&gt; 8; tb += (rgb1 &amp; 0xff) - (rgb2 &amp; 0xff); outIndex += height; &#125; inIndex += width; &#125; &#125; /** * 图片高斯模糊算法  */ public static void blurFractional(int[] in, int[] out, int width, int height, float radius) &#123; radius -= (int) radius; float f = 1.0f / (1 + 2 * radius); int inIndex = 0; for (int y = 0; y &lt; height; y++) &#123; int outIndex = y; out[outIndex] = in[0]; outIndex += height; for (int x = 1; x &lt; width - 1; x++) &#123; int i = inIndex + x; int rgb1 = in[i - 1]; int rgb2 = in[i]; int rgb3 = in[i + 1]; int a1 = (rgb1 &gt;&gt; 24) &amp; 0xff; int r1 = (rgb1 &gt;&gt; 16) &amp; 0xff; int g1 = (rgb1 &gt;&gt; 8) &amp; 0xff; int b1 = rgb1 &amp; 0xff; int a2 = (rgb2 &gt;&gt; 24) &amp; 0xff; int r2 = (rgb2 &gt;&gt; 16) &amp; 0xff; int g2 = (rgb2 &gt;&gt; 8) &amp; 0xff; int b2 = rgb2 &amp; 0xff; int a3 = (rgb3 &gt;&gt; 24) &amp; 0xff; int r3 = (rgb3 &gt;&gt; 16) &amp; 0xff; int g3 = (rgb3 &gt;&gt; 8) &amp; 0xff; int b3 = rgb3 &amp; 0xff; a1 = a2 + (int) ((a1 + a3) * radius); r1 = r2 + (int) ((r1 + r3) * radius); g1 = g2 + (int) ((g1 + g3) * radius); b1 = b2 + (int) ((b1 + b3) * radius); a1 *= f; r1 *= f; g1 *= f; b1 *= f; out[outIndex] = (a1 &lt;&lt; 24) | (r1 &lt;&lt; 16) | (g1 &lt;&lt; 8) | b1; outIndex += height; &#125; out[outIndex] = in[width - 1]; inIndex += width; &#125; &#125; public static int clamp(int x, int a, int b) &#123; return (x &lt; a) ? a : (x &gt; b) ? b : x; &#125;&#125; 如何使用？ Glide.with(MainActivity.this).load(R.drawable.back).asBitmap().into(new SimpleTarget&lt;Bitmap&gt;() &#123; @Override public void onResourceReady(Bitmap resource, GlideAnimation&lt;? super Bitmap&gt; glideAnimation) &#123; mImageView.setBackground(BlurImageview.BlurImages(resource, MainActivity.this)); &#125; &#125;);"},{"title":"就看天气V2.0-RxAndroid+Retrofit+Glide+Matrial Design Weather App","date":"2016-02-21T10:17:33.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/就看天气V2-0.html","permalink":"http://imxie.cc/hide/就看天气V2-0.html","excerpt":"最初上线是在2015年10月，是自己第一个较为成熟的应用，开发完之后刚好答了知乎这篇如何自学Android编程 但是因为代码确实写的很烂，所以决定全部重构代码全新风格的展示就看天气Ver2.0. 当然自己也在学习之中，如果发现有任何问题和建议，随时欢迎Email或者开Issues 开源不易，希望能给个Star鼓励 项目地址：https://github.com/xcc3641/SeeWeather 项目主页发布issue: https://github.com/xcc3641/SeeWeather/issues 本项目为开源项目,技术交流可以通过邮箱联系: Hugo3641@gmail.com","text":"最初上线是在2015年10月，是自己第一个较为成熟的应用，开发完之后刚好答了知乎这篇如何自学Android编程 但是因为代码确实写的很烂，所以决定全部重构代码全新风格的展示就看天气Ver2.0. 当然自己也在学习之中，如果发现有任何问题和建议，随时欢迎Email或者开Issues 开源不易，希望能给个Star鼓励 项目地址：https://github.com/xcc3641/SeeWeather 项目主页发布issue: https://github.com/xcc3641/SeeWeather/issues 本项目为开源项目,技术交流可以通过邮箱联系: Hugo3641@gmail.com 简介就看天气——是一款遵循Material Design风格的只看天气的APP。无流氓权限，无自启，xxx，用最少的权限做最优的体验。 卡片展现（当前天气情况，未来几小时天气情况，生活建议，一周七天概况） 补全城市（第一版本因为自己偷懒所以城市有缺陷对不起各位） 自动定位 缓存数据，减少网络请求，保证离线查看 内置两套图标（设置里更改） 彩蛋（自动夜间状态） 权限说明 &lt;!--用于进行网络定位--&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt;&lt;!--用于访问GPS定位--&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt;&lt;!--获取运营商信息，用于支持提供运营商信息相关的接口--&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;&lt;!--用于访问wifi网络信息，wifi信息会用于进行网络定位--&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;&lt;!--这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot;/&gt;&lt;!--用于访问网络，网络定位需要上网--&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&lt;!--用于读取手机当前的状态--&gt;&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;&lt;!--写入扩展存储，向扩展卡写入数据，用于写入缓存定位数据--&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt; 版本更新&amp;&amp;下载地址Fir.im: http://fir.im/seeWeather 豌豆荚：http://www.wandoujia.com/apps/com.xiecc.seeWeather 魅族应用中心： http://developer.meizu.com/console/apps/detail/6530883 酷安市场：http://www.coolapk.com/apk/com.xiecc.seeWeather v2.0 重构代码，全新UI，升级体验 就看天气——是一款遵循Material Design风格的只看天气的APP。无流氓权限，无自启，xxx，用最少的权限做最优的体验。 卡片展现（当前天气情况，未来几小时天气情况，生活建议，一周七天概况） 彩蛋（自动夜间状态） 补全城市（第一版本因为自己偷懒所以城市有缺陷对不起各位） 缓存数据，减少网络请求，保证离线查看 内置两套图标（设置里更改） v1.1 加固 兼容更多系统版本 v1.0 就看天气V1.0 @图片和信息来源于网络，侵权删 TODO这学期有点忙，需要花时间巩固基础，准备面试，但是自己还是会抽空尽快做出这些功能的，谢谢大家理解和支持 [ ] 桌面小部件 [ ] 通知栏提醒 [ ] 更好，更多的天气ICONS [ ] 管理城市（多城市选择） [x] 自动定位 [ ] 自由定制的Item界面 项目公开 API天气数据来源于：和风天气城市信息来源于：CSDN地理定位服务： 高德地图 开源技术 Rxjava RxAndroid Retrofit GLide ASimpleCache 简单介绍代码网络就看天气的网络部分的支持是用RxJava+RxAndroid+Retrofit+Gson再加上ACache缓存/** * &lt;p/&gt; * 首先从本地缓存获取数据 * if 有 * 更新UI * else * 直接进行网络请求，更新UI并保存在本地 */ private void fetchData() &#123; observer = new Observer&lt;Weather&gt;() &#123; //节约篇幅，已省略 ... &#125;; fetchDataByCache(observer); &#125; /** * 从本地获取 */ private void fetchDataByCache(Observer&lt;Weather&gt; observer) &#123; Weather weather = null; try &#123; weather = (Weather) aCache.getAsObject(&quot;WeatherData&quot;); &#125; catch (Exception e) &#123; Log.e(TAG, e.toString()); &#125; if (weather != null) &#123; //distinct去重 Observable.just(weather).distinct().subscribe(observer); &#125; else &#123; fetchDataByNetWork(observer); &#125; &#125; /** * 从网络获取 */ private void fetchDataByNetWork(Observer&lt;Weather&gt; observer) &#123; String cityName = mSetting.getString(Setting.CITY_NAME, &quot;重庆&quot;); RetrofitSingleton.getApiService(this) .mWeatherAPI(cityName, key) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) ////节约篇幅，已省略 ... &#125; RecycerVIew展示就像洪洋说的一样 整体上看RecyclerView架构，提供了一种插拔式的体验，高度的解耦，异常的灵活，通过设置它提供的不同LayoutManager，ItemDecoration , ItemAnimator实现令人瞠目的效果。 该项目中用到RecyclerView中级的用法是根据itemType展示不同的布局，这就是主页核心的代码了。@Override public int getItemViewType(int position) &#123; if (position == TYPE_ONE) &#123; //标识 ... &#125; return super.getItemViewType(position); &#125;@Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if (viewType == TYPE_ONE) &#123; //绑定 ... &#125; &#125; &#125;@Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; if (holder instanceof NowWeatherViewHolder) &#123; //更新布局 .... &#125;&#125; 截图 感谢感谢开源，学习到了前辈们优秀的代码 @张鸿洋 @扔物线 @drakeet @代码家 @程序亦非猿 @小鄧子 @Jude95 特别感谢简书猿圈 关于作者 简书：http://www.jianshu.com/users/3372b4a3b9e5/latest_articles 知乎：https://www.zhihu.com/people/xcc3641.github.io 微博：http://weibo.com/xcc3641 个人博客： http://IMXIE.CC 请我喝杯咖啡 LICENSECopyright 2016 HugoXie Licensed under the Apache License, Version 2.0 (the \\”License\\”) you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \\”AS IS\\” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 图片来源于网络，版权属于原作者。"},{"title":"Hexo 常用命令以及配置","date":"2015-11-15T01:32:01.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/简单介绍hexo.html","permalink":"http://imxie.cc/hide/简单介绍hexo.html","excerpt":"Hexo 常用命令以及配置","text":"Hexo 常用命令以及配置 命令常用命令hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #将.deploy目录部署到GitHub 常用复合命令hexo deploy -ghexo server -g 简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 目录内容默认目录结构.├── .deploy├── public├── scaffolds├── scripts├── source| ├── _drafts| └── _posts├── themes├── _config.yml└── package.json .deploy：执行hexo deploy命令部署到GitHub上的内容目录public：执行hexo generate命令，输出的静态网页内容目录scaffolds：layout模板文件目录，其中的md文件可以添加编辑scripts：扩展脚本目录，这里可以自定义一些javascript脚本source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。 _drafts：草稿文章_posts：发布文章themes：主题文件目录_config.yml：全局配置文件，大多数的设置都在这里package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮 接下来是重头戏_config.yml，做个简单说明：# Site #整站的基本信息title: IM XIE #网站标题subtitle: 代码如诗 #网站副标题description: #网站描述，给搜索引擎用的，在生成html中的head-&gt;meta中可看到author: Hugo Xie #网站作者，在下方显示email: Hugo3641@gmail.com #联系邮箱language: zh-Hans #语言# URL #域名和文件结构## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://ibruce.info #你的域名root: /permalink: :year/:month/:day/:title/tag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/code# Writing #写文章选项new_post_name: :title.md # File name of new postsdefault_layout: post #默认layout方式auto_spacing: false # Add spaces between asian characters and western characterstitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabmax_open_file: 100multi_thread: truefilename_case: 0render_drafts: falsehighlight: #代码高亮 enable: true #是否启用 line_number: false #是否显示行号 tab_replace:# Category &amp; Tag #分类与标签default_category: uncategorized # defaultcategory_map:tag_map:# Archives #存档，这里的说明好像不对。全部选择1，这个选项与主题中的选项有时候会有冲突## 2: Enable pagination## 1: Disable pagination## 0: Fully Disablearchive: 1category: 1tag: 1# Server #本地服务参数## Hexo uses Connect as a server## You can customize the logger format as defined in## http://www.senchalabs.org/connect/logger.htmlport: 4000logger: truelogger_format:# Date / Time format #日期显示格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: MMM D YYYYtime_format: H:mm:ss# Pagination #分页设置## Set per_page to 0 to disable paginationper_page: 10 #每页10篇文章pagination_dir: page# Disqus #社会化评论disqus，我使用多说，在主题中配置disqus_shortname:# Extensions #插件，暂时未安装插件## Plugins: https://github.com/tommy351/hexo/wiki/Plugins## Themes: https://github.com/tommy351/hexo/wiki/Themes## 主题theme: modernist # raytaylorism # pacman # modernist # lightexclude_generator:# Deployment #部署## Docs: http://zespia.tw/hexo/docs/deploy.htmldeploy: type: git repository: https://github.com/xcc3641/xcc3641.github.io branch: master #你的GitHub Pages仓库 修改局部页面页面展现的全部逻辑都在每个主题中控制，源代码在hexo\\themes\\你使用的主题\\中，以next主题为例：.├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #中文语言├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制| └── _widget #小挂件的布局，页面下方小挂件的控制├── source #源码| ├── css #css源码 | | ├── _base #*.styl基础css| | ├── _partial #*.styl局部css| | ├── fonts #字体| | ├── images #图片| | └── style.styl #*.styl引入需要的css源码| ├── fancybox #fancybox效果源码| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 如果你需要修改头部，直接修改hexo\\themes\\modernist\\layout_partial\\header.ejs，比如头上加个搜索框：&lt;div&gt;&lt;form class=&quot;search&quot; action=&quot;//google.com/search&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;input type=&quot;search&quot; name=&quot;q&quot; id=&quot;search&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot; autocapitalize=&quot;off&quot; maxlength=&quot;20&quot; placeholder=&quot;Search&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;q&quot; value=&quot;site:&lt;%- config.url.replace(/^https?:\\/\\//, &apos;&apos;) %&gt;&quot;&gt;&lt;/form&gt;&lt;/div&gt; 将如上代码加入即可，您需要修改css以便这个搜索框比较美观。 再如，你要修改页脚版权信息，直接编辑hexo\\themes\\next\\layout_partial\\footer.ejs。同理，你需要修改css，直接去修改对应位置的styl文件。 “不蒜子”计数插件普通用户只需两步走：一行脚本+一行标签，搞定一切。追求极致的用户可以进行任意DIY。 要使用不蒜子必须在页面中引入busuanzi.js，目前最新版如下。&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 不蒜子可以给任何类型的个人站点使用，如果你是用的hexo，打开themes/你的主题/layout/_partial/footer.ejs添加上述脚本即可，当然你也可以添加到 header 中。 显示站点总访问量 要显示站点总访问量，复制以下代码添加到你需要显示的位置。有两种算法可选： 算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 如果你是用的hexo，打开themes/你的主题/layout/_partial/footer.ejs添加即可。 RSS 链接编辑 主题配置文件，将 rss 字段设置为： rss: false，这将会禁用Feed链接。rss:，当值为空的时候，默认会使用站点的 Feed 链接。在此之前需要使用 hexo-generator-feed 插件生成 Feed。 # You can configure this plugin in _config.yml.feed: type: atom path: atom.xml limit: 20 hub: 依照 hexo-generator-feed 插件的安装说明进行 Feed 生成，当配件配置完毕后，主题将自动显示 Feed 链接。 写文章执行new命令，生成指定名称的文章至hexo\\source\\_posts\\postName.md。hexo new [layout] &quot;postName&quot; #新建文章 其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:--- 我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:tags:--- postName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。 fancybox可能有人对这个 Reading 页面中图片的 fancybox 效果感兴趣，这个是怎么做的呢。很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片：layout: phototitle: xxxdate: 2085-01-16 07:33:44tags: [hexo]photos:- http:xxx.jpg- http:xxx.jpg 【注】经过测试，文件头上的layout: photo可以省略。 不想每次都手动添加怎么办？同样的，打开您的hexo\\scaffolds\\photo.md layout: &#123; &#123; layout &#125; &#125;title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:photos:---- 然后每次可以执行带layout的new命令生成照片文章：hexo new photo &quot;photoPostName&quot; #新建照片文章"},{"title":"面试问题整理（Java网络版本）","date":"2015-11-10T14:14:07.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/面试问题整理（Java网络版本）.html","permalink":"http://imxie.cc/hide/面试问题整理（Java网络版本）.html","excerpt":"","text":"JavaSE九种基本数据类型的大小，以及他们的封装类Java提供了一组基本数据类型，包括boolean, byte, char, short, int, long, float, double, void. 同时，java也提供了这些类型的封装类，分别为Boolean, Byte, Character, Short, Integer, Long, Float, Double, Void。 既然提供了基本类型，为什么还要使用封装类呢？ 某些情况下，数据必须作为对象出现,此时必须使用封装类来将简单类型封装成对象。 比如，如果想使用List来保存数值，由于List中只能添加对象，因此我们需要将数据封装到封装类中再加入List。在JDK5.0以后可以自动封包，可以简写成list.add(1)的形式，但添加的数据依然是封装后的对象。 另外，有些情况下，我们也会编写诸如func(Object o)的这种方法，它可以接受所有类型的对象数据，但对于简单数据类型，我们则必须使用封装类的对象。 某些情况下，使用封装类使我们可以更加方便的操作数据。比如封装类具有一些基本类型不具备的方法，比如valueOf(), toString(), 以及方便的返回各种类型数据的方法，如Integer的shortValue(), longValue(), intValue()等。 基本数据类型与其对应的封装类由于本质的不同，具有一些区别： 基本数据类型只能按值传递，而封装类按引用传递。 基本类型在堆栈中创建；而对于对象类型，对象在堆中创建，对象的引用在堆栈中创建。基本类型由于在堆栈中，效率会比较高，但是可能会存在内存泄漏的问题。 Switch能否用string做参数？在 Java 7之前，switch 只能支持 byte、short、char、int或者其对应的封装类以及 Enum 类型。在 Java 7中，String支持被加上了。switch (ctrType) &#123; case \"01\" : exceptionType = \"读FC参数数据\"; break; case \"03\" : exceptionType = \"读FC保存的当前表计数据\"; break; default: exceptionType = \"未知控制码：\"+ctrType; &#125; 其中ctrType为字符串。 如在jdk 7 之前的版本使用, 会提示如下错误： Cannot switch on a value of type String for source level below 1.7. Only convertible int values or enum variables are permitted 意为jdk版本太低，不支持。 equals与==的区别总之：“==”比较的是值【变量(栈)内存中存放的对象的(堆)内存地址】equal用于比较两个对象的值是否相同【不是比地址】 【特别注意】Object类中的 equals方法和 双等号是一样的，没有区别，而String类，Integer类等等一些类，是重写了equals方法，才使得equals和“==”不同。 所以，当自己创建类时，自动继承了Object的equals方法，要想实现不同的等于比较，必须重写equals方法。 双等比equal运行速度快,因为”==”只是比较引用. Object有哪些公用方法？ protected Object clone()创建并返回此对象的一个副本。 boolean equals(Object obj)指示其他某个对象是否与此对象“相等”。 protected void finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 Class&lt;?&gt; getClass()返回此 Object 的运行时类。 int hashCode()返回该对象的哈希码值。 void notify()唤醒在此对象监视器上等待的单个线程。 void notifyAll()唤醒在此对象监视器上等待的所有线程。 String toString()返回该对象的字符串表示。 void wait()在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。 void wait(long timeout)在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。void wait(long timeout, int nanos) Java中四种引用（强、软、弱、虚）强引用(StrongReference)强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 软引用(SoftReference)如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。 弱引用(WeakReference)弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 虚引用(PhantomReference)“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。 总结WeakReference与SoftReference都可以用来保存对象的实例引用，这两个类与垃圾回收有关。WeakReference是弱引用，其中保存的对象实例可以被GC回收掉。这个类通常用于在某处保存对象引用，而又不干扰该对象被GC回收，通常用于Debug、内存监视工具等程序中。因为这类程序一般要求即要观察到对象，又不能影响该对象正常的GC过程。最近在JDK的Proxy类的实现代码中也发现了Weakrefrence的应用，Proxy会把动态生成的Class实例暂存于一个由Weakrefrence构成的Map中作为Cache。 SoftReference是强引用，它保存的对象实例，除非JVM即将OutOfMemory，否则不会被GC回收。这个特性使得它特别适合设计对象Cache。对于Cache，我们希望被缓存的对象最好始终常驻内存，但是如果JVM内存吃紧，为了不发生OutOfMemoryError导致系统崩溃，必要的时候也允许JVM回收Cache的内存，待后续合适的时机再把数据重新Load到Cache中。这样可以系统设计得更具弹性。 Hashcode的作用HashCode的官方文档定义： hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。 hashCode 的常规协定是：在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。 以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。 实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。 以上这段官方文档的定义，我们可以抽出成以下几个关键点： hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的； 如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同； 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点； 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。 再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。以下这段话是从别人帖子回复拷贝过来的： 1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有例如内存中有这样的位置0 1 2 3 4 5 6 7 而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。但如果用hashcode那就会使效率提高很多。 我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。 也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。 那么。重写了equals()，为什么还要重写hashCode()呢？想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊 ArrayList、LinkedList、Vector的区别 ArrayList 是一个可改变大小的数组.当更多的元素加入到ArrayList中时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问,因为ArrayList本质上就是一个数组. LinkedList 是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.当然,这些对比都是指数据量很大或者操作很频繁的情况下的对比,如果数据和运算量很小,那么对比将失去意义. Vector 和ArrayList类似,但属于强同步类。如果你的程序本身是线程安全的(thread-safe,没有在多个线程之间共享同一个集合/对象),那么使用ArrayList是更好的选择。 Vector和ArrayList在更多元素添加进来时会请求更大的空间。Vector每次请求其大小的双倍空间，而ArrayList每次对size增长50%. 而 LinkedList 还实现了 Queue 接口,该接口比List提供了更多的方法,包括 offer(),peek(),poll()等.注意: 默认情况下ArrayList的初始容量非常小,所以如果可以预估数据量的话,分配一个较大的初始值属于最佳实践,这样可以减少调整大小的开销。 Finalfinal是java的关键字，它所表示的是“这部分是无法修改的”。不想被改变的原因有两个：效率、设计。使用到final的有三种情况：数据、方法、类。 基本数据类型不可变的是其内容，而引用数据类型不可变的是 其引用，引用所指定的对象内容是可变的。 Final对象里的内容是可变的。"},{"title":"Android 基础 -- 生命周期和启动模式实践总结","date":"2016-07-21T06:14:01.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/Activity-lifecycle-launchmode.html","permalink":"http://imxie.cc/hide/Activity-lifecycle-launchmode.html","excerpt":"Activity / Fragment 的生命周期是每个 Android 开发者最最基础的知识点。所以特别有必要自己整理一番。总看别人博客和书上的死知识，还不如自己动手实践，然后输出要印象深刻，理解透彻。","text":"Activity / Fragment 的生命周期是每个 Android 开发者最最基础的知识点。所以特别有必要自己整理一番。总看别人博客和书上的死知识，还不如自己动手实践，然后输出要印象深刻，理解透彻。 Activity 生命周期 正常情况下的生命周期分析 异常状态下的生命周期 Fragment 普通的 Fragment ViewPager 中的 Fragment 启动模式 Activity 的四种启动模式 具体实践 参考文档 Activity 生命周期正常情况下的生命周期分析 针对一个特定的 Activity ，第一次启动，回调如下：onCreate —-&gt; onStart —-&gt; onResume Log 日志D/KLog: (MainActivity.java:19) onCreateD/KLog: (MainActivity.java:44) onStartD/KLog: (MainActivity.java:62) onResume 切换回到桌面的时候，回调如下：onPause —-&gt; onStop Log 日志D/KLog: (MainActivity.java:50) onPauseD/KLog: (MainActivity.java:68) onStop Back 键退出的话，最后会 onDestroy 启动一个新的 Activity , 我们看看两个 Activity 的生命周期： Log 日志D/KLog: (MainActivity.java:50) onPauseD/KLog: (OtherActivity.java:25) onCreateD/KLog: (OtherActivity.java:31) onStartD/KLog: (OtherActivity.java:49) onResumeD/KLog: (MainActivity.java:68) onStop可以得到顺序是：onPause(A) —-&gt; onCreate(B) —-&gt; onStart(B) —-&gt; onResume(B) —-&gt; onStop(A) 这个时候我们 Back 回到第一个 Activity 时发生的回调： Log 日志D/KLog: (OtherActivity.java:37) onPauseD/KLog: (MainActivity.java:56) onRestartD/KLog: (MainActivity.java:44) onStartD/KLog: (MainActivity.java:62) onResumeD/KLog: (OtherActivity.java:55) onStopD/KLog: (OtherActivity.java:61) onDestroy可以得到顺序是： onPause(B) —-&gt; onRestart(A) —-&gt; onStart(A) —-&gt; onResume(A) —-&gt; onStop(B) —-&gt; onDestroy(B) 如果我在 B Activity 中的 onCreate 回调中直接 finish()： Log 日志D/KLog: (MainActivity.java:50) onPauseD/KLog: (OtherActivity.java:25) onCreateD/KLog: (MainActivity.java:62) onResumeD/KLog: (OtherActivity.java:62) onDestroy我们发现 B Activity 只会执行 onCreate 和 onDestroy。 接下来我们启动一个特殊的 Activity （半透明或者对话框样式）到关闭它： Log 日志D/MainActivity: onPauseD/DialogActivity: onCreateD/DialogActivity: onStartD/DialogActivity: onResumeD/DialogActivity: onPauseD/MainActivity: onResumeD/DialogActivity: onStopD/DialogActivity: onDestroy 在正常使用应用的过程中，前台 Activity 有时会被其他导致 Activity 暂停的可视组件阻挡。 例如，当半透明 Activity 打开时（比如对话框样式中的 Activity ），上一个 Activity 会暂停。 只要 Activity 仍然部分可见但目前又未处于焦点之中，它会一直暂停。 问题：如果是启动一个普通的 Dialog ，Activity 的会执行 onPause 吗？ 答案是不会的，我们可以这样理解，普通的 dialog 是依附在本 Activity 的，相当于是一个整体，所以它本身的焦点也是属于 Activity 的。故不会调用 onPause 。 异常状态下的生命周期 onSaveInstanceState 方法只会出现在 Activity 被异常终止的情况下，它的调用时机是在 onStop 之前，它和 onPause 方法没有既定的时序关系，可能在它之前，也可能在它之后。当 Activity 被重新创建的时候， onRestoreInstanceState 会被回调，它的调用时机是 onStart 之后。系统只会在 Activity 即将被销毁并且有机会重新显示的情况下才会去调用 onSaveInstanceState 方法。当 Activity 在异常情况下需要重新创建时，系统会默认为我们保存当前 Activity 的视图结构，并且在 Activity 重启后为我们恢复这些数据，比如文本框中用户输入的数据、listview 滚动的位置等，这些 view 相关的状态系统都会默认为我们恢复。具体针对某一个 view 系统能为我们恢复哪些数据可以查看 view 的源码中的 onSaveInstanceState 和 onRestoreInstanceState 方法。 Demo 代码：@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); KLog.d(getClass().getSimpleName(),\"onSaveInstanceState\"); outState.putString(STATE, \"test\");&#125;@Overrideprotected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); KLog.d(getClass().getSimpleName(),\"[onRestoreInstanceState]: \" + savedInstanceState.getString(STATE));&#125; 为了方便我们旋转下屏幕来异常终止 Activity : Log 日志D/MainActivity: onPauseD/MainActivity: onSaveInstanceStateD/MainActivity: onStopD/MainActivity: onDestroyD/MainActivity: onCreateD/MainActivity: onStartD/MainActivity: [onRestoreInstanceState]: testD/MainActivity: onResume 摘自 Android 开发者艺术探索 一书： 关于保存和恢复 View 的层次结构，系统工作流程是： Activity 异常终止, Activity 调用 onSaveInstanceState 去保存数据，然后 Activity 会委托 Windows 去保存数据，接着 Window 再委托它上面的顶层容器去保存数据。顶层容器是一个 ViewGroup ，一般来说它很可能是 DectorView ，最后顶层容器再去通知它的子元素保存数据。（这是一种委托思想，上层委托下层，父容器委托子元素去处理事情，如 View 的绘制过程，事件分发都是采用类似的思想） Fragment普通的 Fragment 从图可以看出，Fragment 生命周期大部分的状态与 Activity 相似，特殊的是 onAttach() —— 当 Fragment 被加入到 Activity 时调用(在这个方法中可以获得所在的 Activity ). onCreateView() —— 当 Activity 要得到 Fragment 的 Layout 时，调用此方法，Fragment 在其中创建自己的 Layout (界面)。 onActivityCreated() —— 当 Activity 的 onCreated() 方法返回后调用此方法 onDestroyView() —— 当 Fragment 中的视图被移除的时候，调用这个方法。 onDetach() —— 当 Fragment 和 Activity 分离的时候，调用这个方法。 ViewPager 中的 Fragment我们开发中经常会用到 ViewPager + Fragment 组合的形式来完成特定的需求。本身 Fragment 生命周期就比 Activity 要复杂很多，当它在 ViewPager 中又是怎么回调呢？ 我先给 ViewPager 加入三个 Fragment: viewPager = (ViewPager) findViewById(R.id.viewpager);fragmentList.add(new OneTextFragment());fragmentList.add(new TwoTextFragment());fragmentList.add(new ThreeTextFragment());viewPager.setAdapter(new FtAdapter(getSupportFragmentManager(), fragmentList)); 启动这个 Activity 的日志如下： D/ViewPagerHostActivity: onCreateD/ViewPagerHostActivity: onStartD/ViewPagerHostActivity: onResumeD/OneTextFragment: onAttachD/OneTextFragment: onCreateD/TwoTextFragment: onAttachD/TwoTextFragment: onCreateD/TwoTextFragment: onActivityCreatedD/OneTextFragment: onActivityCreatedD/OneTextFragment: onStartD/OneTextFragment: onResumeD/TwoTextFragment: onStartD/TwoTextFragment: onResume 我们发现启动后，有两个 Fragment(one,two) 被创建，为什么会创建两个？这个问题我们留着后面说。 当 Activity 进入后台： D/ViewPagerHostActivity: onPauseD/ViewPagerHostActivity: onSaveInstanceStateD/TwoTextFragment: onStopD/OneTextFragment: onStopD/ViewPagerHostActivity: onStop 当 Activity 返回前台：D/ViewPagerHostActivity: onRestartD/TwoTextFragment: onStartD/OneTextFragment: onStartD/ViewPagerHostActivity: onStartD/ViewPagerHostActivity: onResumeD/TwoTextFragment: onResumeD/OneTextFragment: onResume 当 Activity 销毁：D/ViewPagerHostActivity: onPauseD/TwoTextFragment: onStopD/OneTextFragment: onStopD/ViewPagerHostActivity: onStopD/TwoTextFragment: onDestroyViewD/TwoTextFragment: onDestroyD/TwoTextFragment: onDetachD/OneTextFragment: onDestroyViewD/OneTextFragment: onDestroyD/OneTextFragment: onDetachD/ViewPagerHostActivity: onDestroy 滑动一页：D/ThreeTextFragment: onAttachD/ThreeTextFragment: onCreateD/ThreeTextFragment: onActivityCreatedD/ThreeTextFragment: onStartD/ThreeTextFragment: onResume 当前显示的页面是 TwoTextFragment 然后 ThreeTextFragment 也已经创建好了。 再滑动一页：D/OneTextFragment: onStopD/OneTextFragment: onDestroyView 当前显示的页面是 ThreeTextFragment ，我们发现 OneTextFragment 已经销毁。 我们可以得到默认状态下的 ViewPager 会缓存 1 个 Fragment，相当于有两个 Fragment 是创建状态。当我们增加一行代码：viewPager.setOffscreenPageLimit(2); 当 Activity 创建时的生命周期：D/ViewPagerHostActivity: onCreateD/ViewPagerHostActivity: onStartD/ViewPagerHostActivity: onResumeD/OneTextFragment: onAttachD/OneTextFragment: onCreateD/TwoTextFragment: onAttachD/TwoTextFragment: onCreateD/ThreeTextFragment: onAttachD/ThreeTextFragment: onCreateD/TwoTextFragment: onActivityCreatedD/OneTextFragment: onActivityCreatedD/OneTextFragment: onStartD/OneTextFragment: onResumeD/TwoTextFragment: onStartD/TwoTextFragment: onResumeD/ThreeTextFragment: onStartD/ThreeTextFragment: onResume 三个 Fragment 都创建好了，并且左右切换不会走任何生命周期（虽然是废话）。 setOffscreenPageLimit 源码： public void setOffscreenPageLimit(int limit) &#123; if (limit &lt; DEFAULT_OFFSCREEN_PAGES) &#123; Log.w(TAG, \"Requested offscreen page limit \" + limit + \" too small; defaulting to \" + DEFAULT_OFFSCREEN_PAGES); limit = DEFAULT_OFFSCREEN_PAGES; &#125; if (limit != mOffscreenPageLimit) &#123; mOffscreenPageLimit = limit; populate(); &#125;&#125; 通过源码我们可以知道，ViewPager 的缓存的默认值和最小值是 1。 启动模式Activity 的四种启动模式 Standard：标准模式，一调用 startActivity() 方法就会产生一个新的实例。 SingleTop: 来了 intent, 每次都创建新的实例，仅一个例外：当栈顶的activity 恰恰就是该activity的实例（即需要创建的实例)时，不再创建新实例。这解决了栈顶复用问题 SingleTask: 来了 intent 后，检查栈中是否存在该 activity的实例，如果存在就把 intent 发送给它，否则就创建一个新的该activity的实例，放入一个新的 task 栈的栈底。肯定位于一个 task 的栈底，而且栈中只能有它一个该 activity 实例，但允许其他 activity 加入该栈。解决了在一个 task 中共享一个 activity。 SingleInstance: 这个跟 SingleTask 基本上是一样，只有一个区别：在这个模式下的Activity实例所处的task中，只能有这个activity实例，不能有其他的实例。一旦该模式的activity的实例已经存在于某个栈中，任何应用在激活该activity时都会重用该栈中的实例，解决了多个task共享一个 activity。 这些启动模式可以在功能清单文件 AndroidManifest.xml 中进行设置，中的 launchMode 属性。 具体实践 SingleTop 栈顶复用模式 &lt;activity android:name=\".dLaunchChapter.OneActivity\" android:launchMode=\"singleTop\"/&gt; 我们在清单里先给 OneActivity 启动模式设置为 singleTop ，然后代码启动活动的顺序为 One --&gt; One，反复点击多次，然后我们看看栈内情况。 adb 命令 ：dumpsys activity | grep -i runroot@vbox86p:/ # dumpsys activity | grep -i run Running activities (most recent first): Run #1: ActivityRecord&#123;23e3b5b u0 com.hugo.demo.activitydemo/.dLaunchChapter.OneActivity t595&#125; Run #0: ActivityRecord&#123;1a2c6f3 u0 com.hugo.demo.activitydemo/.LaunchActivity t595&#125; 该启动模式下并且 OneActivity 在栈顶所以不会创建新的实例，其生命周期调用 onPause —-&gt; onNewIntent —-&gt; onResume SingleTask 栈内复用模式 修改 OneActivity 的启动模式为 SingleTask ，然后我们代码启动的顺序为 One —-&gt; Two —-&gt; One，接了下看看栈内情况： One —-&gt; Two 我们记录下当前的 Activity 栈： Running activities (most recent first): Run #2: ActivityRecord&#123;1e8701b7 u0 com.hugo.demo.activitydemo/.dLaunchChapter.TwoActivity t632&#125; Run #1: ActivityRecord&#123;39e11719 u0 com.hugo.demo.activitydemo/.dLaunchChapter.OneActivity t632&#125; 接下来我们执行 Two —-&gt; One ，当前 Activity 栈信息： Running activities (most recent first): Run #1: ActivityRecord&#123;39e11719 u0 com.hugo.demo.activitydemo/.dLaunchChapter.OneActivity t632&#125; 当 TwoActivity 启动 OneActivity（SingleTask） 的时候，堆栈信息里只剩下了 OneActivity 并且和第一次内存信息 39e11719 相同，所以确实是复用了没有新建实例，接下来我们看看 Log 日志，再验证下我们的猜想，看看具体走了哪些生命周期： D/TwoActivity: onPauseD/OneActivity: onNewIntentD/OneActivity: onRestartD/OneActivity: onStartD/OneActivity: onResumeD/TwoActivity: onStopD/TwoActivity: onDestroy 果然此时 OneActivity 没有重新创建，并且系统把它切换到了栈顶并调用 onNewIntent 方法，同时我们发现， SingleTask 默认具有 clearTop 效果，导致 TwoActivity 出栈。 我们代码指定 OneActivity 的栈，效果还是一样的吗？ 带着问题我们修改下代码，增加一行：&lt;activity android:name=\".dLaunchChapter.OneActivity\" android:launchMode=\"singleTask\" android:taskAffinity=\"com.hugo.demo.singleTask\"/&gt; 然后我们按照刚刚顺序 One —-&gt; Two —-&gt; One 启动 Activity ，现在的栈内信息还会更上次一样吗？Running activities (most recent first): Run #2: ActivityRecord&#123;1bc18519 u0 com.hugo.demo.activitydemo/.dLaunchChapter.OneActivity t636&#125; Run #1: ActivityRecord&#123;36e5e368 u0 com.hugo.demo.activitydemo/.dLaunchChapter.TwoActivity t635&#125; 我们发现，虽然是复用了 OneActivity 而且移到了栈顶，但是并没有销毁 TwoActivity 。 原因在于 singleTask 模式受 taskAffinity 影响，TwoActivity 和 OneActivity 所在的 Activity 栈不同。 总结，启动一个 lauchMode 为 singleTask 的 Activity 时有两种情况: 若系统中存在相同 taskAffinity 值的任务栈 (tacks1 )时,会把 task1 从后台调到前台，若实例存在则干掉其上面的所有 Activity 并调用 onNewInstance 方法重用，没有该实例则新建一个。 否则，新建一个任务栈，并以此 Activity 作为 root 。 SingleInstance 单实例模式 这是一种加强的 singleTask 模式，它除了具有 singleTask 模式的所有特性以外，还加强了一点，就是具有此模式的 Activity 只能单独地位于任务栈。 好了，关于生命周期和启动模式实践+知识点整理已经完成啦，非常推荐大家下载源码自己运行看看 Log 日志，查看源码：Github，这样可以对这篇文章知识更加深刻。 参考文档 Android 开发艺术探索 第一章 管理Activity生命周期 Print the current back stack in the log"},{"title":"框架源码 — 简析学习 Retrofit","date":"2016-08-20T09:03:37.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/retrofit-source-learning.html","permalink":"http://imxie.cc/hide/retrofit-source-learning.html","excerpt":"看过很多篇 Retrofit 的源码分析文章，但是别人一问起来总是讲不清楚到底 Retrofit 是怎么个流程，所以还是得自己亲自去看看源码，一步一步的分析。果然只有亲自动手实践，才有自己的收获。告诫自己，慢慢来，会很快。","text":"看过很多篇 Retrofit 的源码分析文章，但是别人一问起来总是讲不清楚到底 Retrofit 是怎么个流程，所以还是得自己亲自去看看源码，一步一步的分析。果然只有亲自动手实践，才有自己的收获。告诫自己，慢慢来，会很快。 文章来源：itsCoder 的 WeeklyBolg 项目 itsCoder主页：http://itscoder.com/ 作者：谢三弟 审阅者：Joe 目录 目录 Retrofit 简介 Retrofit 分析 具体使用 工具箱：Retrofit.Builder() 外壳：Create() 结构：ServiceMethod 子弹：xxxFactory() 开枪打靶: Call.enqueue() 参考 Retrofit 简介Retrofit 源码开头的解释 * Retrofit adapts a Java interface to HTTP calls by using annotations on the declared methods to* define how requests are made. Create instances using &#123;@linkplain Builder* the builder&#125; and pass your interface to &#123;@link #create&#125; to generate an implementation. Retrofit 利用方法上的注解将接口转化成一个 HTTP 请求。 简单知道是什么了之后，我们对此提出疑问： 如何将接口转换为网络请求？ 谁去进行网络请求？ 接下来我们将从 Retrofit 的使用作为入口分析。 Retrofit 分析具体使用首先建立 API 接口类： interface GankApi &#123; String host = \"http://gank.io/api/data/\"; @GET(\"Android/10/&#123;page&#125;\") Call&lt;Android&gt; getAndroid(@Path(\"page\") int page);&#125; // 创建 Retrofit 实例Retrofit retrofit = new Retrofit.Builder() .baseUrl(GankApi.host) .addConverterFactory(GsonConverterFactory.create()) .build();// 生成接口实现类GankApi gankApi = retrofit.create(GankApi.class);// 调用接口定义的请求方法，并且返回 Call 对象Call&lt;Android&gt; call = gankApi.getAndroid(1);// 调用 Call 对象的异步执行方法call.enqueue(Callback callback) 简单的使用就是这样的流程。现在我们开始层层剖析。 工具箱：Retrofit.Builder()private Platform platform;private okhttp3.Call.Factory callFactory;private HttpUrl baseUrl;private List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;();private List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;();private Executor callbackExecutor;private boolean validateEagerly; 创建 Retrofit 的实例，进行一些配置，这里我们不用多说。但是有一个参数必须得讲讲。 Platform 在构建 Retrofit 的时候，会对当前使用平台进行判断，Java8，Android，iOS。 我们看看 Android 平台的代码：static class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125;&#125; 从代码中我们得知两点： 在 Android 里我们默认使用的 CallAdapter 是 ExecutorCallAdapterFactory() 它会返回的是 Call.class。关于 ExecutorCallAdapterFactory() 我们稍后再说，你先知道这是 Android 默认 CallAdapter 就好。 默认的 Callback 是在主线程。 外壳：Create()// 生成接口实现类GankApi gankApi = retrofit.create(GankApi.class); 我在源码里写好了注释： public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; // 检查传入的类是否为接口并且无继承 Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; // 重点是这里 // 首先会返回一个利用代理实现的 GankApi 对象 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); // 我们调用该对象的方法都会进入到这里 @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; // 解析方法 这里用到了注解（Runtime）这里我们标记下（A）稍后来看看里面具体实现 ServiceMethod serviceMethod = loadServiceMethod(method); // 将刚刚解析完毕包装后的具体方法封装成 OkHttpCall ，你可以在该实现类找到 okhttp 请求所需要的参数 // 所以它是用来跟 okhttp 对接的。 OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); // 将以上我们封装好的 call 返回给上层，这个时候我们就可以执行 call 的同步方法或者异步进行请求。 return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 切合我们实际运用来看看顺序： GankApi gankApi = retrofit.create(GankApi.class);—-&gt; return (T) Proxy.newProxyInstance（...）{...}—-&gt; Call&lt;Android&gt; call = gankApi.getAndroid(1); —-&gt; public Object invoke(...){...} 调用代理类的invoke()。 直到这里我们已经宏观地了解 Retrofit 是怎样的一个流程。 达成 初窥门径 成就。 千万别骄傲，为了以后走的更远更稳，我们得好好筑基，上面我们用到的是动态代理，强烈建议认真阅读两篇文章。 Retrofit2源码分析[动态代理] Java静态代理和动态代理 结构：ServiceMethodRetrofit 有一个双链表用来缓存方法private final Map&lt;Method, ServiceMethod&gt; serviceMethodCache = new LinkedHashMap&lt;&gt;(); ServiceMethod loadServiceMethod(Method method) &#123; ServiceMethod result; synchronized (serviceMethodCache) &#123; // 从缓存中获取该方法 result = serviceMethodCache.get(method); if (result == null) &#123; // 没有就进行创建并且存入链表缓存 result = new ServiceMethod.Builder(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result;&#125; 我们发现主要的方法是 new ServiceMethod.Builder(this, method).build(); ，所以接下来我们深入看看如何 解析注解 以及 构建请求方法 。 初始化一些参数 public Builder(Retrofit retrofit, Method method) &#123; this.retrofit = retrofit; this.method = method; this.methodAnnotations = method.getAnnotations(); this.parameterTypes = method.getGenericParameterTypes(); this.parameterAnnotationsArray = method.getParameterAnnotations();&#125; build() 这里的源码很长，做了很多异常处理，我截取重点来分析下。 callAdapter = createCallAdapter();responseConverter = createResponseConverter(); 一个是用来发送请求的 client ，一个是结果的转换器（Gson，FastJson …）之类，后面我们再讲这个。上层配置就是当我们调用 Retrofit 的 addConverterFactory()和 addCallAdapterFactory()，内部会自动使用我们定义的组件。 for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation);&#125; 在这里可以看到遍历我们使用方法的注解，并且解析他们。parseMethodAnnotation() 内部就是解析好 HTTP 的请求方式。 为了篇幅大小，可以在 源码 里看看具体的操作。 同时也可以看看 http 包下注解用到的接口，你会发现 @Retention(RUNTIME) 所以，从这里我们就可以明白，Retrofit 是在在运行期通过反射访问到这些注解的。 return Call 请求方法参数，请求客户端，返回值转换，我们都定义好了之后，便完成最后一步，构建好适合请求客户端的请求方法，Retrofit 默认的是 okhttpCall 。 OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);return serviceMethod.callAdapter.adapt(okHttpCall); 最后将 call 返回给上层，用户调用方法进行请求。 总结 /** Adapts an invocation of an interface method into an HTTP call. */ ServiceMethod 类开头注释已经很清楚的说明了作用，将接口方法改变成一个 HTTP call 。它对于 Retrofit 是很重要的存在，整个枪支内部都是由它来支撑起来。 子弹：xxxFactory()Retrofit 给我们最大的便利就是自身框架优雅的设计，只需要很小的改动，便可以优雅的适应不同的需求。所以很需要我们再补充点额外知识，了解什么是适配器模式，然后回到这里看看 Retrofit 是如何应用的。 在构建 ServiceMethod 对象的时候，有三个方法可以单独说说 build() 中 createCallAdapter() —-&gt; retrofit.callAdapter() 解析接口方法内注解时parseParameterAnnotation()调用到的retrofit.requestBodyConverter() build() 中 createResponseConverter() —-&gt; retrofit.responseBodyConverter() callAdapter() 最终会调用到 nextCallAdapter() 该方法主要是从 callAdapterFactories 中获取新的 CallAdapter，它会跳过 skipPast，以及 skipPast 之前的 Factory，然后找到与 returnType 和 annotations 都匹配的 CallAdapterFactory 。 requestBodyConverter() &amp; responseBodyConverter() 最终会调用到 nextRequestBodyConverter()/nextResponseBodyConverter利用 converterFactories 创建一个与 RequestBody/ResponseBody 对应的 Converter 对象。 所以在这里我们就可以装填我们需要的子弹类型了。 进入实战，为我们的 Retrofit 添加 RxJava 和 Gson。 Rxjava: adapter-rxjava 我们重点看 RxJavaCallAdapterFactory 即可，它是实现了 CallAdapter.Factory 并在对应方法里将 Call 包装成 Observable.class 返回。 然后给 Retrofit 对象加上 .addCallAdapterFactory(RxJavaCallAdapterFactory.create())，这样我们才可以优雅的使用 Retrofit + RxJava 。 Gson: 我相信通过类名我们就可以知道每个类是用来做什么的，我在这里太过深入到具体实现反而一叶障目，如果我们需要自定义数据转换格式，也是同样这样做。继承 Converter.Factory 类作为适配类，同时创建两个实现 Converter 的类包装请求和响应的数据形式。 开枪打靶: Call.enqueue()注意：我这里只列举一个默认状态下的情况 \b还记得我工具箱里我们提到的 ExecutorCallbackCall 吗？这里的 Call 是对应我们选择的 call ，而此时是默认的 ExecutorCallbackCall 。如果还要问我为什么，请去看看 工具箱：Retrofit.Builder() 里 Android 平台的源码。 static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor; final Call&lt;T&gt; delegate; ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate; &#125; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; if (callback == null) throw new NullPointerException(\"callback == null\"); delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; // 省略&#125; 这里的 delegate 对应的就是 okhttp 的 call ，不禁有疑问了，这里调用的是异步请求，但是我们的回调是怎么回到主线程的呢？ 带着疑问我们来看看。首先回调是在 callbackExecutor.execute() 我们从这里入手。我们发现在 Retrofit 的 build() 方法里： Executor callbackExecutor = this.callbackExecutor;if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor();&#125; 平台默认的回调调度器，连忙回到工具箱看看： static class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125;&#125; 我们发现，Android 默认的调度器是主线程的 Handler ，execute()方法也只是 mainHandler.post() 。 所以这下就可以解决我们的疑问了。 callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125;&#125;); 这段代码我们就可以改写为： mainHandler.post(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; // Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation. callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125;&#125;); 如果看到这，还不理解为什么那就得好好补补 handler 的知识啦！ 我这里推荐 melo 写的这篇，风趣易懂 带着这篇去通关所有Handler的提问 。 最后放上两张开源社区画的流程图，我觉得特别清晰： 以上。〃´∀`) 参考 Retrofit2源码分析[动态代理] Java静态代理和动态代理 一个示例让你明白适配器模式 Retrofit分析-漂亮的解耦套路 我对Retrofit的认识 Retrofit 源码分析 Java 注解"},{"title":"沉浸式适配个人总结","date":"2016-11-08T08:02:31.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/jike_Immersive_project.html","permalink":"http://imxie.cc/hide/jike_Immersive_project.html","excerpt":"总结适配项目中遇到的沉浸式的坑和个人的解决方案。","text":"总结适配项目中遇到的沉浸式的坑和个人的解决方案。 文章来源：itsCoder 的 WeeklyBolg 项目 itsCoder主页：http://itscoder.com/ 作者：谢三弟 审阅者：Jaeger 目录 目录 前言 适配 标志 布局 修补 坑 源码 状态栏工具部分核心代码 环境工具类部分核心代码 修复全屏输入框工具类 总结 参考 前言 本篇文章环境是 主色调：白色 右滑返回：需要 在做沉浸式之前，得知道下面几个问题： 什么是沉浸式 Android 系统对沉浸式的支持 首先第一个问题，推荐阅读这篇 Android 沉浸式 UI 实现及原理 ，作者对照哔哩哔哩进行分析「个人也认为 B 站在国内 Android 应用里算规范」。 第二个问题，也是个人在适配沉浸式过程中遇到的版本坑，大致总结如下： Android 4.4（19）以下 Android 4.4（19） 「小米 MIUI V4 」和「魅族 Flyme 4.0」以上 Android 5.0 （21） Android 6.0+（23+） 因为 Android 是从 4.4 开始引入 android:windowTranslucentStatus 标签，所以理论上 4.4 以上都可以实现沉浸式，而本方案也是基于 4.4 开始。 因为即刻的主色调是纯白色，在 Android 里纯白是 BUG 的存在，适配需要做更多对于状态栏 icon 颜色的处理。收集资料可以参考： Android 状态栏黑色字体 Android 系统更改状态栏字体颜色 白底黑字！Android 浅色状态栏黑色字体模式 Flyme 系统 API-沉浸式状态栏 按照刚才列出的版本，整理注意的细节如图： 关于小米 OS 和魅族 OS 可以参考维基百科： Flyme OS - 维基百科，自由的百科全书 MIUI - 维基百科，自由的百科全书 适配标志适配中用到的 Flag 有： View.SYSTEM_UI_FLAG_LAYOUT_STABLEView.SYSTEM_UI_FLAG_LAYOUT_FULLSCREENView.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 在 4.4(API 19) 中还引入了 WindowManager.LayoutParams.FLAG_TRANSUCENT_STATUS 和WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION 用于控制 System UI 变透明，这两个 Flag 分别对应于 windowTranslucentStatus 和windowTranslucentNavigation 两个 attr，并同时提供了相应的 Theme（这些 Theme 都没有 ActionBar），当使用这两个 Flag 时，SYSTEM_UI_FLAG_LAYOUT_STABLE、SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN和SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 会被自动添加。 布局从 4.4 开始，所以在 style-19 里所有父级主题增加：&lt;style name=\"JikeTheme.SystemUi\"&gt; &lt;item name=\"android:windowTranslucentStatus\"&gt;true&lt;/item&gt;&lt;/style&gt; 在业务基类 BaseActivity onCreate() 中加入了对沉浸式的一些判断和处理： isSuccessStatusIcons = true; // 默认认为可以设置状态栏 Icon 颜色@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); StatusBarUtil.setImmersiveStatusBar(this); // 适配状态栏字体颜色 if (needStatusIconsBlack()) &#123; isSuccessStatusIcons = StatusBarUtil.setStatusBarDarkIcon(this); &#125; if (!isSuccessStatusIcons &amp;&amp; ImmersiveUtil.supportImmersiveStatusBar()) &#123; if (needAddColorStatusView()) &#123; StatusBarUtil.addColorStatusView(this, R.color.black); &#125; else &#123; StatusBarUtil.addTranslucentView(this, 0); &#125; &#125;&#125; 这里有四个方法： StatusBarUtil.setImmersiveStatusBar(this); // 添加全屏/透明状态栏的 Flag StatusBarUtil.setStatusBarDarkIcon(this); // 设置状态栏 Icon 为黑色 StatusBarUtil.addColorStatusView(this, R.color.very_dark_grayish_blue_26); // 添加一个带颜色的矩形块 StatusBarUtil.addTranslucentView(this, 0); // 添加一个透明状态栏 主要是这里的逻辑需要说明 if (!isSuccessStatusIcons &amp;&amp; StatusBarUtil.supportImmersiveStatusBar()) 前面已经说了 5.x 的非小米魅族 Rom 无法更改状态栏 icon 颜色，所以我进行适配的方法是，isSuccessStatusIcons 来标识是不是非（魅族，小米） 的其他 Rom，然后加入一个与状态栏等高的带颜色的矩形 View ，也就是StatusBarUtil.addColorStatusView(this, R.color.very_dark_grayish_blue_26); 方法做的事情，同时通过 needAddColorStatusView()标志是否需要添加。 这样说可能不好理解， 一个具体的场景是这样： 可以看到，在 5.x 首页状态栏是一个黑条，也就是我们手动加上去的矩形，但在有图片的 activity 是透明，这也就是 needAddColorStatusView 标识的作用。 接下来适配 Toolbar ： protected void initToolbar(@NonNull Toolbar toolbar) &#123; // other code StatusBarUtil.setImmersiveStatusBarToolbar(toolbar, this);&#125; /** * 统一适配 toolbar * 设置 toolbar 高度为 ?attr/actionBarSize + statusBarHeight 并且设置 padding 布局还原 */public static void setImmersiveStatusBarToolbar(Toolbar toolbar, Context context) &#123; if (ImmersiveUtil.supportImmersiveStatusBar()) &#123; ViewGroup.MarginLayoutParams toolLayoutParams = (ViewGroup.MarginLayoutParams) toolbar.getLayoutParams(); toolLayoutParams.height = EnvUtil.getStatusBarHeight() + EnvUtil.getActionBarSize(context); toolbar.setLayoutParams(toolLayoutParams); setImmersiveStatusToolbarOnlyPadding(toolbar, 0, EnvUtil.getStatusBarHeight(), 0, 0); &#125;&#125; 主要做的事情就是，将 Toolbar 的高度增加一个状态栏高度，且设置 paddingTop。 这样在 BaseActivity 里就把状态栏和 Toolbar 都适配好了。 接下来就是给内容详情增加正确的 margin 值。 其实以上大部分都跟具体的界面编写有关，所以这里只提供一个思路。 修补适配之后整个页面看着是可行的，但是得额外注意一些具体场景： 需要输入法 与状态栏有关的遮挡交互动画 第一个 比较特殊性。为了适配沉浸式，我们使用了View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN 标签，该标签下，adjustResize 会失效，adjustPan 效果很差。为了实现输入法弹出效果，写了一个 FullscreenInputModeUtil 工具类兼容实现，主要逻辑是动态计算可见高度来得到输入法高度，从而改变布局整个高度（输入栏框是始终在布局最底部）实现 adjustResize 效果。 具体可以参考 code.google.com 第二个 是这样的： 原本是 CoordinatorLayout Behavior 实现 Toolbar 上滑隐藏效果， BUG 是上滑应该隐藏在状态栏后的 Title 并没有消失。所以现有的解决方案是在 layout 里写一个背景是白色高度是0的 View 并在代码里根据 sdk 修改高度： // 增加一个实体白色 View 在状态栏下，复原滑动效果if (ImmersiveUtil.supportImmersiveStatusBar()) &#123; mTrickStatusBar.getLayoutParams().height = EnvUtil.getStatusBarHeight(); mTrickStatusBar.requestLayout();&#125; 坑 ROM 坑 根据手机厂商判断 Rom 是不行的，因为会有小米手机但是刷了其他 Rom 的情况，所以我们得找到正确判断 Rom 的方法。 private static String getRomProperty(String prop) &#123; String line = \"\"; BufferedReader reader = null; Process process = null; try &#123; process = Runtime.getRuntime().exec(\"getprop \" + prop); reader = new BufferedReader(new InputStreamReader(process.getInputStream()), 1024); line = reader.readLine(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; IOUtil.close(reader); if (process != null) &#123; process.destroy(); &#125; &#125; return line;&#125; 该方法主要是执行命令行，去获取 build.prop 文件的信息，里面记录了系统的设置和属性，相当于 Windows 系统注册表的文件。当然包括了该手机使用的 Rom 信息，上层我们只需要判断是否含有特殊适配的 Rom 字段即可。这样就可以准确适配不同手机不同系统。 虚拟导航栏是否存在 这里大部分的场景是需要输入栏的页面——因为大多输入栏的布局都会是layout_alignParentBottom=true。因为即刻中采取的沉浸式方案是全屏，有输入栏的页面，会设置一个虚拟导航栏的 padding 值，这样才能保证输入栏不会被虚拟导航栏遮挡。 所以这里的关键就是判断该手机是否有虚拟导航栏。 最开始的时候，我们是通过判断是否有硬件按钮（菜单键，返回键），来直接一刀决定是否有虚拟导航栏。但是在 Android 机型复杂的环境下，该方法并不能保证所有适配。所以换了一种方案： 用 Display 来帮助，该类中有个方法： Gets display metrics based on the real size of this display.The size is adjusted based on the current rotation of the display.The real size may be smaller than the physical size of the screen when the window manager is emulating a smaller display (using adb shell am display-size). public void More ...getRealMetrics(DisplayMetrics outMetrics) &#123; synchronized (this) &#123; updateDisplayInfoLocked(); mDisplayInfo.getLogicalMetrics(outMetrics, CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO, mDisplayAdjustments.getActivityToken()); &#125;&#125; 从上诉方法我们可以得到一个近似于手机物理屏幕的尺寸，这里我们认为是 realSize . Gets display metrics that describe the size and density of this display.The size is adjusted based on the current rotation of the display.The size returned by this method does not necessarily represent the actual raw size (native resolution) of the display. The returned size may be adjusted to exclude certain system decor elements that are always visible. It may also be scaled to provide compatibility with older applications that were originally designed for smaller displays. public void More ...getMetrics(DisplayMetrics outMetrics) &#123; synchronized (this) &#123; updateDisplayInfoLocked(); mDisplayInfo.getAppMetrics(outMetrics, mDisplayAdjustments); &#125;&#125; 同时通过该方法获取可见视图的尺寸。接下来的事情，就是分别比较长宽大小来判断是否有导航栏。 源码状态栏工具部分核心代码public class StatusBarUtil &#123; /** * 透明状态栏 让布局延伸到状态栏 */ public static void setImmersiveStatusBar(@NonNull Activity activity) &#123; if (ImmersiveUtil.supportImmersiveStatusBar()) &#123; if (SdkUtil.sdkVersionGe21()) &#123; activity.getWindow().setStatusBarColor(Color.TRANSPARENT); &#125; if (SdkUtil.sdkVersionEq(19)) &#123; activity.getWindow().setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS, WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); &#125; activity.getWindow() .getDecorView() .setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN); &#125; &#125; /** * 统一适配 toolbar * 设置 toolbar 高度为 ?attr/actionBarSize + statusBarHeight 并且设置 padding 布局还原 */ public static void setImmersiveStatusBarToolbar(@NonNull Toolbar toolbar, Context context) &#123; if (ImmersiveUtil.supportImmersiveStatusBar()) &#123; ViewGroup.MarginLayoutParams toolLayoutParams = (ViewGroup.MarginLayoutParams) toolbar.getLayoutParams(); toolLayoutParams.height = EnvUtil.getStatusBarHeight() + EnvUtil.getActionBarSize(context); toolbar.setLayoutParams(toolLayoutParams); setImmersiveStatusToolbarOnlyPadding(toolbar, 0, EnvUtil.getStatusBarHeight(), 0, 0); &#125; &#125; /** * 为沉浸式抽离设置 toolbar padding 值的方法 */ public static void setImmersiveStatusToolbarOnlyPadding(@NonNull Toolbar toolbar, int left, int top, int right, int bottom) &#123; if (SdkUtil.sdkVersionGe21()) &#123; toolbar.setPadding(left, top, right, bottom); &#125; else if (SdkUtil.sdkVersionGe19()) &#123; toolbar.setPadding(left, top - DensityUtil.dimenPixelSize(R.dimen.shadow_size), right, bottom); &#125; else &#123; toolbar.setPadding(left, 0, right, bottom); &#125; toolbar.requestLayout(); &#125; /** * 给内容页设置正确的 margin 值 * * @param includeActionBar true： Height = StatusBar + ActionBar false： Height = StatusBar */ public static void setImmersiveStatusBarContent(@NonNull View view, boolean includeActionBar) &#123; ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) view.getLayoutParams(); if (ImmersiveUtil.supportImmersiveStatusBar()) &#123; if (includeActionBar) &#123; params.topMargin = EnvUtil.getStatusBarHeight() + EnvUtil.getActionBarSize(view.getContext()); &#125; else &#123; params.topMargin = EnvUtil.getStatusBarHeight(); &#125; &#125; else &#123; if (includeActionBar) &#123; params.topMargin = EnvUtil.getActionBarSize(view.getContext()) + DensityUtil.dimenPixelSize(R.dimen.shadow_size) * 2; &#125; &#125; view.setLayoutParams(params); view.requestLayout(); &#125; /** * 给需要弹出输入法的页面设置弹出效果和正确的 padding 值 */ public static void setImmersiveNeedInputView(@NonNull Activity activity, @NonNull ViewGroup viewGroup) &#123; if (ImmersiveUtil.supportImmersiveStatusBar()) &#123; FullscreenInputModeUtil.attachActivity(activity, viewGroup); viewGroup.setPadding(0, 0, 0, EnvUtil.getNavigationBarHeight()); viewGroup.requestLayout(); &#125; &#125; /** * 添加颜色矩形条 */ public static void addColorStatusView(@NonNull Activity activity, @ColorRes int color) &#123; ViewGroup contentView = (ViewGroup) activity.findViewById(Window.ID_ANDROID_CONTENT); if (contentView.getChildCount() &gt; 1) &#123; contentView.getChildAt(1).setBackgroundColor(ContextCompat.getColor(activity, color)); &#125; else &#123; contentView.addView(createColorStatusBarView(activity, color)); &#125; &#125; /** * 添加半透明矩形条 */ public static void addTranslucentView(@NonNull Activity activity, int statusBarAlpha) &#123; ViewGroup contentView = (ViewGroup) activity.findViewById(Window.ID_ANDROID_CONTENT); if (contentView.getChildCount() &gt; 1) &#123; contentView.getChildAt(1).setBackgroundColor(Color.argb(statusBarAlpha, 0, 0, 0)); &#125; else &#123; contentView.addView(createTranslucentStatusBarView(activity, statusBarAlpha)); &#125; &#125; /** * 创建半透明矩形 View */ private static View createTranslucentStatusBarView(@NonNull Activity activity, int alpha) &#123; // 绘制一个和状态栏一样高的矩形 View statusBarView = new View(activity); LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, EnvUtil.getStatusBarHeight()); statusBarView.setLayoutParams(params); statusBarView.setBackgroundColor(Color.argb(alpha, 0, 0, 0)); return statusBarView; &#125; /** * 创建一个带颜色矩形 View */ private static View createColorStatusBarView(@NonNull Activity activity, @ColorRes int color) &#123; // 绘制一个和状态栏一样高的矩形 View statusBarView = new View(activity); LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, EnvUtil.getStatusBarHeight()); statusBarView.setLayoutParams(params); statusBarView.setBackgroundColor(ContextCompat.getColor(activity, color)); return statusBarView; &#125; /** * @return 是否设置颜色成功 */ public static boolean setStatusBarDarkIcon(@NonNull Activity activity) &#123; if (!ImmersiveUtil.supportImmersiveStatusBar()) &#123; return false; &#125; else &#123; if (EnvUtil.isMeizu()) &#123; StatusBarUtil.setMeizuStatusBarDarkIcon(activity, true); return true; &#125; else if (EnvUtil.isXiaomi()) &#123; StatusBarUtil.setMiuiStatusBarDarkIcon(activity, true); return true; &#125; else if (EnvUtil.isZuk()) &#123; // Zuk 的 rom 无法修改状态栏 icon 颜色 return false; &#125; else if (SdkUtil.sdkVersionGe23()) &#123; activity.getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); return true; &#125; else &#123; return false; &#125; &#125; &#125; /** * 修改魅族状态栏字体颜色 Flyme 4.0 */ private static void setMeizuStatusBarDarkIcon(@NonNull Activity activity, boolean dark) &#123; if (ImmersiveUtil.supportImmersiveStatusBar()) &#123; try &#123; WindowManager.LayoutParams lp = activity.getWindow().getAttributes(); Field darkFlag = WindowManager.LayoutParams.class .getDeclaredField(\"MEIZU_FLAG_DARK_STATUS_BAR_ICON\"); Field meizuFlags = WindowManager.LayoutParams.class .getDeclaredField(\"meizuFlags\"); darkFlag.setAccessible(true); meizuFlags.setAccessible(true); int bit = darkFlag.getInt(null); int value = meizuFlags.getInt(lp); if (dark) &#123; value |= bit; &#125; else &#123; value &amp;= ~bit; &#125; meizuFlags.setInt(lp, value); activity.getWindow().setAttributes(lp); &#125; catch (Exception e) &#123; JLog.e(e, e.toString()); &#125; &#125; &#125; /** * 修改 MIUI V6 以上状态栏颜色 */ private static void setMiuiStatusBarDarkIcon(@NonNull Activity activity, boolean dark) &#123; if (ImmersiveUtil.supportImmersiveStatusBar()) &#123; Class&lt;? extends Window&gt; clazz = activity.getWindow().getClass(); try &#123; Class&lt;?&gt; layoutParams = Class.forName(\"android.view.MiuiWindowManager$LayoutParams\"); Field field = layoutParams.getField(\"EXTRA_FLAG_STATUS_BAR_DARK_MODE\"); int darkModeFlag = field.getInt(layoutParams); Method extraFlagField = clazz.getMethod(\"setExtraFlags\", int.class, int.class); extraFlagField.invoke(activity.getWindow(), dark ? darkModeFlag : 0, darkModeFlag); &#125; catch (Exception e) &#123; JLog.e(e, e.toString()); &#125; &#125; &#125;&#125; 环境工具类部分核心代码public class EnvUtil &#123; public static void checkDeviceHasNavigationBar(Activity activity) &#123; if (sHasNavigationBar != null) &#123; return; &#125; WindowManager windowManager = activity.getWindowManager(); Display display = windowManager.getDefaultDisplay(); DisplayMetrics realDisplayMetrics = new DisplayMetrics(); if (SdkUtil.sdkVersionGe(17)) &#123; display.getRealMetrics(realDisplayMetrics); &#125; int realHeight = realDisplayMetrics.heightPixels; int realWidth = realDisplayMetrics.widthPixels; DisplayMetrics displayMetrics = new DisplayMetrics(); display.getMetrics(displayMetrics); int displayHeight = displayMetrics.heightPixels; int displayWidth = displayMetrics.widthPixels; sHasNavigationBar = (realWidth - displayWidth) &gt; 0 || (realHeight - displayHeight) &gt; 0; &#125; public static boolean isXiaomi() &#123; return MIUI.equalsIgnoreCase(getRomInfo()); &#125; public static boolean isMeizu() &#123; return FLYME.equalsIgnoreCase(getRomInfo()); &#125; public static boolean isZuk() &#123; return ZUK.equalsIgnoreCase(getRomInfo()); &#125; private static String romInfo = \"\"; private static final String MIUI = \"miui\"; private static final String FLYME = \"flyme\"; private static final String ZUK = \"zuk\"; private static final String UNKNOWN = \"unknown\"; private static final String RUNTIME_MIUI = \"ro.miui.ui.version.name\"; private static final String RUNTIME_DISPLAY = \"ro.build.display.id\"; private static final String RUNTIME_ZUK = \"ro.com.zui.version\"; public static String getRomInfo() &#123; if (!TextUtils.isEmpty(romInfo)) &#123; return romInfo; &#125; if (!TextUtils.isEmpty(getRomProperty(RUNTIME_MIUI))) &#123; romInfo = MIUI; &#125; else if (!TextUtils.isEmpty(getRomProperty(RUNTIME_ZUK))) &#123; romInfo = ZUK; &#125; else if (getRomProperty(RUNTIME_DISPLAY).toLowerCase().contains(FLYME)) &#123; romInfo = FLYME; &#125; else &#123; romInfo = UNKNOWN; &#125; return romInfo; &#125; private static String getRomProperty(String prop) &#123; String line = \"\"; BufferedReader reader = null; Process process = null; try &#123; process = Runtime.getRuntime().exec(\"getprop \" + prop); reader = new BufferedReader(new InputStreamReader(process.getInputStream()), 1024); line = reader.readLine(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; IOUtil.close(reader); if (process != null) &#123; process.destroy(); &#125; &#125; return line; &#125;&#125; 修复全屏输入框工具类public class FullscreenInputModeUtil &#123; public static void attachActivity(Activity activity, ViewGroup group) &#123; new FullscreenInputModeUtil(activity, group); &#125; private View mChildOfContent; private int usableHeightPrevious; private FrameLayout.LayoutParams mChildLayoutParams; private ViewGroup mInputParentView; private FullscreenInputModeUtil(Activity activity, ViewGroup viewGroup) &#123; FrameLayout content = (FrameLayout) activity.findViewById(Window.ID_ANDROID_CONTENT); mInputParentView = viewGroup; mInputParentView.setBackgroundColor(Color.WHITE); mChildOfContent = content.getChildAt(0); mChildOfContent.getViewTreeObserver().addOnGlobalLayoutListener(() -&gt; &#123; // 当在一个视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变时，所要调用的回调函数的接口类 resizeChildOfContent(); &#125;); mChildLayoutParams = (FrameLayout.LayoutParams) mChildOfContent.getLayoutParams(); &#125; /** * 重置 content 布局，通过计算可见范围的变化值，确定输入框的高度（兼容一个状态栏高度） */ private void resizeChildOfContent() &#123; int visibleHeightNow = ViewUtil.getVisibleHeightInLayout(mChildOfContent); if (visibleHeightNow != usableHeightPrevious) &#123; int visibleHeightSansKeyboard = mChildOfContent.getRootView().getHeight(); int heightDifference = visibleHeightSansKeyboard - visibleHeightNow; if (heightDifference &gt; (visibleHeightSansKeyboard / 4)) &#123; // 输入法出现 mChildLayoutParams.height = visibleHeightSansKeyboard - heightDifference + EnvUtil.getStatusBarHeight(); mInputParentView.setPadding(0, 0, 0, 0); &#125; else &#123; // 输入法消失 mChildLayoutParams.height = visibleHeightSansKeyboard; mInputParentView.setPadding(0, 0, 0, EnvUtil.getNavigationBarHeight()); &#125; mChildOfContent.requestLayout(); usableHeightPrevious = visibleHeightNow; &#125; &#125;&#125; 总结本文主要是提供一个具体可行方案和开发中遇到的一些坑的解决方案提供出来。如果你的应用主色调不是纯白色，那么理论上可以完全适配到 4.4 (19) 。 对于沉浸式，众说纷纭，但是唯一的目的，就是提高用户体验。 如果还有什么遗漏的地方，欢迎补充。 参考 Android App 沉浸式状态栏解决方案 与 Status Bar 和 Navigation Bar 相关的一些东西 Android How to adjust layout in Full Screen Mode when softkeyboard is visible"},{"title":"面试问题整理Andorid版本","date":"2015-11-12T13:14:36.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"hide/面试问题整理Andorid版本.html","permalink":"http://imxie.cc/hide/面试问题整理Andorid版本.html","excerpt":"","text":"Acitivty的四中启动模式与特点。 standard：默认的启动模式 singleTop：适合那种接受通知启动的页面，比如新闻客户端之类的，可能会给你推送好几次 ，但是每次都是打开同一张页面调用onNewIntent singleTask：适合作为程序入口点，例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空浏览器主界面上面的其他页面。而之前打开过的页面不再新建 singleInstance：适合需要与程序分离开的页面。例如闹铃，将闹铃提醒与设置分离，使得闹铃提醒成为系统范围内的唯一实例 Acitivity后台闲置退出或异常退出，如何保存数据 通过 onSaveInstanceState() 和 onRestoreInstanceState() 保存和重启非持久化数据。 Service的生命周期，两种启动方法，有什么区别Service的第一种启动方式采用start的方式开启服务 使用Service的步骤： 1.定义一个类继承Service2.在Manifest.xml文件中配置该Service3.使用Context的startService(Intent)方法启动该Service4.不再使用时，调用stopService(Intent)方法停止该服务 使用这种start方式启动的Service的生命周期如下： onCreate()—&gt;onStartCommand()（onStart()方法已过时） —&gt; onDestory() 说明： 如果服务已经开启，不会重复的执行onCreate()， 而是会调用onStart()和onStartCommand()。服务停止的时候调用 onDestory()。服务只会被停止一次。 特点： 一旦服务开启跟调用者(开启者)就没有任何关系了。开启者退出了，开启者挂了，服务还在后台长期的运行。开启者不能调用服务里面的方法。 Service的第二种启动方式采用bind的方式开启服务 使用Service的步骤： 1.定义一个类继承Service2.在Manifest.xml文件中配置该Service3.使用Context的bindService(Intent, ServiceConnection, int)方法启动该Service4.不再使用时，调用unbindService(ServiceConnection)方法停止该服务 使用这种start方式启动的Service的生命周期如下： onCreate() —&gt;onBind()—&gt;onunbind()—&gt;onDestory() 注意：绑定服务不会调用onstart()或者onstartcommand()方法 特点：bind的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。绑定者可以调用服务里面的方法。 绑定者如何调用服务里的方法呢？首先定义一个Service的子类。public class MyService extends Service &#123; public MyService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; //返回MyBind对象 return new MyBinder(); &#125; private void methodInMyService() &#123; Toast.makeText(getApplicationContext(), \"服务里的方法执行了。。。\", Toast.LENGTH_SHORT).show(); &#125; /** * 该类用于在onBind方法执行后返回的对象， * 该对象对外提供了该服务里的方法 */ private class MyBinder extends Binder implements IMyBinder &#123; @Override public void invokeMethodInMyService() &#123; methodInMyService(); &#125; &#125;&#125; 自定义的MyBinder接口用于保护服务中不想让外界访问的方法。public interface IMyBinder &#123; void invokeMethodInMyService();&#125; 接着在Manifest.xml文件中配置该Service&lt;service android:name=&quot;.MyService&quot;/&gt;在Activity中绑定并调用服务里的方法简单布局：&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;Button android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:onClick=\"start\" android:text=\"开启服务\" android:textSize=\"30sp\" /&gt; &lt;Button android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:onClick=\"invoke\" android:text=\"调用服务的方法\" android:textSize=\"30sp\" /&gt;&lt;/LinearLayout&gt; 绑定服务的Activity：public class MainActivity extends Activity &#123; private MyConn conn; private Intent intent; private IMyBinder myBinder; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; //开启服务按钮的点击事件 public void start(View view) &#123; intent = new Intent(this, MyService.class); conn = new MyConn(); //绑定服务， // 第一个参数是intent对象，表面开启的服务。 // 第二个参数是绑定服务的监听器 // 第三个参数一般为BIND_AUTO_CREATE常量，表示自动创建bind bindService(intent, conn, BIND_AUTO_CREATE); &#125; //调用服务方法按钮的点击事件 public void invoke(View view) &#123; myBinder.invokeMethodInMyService(); &#125; private class MyConn implements ServiceConnection &#123; @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) &#123; //iBinder为服务里面onBind()方法返回的对象，所以可以强转为IMyBinder类型 myBinder = (IMyBinder) iBinder; &#125; @Override public void onServiceDisconnected(ComponentName componentName) &#123; &#125; &#125;&#125; 绑定本地服务调用方法的步骤： 1.在服务的内部创建一个内部类 提供一个方法，可以间接调用服务的方法2.实现服务的onbind方法，返回的就是这个内部类3.在activity 绑定服务。bindService();4.在服务成功绑定的回调方法onServiceConnected， 会传递过来一个 IBinder对象5.强制类型转化为自定义的接口类型，调用接口里面的方法。 RxJava&amp;RxAndroidRxJava 到底是什么 异步，简洁。 RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。 然而，对于初学者来说，这太难看懂了。因为它是一个『总结』，而初学者更需要一个『引言』。 其实， RxJava 的本质可以压缩为异步这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的。 链式调用 线程切换容易 更加符合思维 不会出现迷之嵌套 其他：详细阅读扔物线给 Android 开发者的 RxJava 详解 Intent的使用方法，可以传递哪些数据类型 参考这篇文章 Serializable :将 Java 对象序列化为二进制文件的 Java 序列化技术是 Java系列技术中一个较为重要的技术点，在大部分情况下，开发人员只需要了解被序列化的类需要实现 Serializable 接口，使用ObjectInputStream 和 ObjectOutputStream 进行对象的读写。 charsequence :在JDK1.4中，引入了CharSequence接口，实现了这个接口的类有：CharBuffer、String、StringBuffer、StringBuilder这个四个类。CharBuffer为nio里面用的一个类，String实现这个接口理所当然，StringBuffer也是一个CharSequence，StringBuilder是Java抄袭C#的一个类，基本和StringBuffer类一样，效率高，但是不保证线程安全，在不需要多线程的环境下可以考虑。提供这么一个接口，有些处理String或者StringBuffer的类就不用重载了。但是这个接口提供的方法有限，只有下面几个：charat、length、subSequence、toString这几个方法，感觉如果有必要，还是重载的比较好，避免用instaneof这个操作符。 Parcelable :android提供了一种新的类型：Parcel。本类被用作封装数据的容器，封装后的数据可以通过Intent或IPC传递。 除了基本类型以外，只有实现了Parcelable接口的类才能被放入Parcel中。是GOOGLE在安卓中实现的另一种序列化,功能和Serializable相似,主要是序列化的方式不同 Bundle:Bundle是将数据传递到另一个上下文中或保存或回复你自己状态的数据存储方式。它的数据不是持久化状态。 可以直接通过调用Intent的putExtra()方法存入数据，然后在获得Intent后调用getXxxExtra获得 对应类型的数据；传递多个的话，可以使用Bundle对象作为容器，通过调用Bundle的putXxx先将数据 存储到Bundle中，然后调用Intent的putExtras()方法将Bundle存入Intent中，然后获得Intent以后， 调用getExtras()获得Bundle容器，然后调用其getXXX获取对应的数据！ 另外数据存储有点类似于Map的&lt;键，值&gt;！ 传递对象的方式有两种：将对象转换为Json字符串或者通过Serializable,Parcelable序列化 不建议使用Android内置的抠脚Json解析器，可使用fastjson或者Gson第三方库！ ContentProvider使用方法 参考这篇文章 因为在Android系统里面，数据库是私有的。一般情况下外部应用程序是没有权限读取其他应用程序的数据。如果你想公开你自己的数据，你有两个选择：你可以创建你自己的内容提供器（一个ContentProvider子类）或者你可以给已有的提供器添加数据-如果存在一个控制同样类型数据的内容提供器且你拥有写的权限。而外界根本看不到，也不用看到这个应用暴露的数据在应用当中是如何存储的，或者是用数据库存储还是用文件存储，还是通过网上获得，这些一切都不重要，重要的是外界可以通过这一套标准及统一的接口和程序里的数据打交道，可以读取程序的数据，也可以删除程序的数据，当然，中间也会涉及一些权限的问题。 Thread、AsycTask、IntentService的使用场景与特点。 参考这篇文章 Android 原生的 AsyncTask.java 是对线程池的一个封装，使用其自定义的 Executor 来调度线程的执行方式（并发还是串行），并使用 Handler 来完成子线程和主线程数据的共享。 预先了解 AsyncTask，必先对线程池有所了解。一般情况下，如果使用子线程去执行一些任务，那么使用 new Thread 的方式会很方便的创建一个线程，如果涉及到主线程和子线程的通信，我们将使用 Handler（一般需要刷新 UI 的适合用到）。如果我们创建大量的（特别是在短时间内，持续的创建生命周期较长的线程）野生线程，往往会出现如下两方面的问题：每个线程的创建与销毁（特别是创建）的资源开销是非常大的；大量的子线程会分享主线程的系统资源，从而会使主线程因资源受限而导致应用性能降低。各位开发一线的前辈们为了解决这个问题，引入了线程池（ThreadPool）的概念，也就是把这些野生的线程圈养起来，统一的管理他们。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 使用线程池的风险？虽然线程池是构建多线程应用程序的强大机制，但使用它并不是没有风险的。用线程池构建的应用程序容易遭受任何其它多线程应用程序容易遭受的所有并发风险，诸如同步错误和死锁，它还容易遭受特定于线程池的少数其它风险，诸如与池有关的死锁、资源不足和线程泄漏。 死锁 任何多线程应用程序都有死锁风险。当一组进程或线程中的每一个都在等待一个只有该组中另一个进程才能引起的事件时，我们就说这组进程或线程 死锁了。死锁的最简单情形是：线程 A 持有对象 X 的独占锁，并且在等待对象 Y 的锁，而线程 B 持有对象 Y 的独占锁，却在等待对象 X 的锁。除非有某种方法来打破对锁的等待（Java 锁定不支持这种方法），否则死锁的线程将永远等下去。 虽然任何多线程程序中都有死锁的风险，但线程池却引入了另一种死锁可能，在那种情况下，所有池线程都在执行已阻塞的等待队列中另一任务的执行结果的任务，但这一任务却因为没有未被占用的线程而不能运行。当线程池被用来实现涉及许多交互对象的模拟，被模拟的对象可以相互发送查询，这些查询接下来作为排队的任务执行，查询对象又同步等待着响应时，会发生这种情况。 资源不足 线程池的一个优点在于：相对于其它替代调度机制（有些我们已经讨论过）而言，它们通常执行得很好。但只有恰当地调整了线程池大小时才是这样的。线程消耗包括内存和其它系统资源在内的大量资源。除了 Thread 对象所需的内存之外，每个线程都需要两个可能很大的执行调用堆栈。除此以外，JVM 可能会为每个 Java 线程创建一个本机线程，这些本机线程将消耗额外的系统资源。最后，虽然线程之间切换的调度开销很小，但如果有很多线程，环境切换也可能严重地影响程序的性能。 如果线程池太大，那么被那些线程消耗的资源可能严重地影响系统性能。在线程之间进行切换将会浪费时间，而且使用超出比您实际需要的线程可能会引起资源匮乏问题，因为池线程正在消耗一些资源，而这些资源可能会被其它任务更有效地利用。除了线程自身所使用的资源以外，服务请求时所做的工作可能需要其它资源，例如 JDBC 连接、套接字或文件。这些也都是有限资源，有太多的并发请求也可能引起失效，例如不能分配 JDBC 连接。 并发错误 线程池和其它排队机制依靠使用 wait() 和 notify() 方法，这两个方法都难于使用。如果编码不正确，那么可能丢失通知，导致线程保持空闲状态，尽管队列中有工作要处理。使用这些方法时，必须格外小心；即便是专家也可能在它们上面出错。而最好使用现有的、已经知道能工作的实现，例如 util.concurrent 包。 线程泄漏 各种类型的线程池中一个严重的风险是线程泄漏，当从池中除去一个线程以执行一项任务，而在任务完成后该线程却没有返回池时，会发生这种情况。发生线程泄漏的一种情形出现在任务抛出一个 RuntimeException 或一个 Error 时。如果池类没有捕捉到它们，那么线程只会退出而线程池的大小将会永久减少一个。当这种情况发生的次数足够多时，线程池最终就为空，而且系统将停止，因为没有可用的线程来处理任务。 有些任务可能会永远等待某些资源或来自用户的输入，而这些资源又不能保证变得可用，用户可能也已经回家了，诸如此类的任务会永久停止，而这些停止的任务也会引起和线程泄漏同样的问题。如果某个线程被这样一个任务永久地消耗着，那么它实际上就被从池除去了。对于这样的任务，应该要么只给予它们自己的线程，要么只让它们等待有限的时间。 请求过载 仅仅是请求就压垮了服务器，这种情况是可能的。在这种情形下，我们可能不想将每个到来的请求都排队到我们的工作队列，因为排在队列中等待执行的任务可能会消耗太多的系统资源并引起资源缺乏。在这种情形下决定如何做取决于您自己；在某些情况下，您可以简单地抛弃请求，依靠更高级别的协议稍后重试请求，您也可以用一个指出服务器暂时很忙的响应来拒绝请求。 Android的数据存储形式Shared PreferencesStore private primitive data in key-value pairs. Internal StorageStore private data on the device memory. External StorageStore public data on the shared external storage. SQLite DatabasesStore structured data in a private database. Network ConnectionStore data on the web with your own network server. Content Provider不能算是一种数据存储方式。它只是给我们提供操作数据的接口，Content Provider背后其实还是SQLite、File I\\O等其他方式 MVC for AndroidMVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。其中M层处理数据，业务逻辑等；V层处理界面的显示结果；C层起到桥梁的作用，来控制V层和M层通信以此来达到分离视图显示和业务逻辑层。 1.M层：适合做一些业务逻辑处理，比如数据库存取操作，网络操作，复杂的算法，耗时的任务等都在model层处理。2.V层：应用层中处理数据显示的部分，XML布局可以视为V层，显示Model层的数据结果。3.C层：在Android中，Activity处理用户交互问题，因此可以认为Activity是控制器，Activity读取V视图层的数据（eg.读取当前EditText控件的数据），控制用户输入（eg.EditText控件数据的输入），并向Model发送数据请求（eg.发起网络请求等）。 Android抽象布局——include、merge 、ViewStub 参考文章 &lt;include /&gt;标签能够重用布局文件 &lt;include /&gt;标签可以使用单独的layout属性，这个也是必须使用的。 可以使用其他属性。&lt;include /&gt;标签若指定了ID属性，而你的layout也定义了ID，则你的layout的ID会被覆盖，解决方案。 在include标签中所有的android:layout_*都是有效的，前提是必须要写layout_width和layout_height两个属性。 减少视图层级&lt;merge /&gt;标签在UI的结构优化中起着非常重要的作用，它可以删减多余的层级，优化UI。&lt;merge/&gt;多用于替换FrameLayout或者当一个布局包含另一个时，&lt;merge/&gt;标签消除视图层次结构中多余的视图组。例如你的主布局文件是垂直布局，引入了一个垂直布局的include，这是如果include布局使用的LinearLayout就没意义了，使用的话反而减慢你的UI表现。这时可以使用&lt;merge/&gt;标签优化。 需要时使用&lt;ViewStub /&gt;&lt;ViewStub /&gt;标签最大的优点是当你需要时才会加载，使用他并不会影响UI初始化时的性能。各种不常用的布局想进度条、显示错误消息等可以使用&lt;ViewStub /&gt;标签，以减少内存使用量，加快渲染速度。&lt;ViewStub /&gt;是一个不可见的，大小为0的View。&lt;ViewStub /&gt;标签使用如下： &lt;ViewStub android:id=\"@+id/stub_import\" android:inflatedId=\"@+id/panel_import\" android:layout=\"@layout/progress_overlay\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom\" /&gt; 当你想加载布局时，可以使用下面其中一种方法： ((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE); // or View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate(); 当调用inflate()函数的时候，ViewStub被引用的资源替代，并且返回引用的view。 这样程序可以直接得到引用的view而不用再次调用函数findViewById()来查找了。注：ViewStub目前有个缺陷就是还不支持 标签。 Json有什么优劣势优点： 数据格式比较简单，易于读写，格式都是压缩的，占用带宽小，浏览器解析快 易于解析这种语言，客户端JavaScript可以简单的通过eval()进行JSON数据的读取 构造友好，支持多种语言，包括ActionScript， C，C#，ColdFusion，Java，JavaScript，Per，PHP，Python，Ruby等语言服务器端语言，便于服务器端的解析 在PHP世界，已经有PHP-JSON和JSON-PHP出现了，便于PHP序列化后的程序直接调用，PHP服务器端的对象、数组等能够直接生JSON格式，便于客户端的访问提取 因为JSON格式能够直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量, 但是完成的任务不变, 且易于维护6.相当稳定。JSON 的附加内容将成为超集 缺点： 没有XML格式这么推广的深入人心和使用广泛，没有XML那么通用性 JSON格式目前在Web Service中推广还属于初级阶段 Asset目录与res目录的区别1.assets:不会在R.java文件下生成相应的标记，存放到这里的资源在运行打包的时候都会打入程序安装包中 2.res：会在R.java文件下生成标记，这里的资源会在运行打包操作的时候判断哪些被使用到了，没有被使用到的文件资源是不会打包到安装包中的。 在res文件夹下其实还可以定义一下目录： res/anim:这里存放的是动画资源。 res/xml:可以在Activity中使用getResource().getXML()读取这里的资源文件 res/raw:该目录下的文件可以直接复制到设备上，编译软件时，这里的数据不需要编译，直接加入到程序安装包中，使用方法是getResource().OpenRawResources(ID),其中参数ID的形式是R.raw.XXX. 显示Intent和隐式Intent区别对明确指出了目标组件名称的Intent，我们称之为“显式Intent”。对于没有明确指出目标组件名称的Intent，则称之为“隐式 Intent”。对于隐式意图，在定义Activity时，指定一个intent-filter，当一个隐式意图对象被一个意图过滤器进行匹配时，将有三个方面会被参考到： 动作(Action)类别(Category [‘kætɪg(ə)rɪ] )数据(Data ) 什么是线程池，线程池的作用是什么线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。就好比原来去食堂打饭是每个人看谁抢的赢，谁先抢到谁先吃，有了线程吃之后，就是排好队形，今天我跟你关系好，你先来吃饭。比如：一个应用要和网络打交道，有很多步骤需要访问网络，为了不阻塞主线程，每个步骤都创建个线程，在线程中和网络交互，用线程池就变的简单，线程池是对线程的一种封装，让线程用起来更加简便，只需要创一个线程池，把这些步骤像任务一样放进线程池，在程序销毁时只要调用线程池的销毁函数即可。单个线程的弊端：a. 每次new Thread新建对象性能差b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或者OOM,c. 缺乏更多功能，如定时执行、定期执行、线程中断。java提供的四种线程池的好处在于：a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。c. 提供定时执行、定期执行、单线程、并发数控制等功能。 Java 线程池Java通过Executors提供四种线程池，分别为： newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 (1). newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。 (2). newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 (3) newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。ScheduledExecutorService比Timer更安全，功能更强大 (4)、newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行 IntentService的用法一、IntentService简介IntentService是Service的子类，比普通的Service增加了额外的功能。先看Service本身存在两个问题： Service不会专门启动一条单独的进程，Service与它所在应用位于同一个进程中； Service也不是专门一条新线程，因此不应该在Service中直接处理耗时的任务； 二、IntentService特征会创建独立的worker线程来处理所有的Intent请求； 会创建独立的worker线程来处理onHandleIntent()方法实现的代码，无需处理多线程问题； 所有请求处理完成后，IntentService会自动停止，无需调用stopSelf()方法停止Service； 为Service的onBind()提供默认实现，返回null； 为Service的onStartCommand提供默认实现，将请求Intent添加到队列中； IntentService不会阻塞UI线程，而普通Serveice会导致ANR异常Intentservice若未执行完成上一次的任务，将不会新开一个线程，是等待之前的任务完成后，再执行新的任务，等任务完成后再次调用stopSelf Handler的实现原理handler干了些什么： 运行在某个线程上，共享线程的消息队列； 接收消息、调度消息，派发消息和处理消息； 实现消息的异步处理； 建立消息处理模型/系统 参考博客 Context与ApplicationContext的区别，分别用在什么情况下Application的Context是一个全局静态变量，SDK的说明是只有当你引用这个context的生命周期超过了当前activity的生命周期，而和整个应用的生命周期挂钩时，才去使用这个application的context。 在android中context可以作很多操作，但是最主要的功能是加载和访问资源。在android中有两种context，一种是 application context，一种是activity context，通常我们在各种类和方法间传递的是activity context。 View的绘制流程1.onmesarue() 为整个View树计算实际的大小 2.onlayout() 为将整个根据子视图的大小以及布局参数将View树放到合适的位置上 3.ondraw() 1 、绘制该View的背景2 、为显示渐变框做一些准备操作(见5，大多数情况下，不需要改渐变框)3、调用onDraw()方法绘制视图本身 (每个View都需要重载该方法，ViewGroup不需要实现该方法)4、调用dispatchDraw ()方法绘制子视图(如果该View类型不为ViewGroup，即不包含子视图，不需要重载该方法) 触摸屏幕的分发机制1、基础知识(1) 所有Touch事件都被封装成了MotionEvent对象，包括Touch的位置、时间、历史记录以及第几个手指(多指触摸)等。(2) 事件类型分为ACTION_DOWN, ACTION_UP, ACTION_MOVE, ACTION_POINTER_DOWN, ACTION_POINTER_UP, ACTION_CANCEL，每个事件都是以ACTION_DOWN开始ACTION_UP结束。(3) 对事件的处理包括三类，分别为传递——dispatchTouchEvent()函数、拦截——onInterceptTouchEvent()函数、消费——onTouchEvent()函数和OnTouchListener 2、传递流程(1) 事件从Activity.dispatchTouchEvent()开始传递，只要没有被停止或拦截，从最上层的View(ViewGroup)开始一直往下(子View)传递。子View可以通过onTouchEvent()对事件进行处理。 (2) 事件由父View(ViewGroup)传递给子View，ViewGroup可以通过onInterceptTouchEvent()对事件做拦截，停止其往下传递。 (3) 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数。 (4) 如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来。 (5) OnTouchListener优先于onTouchEvent()对事件进行消费。"}],"posts":[{"title":"The End Of 2016","slug":"the_end_of_2016","date":"2016-12-31T15:23:23.000Z","updated":"2019-01-06T06:01:13.126Z","comments":true,"path":"2016/12/31/the_end_of_2016/","link":"","permalink":"http://imxie.cc/2016/12/31/the_end_of_2016/","excerpt":"1因为自己的生日还蛮接近过年的，所以每次写年终，刚好是一个年岁。 今年开端那段时间是留在学校开发校园说吧，最后一天去公司撸了猫写了需求。有始有终还是挺好的。重邮一月大家都寒假回家，团队留在学校开发，第一次踩在真正的雪上，南方孩子蛮容易因为这个幸福感动的吧。记得那个时候自己的工位还是双屏，新垣结衣占据了一个大屏。开学自己搬出去住了，在顶楼，是房东在屋顶花园改造的房子。所以，晚上的雨滴和飞禽的落脚都听得一清二楚。不过，一直都有的热水，不断电的电脑，不用再害怕晚归，还有一个大大的衣柜，比在寝室确实要自由很多。窗台还养了多肉，生命力顽强的生物不用操心就长得不错。重庆春夏，雨季绵绵，得随时关窗，顶楼没有遮雨的棚子。现在回想才明白，生活的一些细节，是因为遭遇过，才知道。还很喜欢出租屋的阳台，因为顶楼的关系，少有的高度看南山的天空，有时候蛮想变成天上半明半暗的云。那里视野不错，拍下过最多的应该是黄昏时分，但不知道分享给谁，所以也删掉了很多。","text":"1因为自己的生日还蛮接近过年的，所以每次写年终，刚好是一个年岁。 今年开端那段时间是留在学校开发校园说吧，最后一天去公司撸了猫写了需求。有始有终还是挺好的。重邮一月大家都寒假回家，团队留在学校开发，第一次踩在真正的雪上，南方孩子蛮容易因为这个幸福感动的吧。记得那个时候自己的工位还是双屏，新垣结衣占据了一个大屏。开学自己搬出去住了，在顶楼，是房东在屋顶花园改造的房子。所以，晚上的雨滴和飞禽的落脚都听得一清二楚。不过，一直都有的热水，不断电的电脑，不用再害怕晚归，还有一个大大的衣柜，比在寝室确实要自由很多。窗台还养了多肉，生命力顽强的生物不用操心就长得不错。重庆春夏，雨季绵绵，得随时关窗，顶楼没有遮雨的棚子。现在回想才明白，生活的一些细节，是因为遭遇过，才知道。还很喜欢出租屋的阳台，因为顶楼的关系，少有的高度看南山的天空，有时候蛮想变成天上半明半暗的云。那里视野不错，拍下过最多的应该是黄昏时分，但不知道分享给谁，所以也删掉了很多。 从暑假开始到10月，蛮影响自己的人生轨迹吧，毕竟是对应届毕业生很重要的阶段。那段时间的故事其实在知乎回答 21 岁的你在干嘛？找到了人生奋斗的目标了吗？ 写的差不多了。想要感叹的是，一直以来，觉得很幸运的是，所有都是自己的选择，所有的决定自己没有后悔。 来到上海后，没有再在哥哥那里借住，找了一个在浦东新区合租房，离公司的话，过了一个下穿后还是感觉蛮近的，唯一缺点是离地铁站有点两个公交站，不是很方便。如果可能的话，毕业后搬家吧。房子里设备还是蛮新的，家电全齐，自己的单间中双人床和一个蛮大的衣柜，网上买了地毯和坐垫靠枕加上一个落地灯，组了一个角落，回来就可以窝在那里看书，觉得好赞，稍微有点生活的样子，以后会更好吧。 上海原来印象就是中国地图中右边沿海的一个城市，不至于大到哪里，踩在这片土地上后才知道，自己有多可笑。几个月下来，有点可惜的是，还不知道这个城市真正的魅力，自己才丈量了这座城市的十方一里。 还需要更多的时间，感受这张虚构的藏宝图。 2这年来，感觉最大的改变是学会了表达自己的感受和减少争论。 「做人不能太怂，把你的真诚，你的感受，你的想法一定要传达到。别犹豫不决，别傻逼怂蛋。」言表是最难的事情，逃避只能让你的想法确实成为空想。因为见过太多次对自己说的「算了吧」，向自己妥协与躲在自己的舒适区真是要了命。 「去除头脑里的宗教，偏激，仇恨和鄙视。每次仇恨一个东西，你就失去了向它学习的机会。」 这句话是王垠很久前的一篇文章说的，自己并非热衷粉丝或者抵触他的人。但这句话确实对我有所影响。大概我并不是那种偏执的人，所以会认可这句话。也是从这出发，开始明白和理解各有各的不同，毕竟世间没有万般通用的法子，生活中每个选择，都有当下的缘故。 之于感情，感触最深的是10月要去上海的时候，跟妹妹吃饭。她看着我说，「突然想起来，下次见你和图图都要用手数着日子了」。内心一揪。 其实也明白这些情感越长大就越会习惯。但目前我只明白，二十来岁的自己，最难受的事情就是去拥抱再见，最害怕的还是去跨越搁在你我的时间。 但「一约既定，万山无阻」。 3「如果你开发的应用你自己不经常用，那么你几乎不可能把它做好。」 其实在暑假后回校，这句话感觉就一直种下了。因为在根本不知道去做和该做什么的时候，这颗种子明确了自己的目标。我想写个好的应用，去认真做好一个产品，去认识更多优秀的有理想的人，剩下的能争取到的就努力争取，即使争取不到，这个应用是你的人生中的一个勋章，它是你一段时间的故事，可以讲给别人听，你高兴的时候可以打开它，它一直存在；挫折沮丧的时候，可以看看用户们鼓励和支持的评论。其实因为你的开发，已经对别人生活产生了细微的影响，这些都是你自己的成就和证明你存在意义的直观感受。 所以，一定要去开发自己喜欢的应用，让它变得更好，让越来越多的人喜欢。暗爽的同时一定要坚持。毕竟正好年轻，正好自己可以尽微薄的能力，去做一些自己认为有价值的事情，不会后悔。 4说一些对明年自己的期望。 16年觉得自己太过冷漠，什么都放得下又什么都不放不下。人不应该沉溺于过去，但也最好不要太过豁达和释然。 看不惯自我怜悯，但是现今又觉得只有这个年龄还好意思拥有垂帘的悲情。所以下次，我肯定会多抱一会。 得再相信自己是屠龙的勇士，左手有光，右手有剑，燃烧自己，让血沸腾。即使没有公主，血别凉，心别死。 很多时候，欲速则不达，只要走在一条正确的路上，那就够了。慢慢来，会很快。 要学会赚钱，钱不是俗物，是实现梦想的一个必需品。但不能只知道赚钱，要看书，买了 Kindle 得利用。 踏实一点，永远不要失去好奇心。想要的，都会有的。 永远得向前看，人生漫长，还有太多值得拥抱的事物等在前面。在这璀璨人间。 最后还有提交代码之前，再想想看。(๑˙ー˙๑)。 5 去岁一别，久疏问候。平安喜乐，万事胜意。 再见，2016.","categories":[],"tags":[],"keywords":[]},{"title":"魔都实习之旅","slug":"Intern-life-in-SH","date":"2016-07-10T22:09:42.000Z","updated":"2019-01-06T06:01:23.245Z","comments":true,"path":"2016/07/11/Intern-life-in-SH/","link":"","permalink":"http://imxie.cc/2016/07/11/Intern-life-in-SH/","excerpt":"Keep - Move - Think Day 1 丙申年 乙未月 甲午日 7点的东方航空。从重庆到上海浦东。顺风车是在5点，重邮新校门接的我，路上闲聊还知道，司机是老校友，那时候重邮末尾还跟着学院。 晚上十点左右收拾好东西，把华为的比赛作品也提交完成，还看完了 硅谷 第一季的最后两集。闷热，好像寝室的空调不怎么给力了，凌晨1点躺在床上还是觉得不舒服，辗转反侧，应该是没有睡着吧，一直等到四点半的闹钟，倒了垃圾，然后出发。 是靠窗的位置，眼睛还是特别累，马上又要去上海了，当初自己跟朋友明确表达过不喜欢的这个城市，然而人生 3.0 Hard Mode 起始点还是这里。 住在青旅，8人间，第一次住青旅，没有想象中的那么糟糕，也没有想象中的很多娱乐。有个法语专业的室友蛮有意思，当过兵，来上海是为了找一个跟专业相关的工作，所以住在“下一栈”青旅。他人还蛮好的，各种问题他都回答的蛮详细，后来才知道他以前早来过这里，并且还在这里兼过职。他跟我讲他在青旅认识的外国友人，他特别喜欢一个巴西的妹子，看上去很漂亮，而且才14岁。 吃过晚饭后，出去走了下，因为台风的原因吗？迎面而来的风特别肆虐，不过还好不闷热，蛮舒服。今天办好了招行的卡，明天早上就准备去公司入职了。说实话还是蛮期待的。嗯，晚安，加油。","text":"Keep - Move - Think Day 1 丙申年 乙未月 甲午日 7点的东方航空。从重庆到上海浦东。顺风车是在5点，重邮新校门接的我，路上闲聊还知道，司机是老校友，那时候重邮末尾还跟着学院。 晚上十点左右收拾好东西，把华为的比赛作品也提交完成，还看完了 硅谷 第一季的最后两集。闷热，好像寝室的空调不怎么给力了，凌晨1点躺在床上还是觉得不舒服，辗转反侧，应该是没有睡着吧，一直等到四点半的闹钟，倒了垃圾，然后出发。 是靠窗的位置，眼睛还是特别累，马上又要去上海了，当初自己跟朋友明确表达过不喜欢的这个城市，然而人生 3.0 Hard Mode 起始点还是这里。 住在青旅，8人间，第一次住青旅，没有想象中的那么糟糕，也没有想象中的很多娱乐。有个法语专业的室友蛮有意思，当过兵，来上海是为了找一个跟专业相关的工作，所以住在“下一栈”青旅。他人还蛮好的，各种问题他都回答的蛮详细，后来才知道他以前早来过这里，并且还在这里兼过职。他跟我讲他在青旅认识的外国友人，他特别喜欢一个巴西的妹子，看上去很漂亮，而且才14岁。 吃过晚饭后，出去走了下，因为台风的原因吗？迎面而来的风特别肆虐，不过还好不闷热，蛮舒服。今天办好了招行的卡，明天早上就准备去公司入职了。说实话还是蛮期待的。嗯，晚安，加油。 Day 2 丙申年 乙未月 乙未日 七月十二日 每天记录还是不现实的，但今天是第一天入职，还是有很多体会。 早上7点就自然醒了，到公司是9点，人蛮少的，溜达了一转，觉得蛮酷。配了一个戴尔的屏幕，我是自带的 MBP ，所以环境什么的完全不需要配置。入职需要走一些流程，填表啊，申请邮箱啊，还要给全公司发介绍信。椅子坐着很舒服，公司蛮弹性的，而且没很多条条框框，待着很舒服。 晚上自愿加下班，九点坐了公交再走段路回青旅。 在上海，大家都嫌弃纸币喜欢硬币。在上海，公交车说三种语言，就普通话声小。在上海，地铁公交人满了下一班次也是满的。在上海，感觉是一个特繁华的重庆。在上海，遇到阿姨别叫嬢嬢了。 不过遇到了很多有意思的人。对了，最近还喜欢李悦君的《梦伴》这首歌。 Day 10 丙申年 乙未月 癸卯日 周末跟上海的 Android 开发网友小聚，见到了给予我蛮多帮助的天哥和猴哥。大家都是特别有意思的家伙。 从青旅搬家到了哥哥那里住，浦东新区，开始挤地铁去上班，坐一个半小时。需要从2号线南京东路换乘10号线到江湾体育场。在地铁上蛮花时间的，所以这几天也养成了背单词，刚好在早上，花点不多的时间，把软件上的每日60词刷完。 到了公司10点左右，开站会，早上自己决定看书，下午做项目。其实来这里公司环境还是可以，同事们也都友善易相处。唯一对我来说的缺点就是没有能够聊 Android 的人吧。 校招也开始了，确实好快，又是一波面试。虽然总能受到周遭人的鼓励和认可，但是自己几斤几两特别清楚。 Day 26 丙申年 乙未月 庚申日 很久没有更新这个篇章，上班真的蛮磨人的，从公司到住的地方需要一个半小时，回到家之后就特别累了然后就想休息，带回来的电脑然后明天又背着回去。 今天一大早也拿到了半个月的工资，特别愉悦~本来今天周六，下午3点还是来公司学习，居然还碰到了运维的两个小伙伴。晚饭点的外卖，韩寒的那家，感觉没有他们说的那么难吃嘛。 DaoVoice 这周走了两个前端小伙伴，DaoCloud 也有其他部门的小伙伴离职，感觉在工作之后，分离也开始变得平常了起来，来来去去的，可能是因为第一次经历吧，或许以后会习惯的。所以更加理解了一期一会的意思，得要以最好的方式对待对方。 最近的成果还是蛮明显的。DaoVoice 框架+第一层逻辑已经完成，还完成了自己的小玩具，是运用 Leancloud 的云引擎——这都被你找到了 越来越喜欢上海了诶。第一次来上海是带着玩的心态，这次是却是来生活，体会比原来更细致。 Last浦东国际机场 宝山路 下一栈青旅 南京东路 五角场 广兰路 张江 香楠小区-波司登大厦 老板娘日式料理 米馆的火车头 暖食的侧脸服务员 星巴克的买二送一 全家的味全优酸乳 隔壁的盒装水果-小米粥 家制酸粉 家制混合饮品 望湘园 PizzaExpress 游轮晚宴 星怡会 家府潮仙菜-中山公园 龙之梦 （桂满陇）末那寿司 动漫画展 南京大牌档 香天下火锅 蕉叶 江湾体育场 西北狼烧烤 85℃ 蒸青年 上海歌神-钢炼 李狗嗨 请回答1988 gakki 乖巧 羁绊 友谊之水 中二之魂 嗨歌 歇斯底里 再见 朋友 写真集 月饼盒 两封信 同理心-香楠小区 张江 广兰路 虹桥-“有事开口，不要客气”“天涯海角，唯望君安”-再见，上海。这座偶尔温暖的城市。","categories":[{"name":"发骚","slug":"发骚","permalink":"http://imxie.cc/categories/发骚/"}],"tags":[{"name":"实习","slug":"实习","permalink":"http://imxie.cc/tags/实习/"}],"keywords":[{"name":"发骚","slug":"发骚","permalink":"http://imxie.cc/categories/发骚/"}]},{"title":"愿你来时相见欢快，也愿你走后道别忘怀","slug":"给胖子的信","date":"2015-03-16T09:41:39.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"2015/03/16/给胖子的信/","link":"","permalink":"http://imxie.cc/2015/03/16/给胖子的信/","excerpt":"&lt; /1&gt; 一直都没有怎么写过东西给你吧。 其实很多话还是落在笔头上比说出来的要好很多。毕竟语言在伤人的时候比感动要更容易。我比自伤更不愿意去伤害自己身边的人，之于这一点相比你应该是清楚的。从糖糖那里我清楚的明白，像我们这样总给身边朋友乐呵呵样子的人，是藏不住快乐和喜悦的，但憋得住难过与伤心。很多伤疤其实在我们说出来的时候，早就觉得已经没有什么了。对于最后的结尾也只能接受了，不过我还是很感谢那么长时间的陪伴，毕竟我也感受到自己的成长。 我这人忽冷忽热，性格使然。自己能尽力做好的事情绝不会去麻烦别人。偶尔会装下疯，卖下傻，觉得开心最重要。偏爱的还是单独的对话，一个群体的环境会觉得小无助。 像觉得你搞笑就是傻的人，果真不能深交。这是我最近体会到的。而且我最近越来越变得不再会为自己去辩护什么了。与那些不了解你就随意定义你如何的人浪费那么多时间与口舌真是不值。我一直都想让自己变得比昨年的自己要成熟，成熟的男人，有一点就是清楚明白自己是怎样的人，没有必要为自己去辩护。 水瓶座的人都有两面。 若是全部展现给你，那么你真是那个不多的身边的人。","text":"&lt; /1&gt; 一直都没有怎么写过东西给你吧。 其实很多话还是落在笔头上比说出来的要好很多。毕竟语言在伤人的时候比感动要更容易。我比自伤更不愿意去伤害自己身边的人，之于这一点相比你应该是清楚的。从糖糖那里我清楚的明白，像我们这样总给身边朋友乐呵呵样子的人，是藏不住快乐和喜悦的，但憋得住难过与伤心。很多伤疤其实在我们说出来的时候，早就觉得已经没有什么了。对于最后的结尾也只能接受了，不过我还是很感谢那么长时间的陪伴，毕竟我也感受到自己的成长。 我这人忽冷忽热，性格使然。自己能尽力做好的事情绝不会去麻烦别人。偶尔会装下疯，卖下傻，觉得开心最重要。偏爱的还是单独的对话，一个群体的环境会觉得小无助。 像觉得你搞笑就是傻的人，果真不能深交。这是我最近体会到的。而且我最近越来越变得不再会为自己去辩护什么了。与那些不了解你就随意定义你如何的人浪费那么多时间与口舌真是不值。我一直都想让自己变得比昨年的自己要成熟，成熟的男人，有一点就是清楚明白自己是怎样的人，没有必要为自己去辩护。 水瓶座的人都有两面。 若是全部展现给你，那么你真是那个不多的身边的人。 &lt; /2&gt; 人与人真有独特的磁场彼此吸引你信吗。 当时应该是一节英语课，我那时也不认识班上的任何人。你来的很早，坐在位置上等着上课。我进了教室，看到你后就坐在你旁边。课上的内容很枯燥，我没有听，我观察你拿着本子认真的做着笔记，字很好看，还有左耳上的耳钉。你的动作不快不慢，徐缓让人觉得心静平和。下课的时候，你去上厕所，我偷偷去翻看你笔记的扉页，知晓了你的名字，刘瀚聪。 你很特别，所以我一定会认识你。当时我就是那么想的。 观音桥的寿司店，杨师傅那里的痛哭，幸福喷泉的广场，纯K的下午场，14年11月的机场，家里你亲自做的咖喱。 还有很多事情，自己也不愿意去具化感情，因为一说，就感觉有了一个框，在框里按着规则去照做。但你一定是我唯一的最亲爱的胖友，在我微信的置顶，心上的一二三。 &lt; /3&gt; 我们谈过回忆，谈过感情，却从未谈过未来。 经过这个寒假，自己清醒的感觉以后路的艰苦，并且现在的自己并无一技之长。所以我才开始认真的对待专业，并放弃一些事情腾出时间去学习。我自身也是爱的，所以学习其中并没有什么痛苦。 明白自己大一荒废了一年。除了维系了感情之外并没有其他收获，时间很紧，需要学习的东西很多，我每时每刻都告诉自己别慌张，也别急于求成，那样反而什么事情都做不好。我明白自己内心阴暗，会嫉妒别人需要做什么以后一样的有出路，会虚荣自己一点点不值一提的小成就，会眼红别人的朋友很多很好一呼百应。仔细想想，很多时候我们的成长真是依赖这些负能量，而不是天生的善良。 “想要的很少拥有的很多”。这句话评论李健再适合不过。我希望未来的自己就是能够做到那样。像我这种佳肴三千，都爱白饭的人，应该还是很容易满足的。 大二这最后的学期努力学习JAVA，然后进阶自己喜欢的Andriod，并且一次性通过六级。大三报考N2，学习自己感兴趣的日语。 “少年，我问你，你的梦想都死到哪里去了。你拍拍自己的胸口，它还在这里啊，一直在这里啊。我呸。你就安慰自己吧。你尽管为平庸找出一百个借口吧。你继续蜗居在自己的狭窄世界里吧。你不再是漫不经心就可以邀得全世界宠爱的孩子了。 你想到的，就去做吧。”这段是北漂贴吧的置顶贴。正好应和你说过一个学姐的一句话，不努力就会死。现今的我觉得最适合当下的年纪了，我也不再会把一些话当成只是说说而已。 我很难想过未来会光鲜的自己，反而觉得刚好能顺心意平凡而不平庸的过日子就已足够。并且希望四十来岁的时候，自己有能力去学木工，以后做个手艺人，身上带有樟木的香，阳光洒在自己小院，日子很慢，一年也就那几把椅子，几样小玩意。 &lt; /愿你来时相见欢快，也愿你走后道别忘怀&gt; 哈，自己写东西又写了一大堆关于自己的。 不过呢，这些都是平常说不出的话。马上你就要飞往另外一个国度，再也不能像以前一样打个电话发个微信就可以约着见一面。虽说只有一年时间，我也曾说过担忧，一年很短，但一年可以发生的事情很多。但是我觉得有些坎，一个人肯定是跨不去，所以需要另一方的协助，这种共识的感情是两个人的事，所以才被叫做友情吧。 你是我唯一的胖友，有些事情你明白我为何那么坚持，有些事情你也清楚我为何那么感慨。我也希望你明白我们彼此掏过心吐过衷肠这份真诚与在意是不变的，我们用过真心就不会有差错。 所以有时候带有感情的时间真是神奇，可能2016年的某一月某一天我们重逢。你好像瘦了，头发也变短了，见你是一年前的事。然后你开口叫我名字，我就想笑，好像自己背着书包，只在校门口里等了你五分钟而已。","categories":[{"name":"发骚","slug":"发骚","permalink":"http://imxie.cc/categories/发骚/"}],"tags":[{"name":"发骚","slug":"发骚","permalink":"http://imxie.cc/tags/发骚/"}],"keywords":[{"name":"发骚","slug":"发骚","permalink":"http://imxie.cc/categories/发骚/"}]},{"title":"信笺","slug":"信笺","date":"2015-01-26T14:36:00.000Z","updated":"2019-01-06T06:02:01.526Z","comments":true,"path":"2015/01/26/信笺/","link":"","permalink":"http://imxie.cc/2015/01/26/信笺/","excerpt":"给姑娘的信展信佳。 说着要给你写信的，这个事情应该是在期末考试前答应你的。当时的自己还觉得应该回了家没多久就可以提笔写信然后寄给你。无奈自己的性子，回到了家就有了脾性，贪玩懒惰浮躁很多不好的东西像打开一瓶被摇过后的碳酸饮料来不及反省就一下子全涌了出来。 嗯。跟你写信想展现的可不是这样在家堕落的自己。还记得我有次微信跟你描述我在家里的样子吗？“我在家里最喜欢的地方就是自己电脑 因为在家里有熬夜的习惯 没什么事情 但还是习惯熬夜到深夜 有时候爸妈睡着了 家里安静到仿佛可以听见明早初阳穿过薄云的破空声 自个端上一杯热饮 坐在电脑椅上打转 心里很静 夜里很暖”。现在的我只留了客厅的壁灯，窝在沙发上用笔记本敲字，房间很安静，只能听到自己敲键盘的声音，或窗外深夜里偶有的汽车鸣笛。回来也有些日子了，但今儿能这样静下来却是头一回。我自己没有先用笔纸写给你的信，莫怪便是。 姑娘啊，姑娘。这个名字其实让我最开始想起的是我初三毕业那会儿，在一个论坛里写了一部短篇小说，也就3000字左右。然后结识了一群喜欢文艺的人儿，年龄有大有小，但人都挺好。里面有个北京女孩，单单，喜欢被人叫姑娘。因为是副版主，当时我第一次在网络上发东西，没有一点排版经验，她加了我Q，得我允许后帮我调整，后来在群里经常互动，说话挺小女生的那种可爱，但文字细腻动人。因为年龄相差不大，聊天没有代沟，自然也熟络了起来。我知道了很多她的事情，她一直喜欢一个叫石灰的大叔，也是论坛里的，她日志里的所有碎碎念全是关于他的，也听说过她也自己坐火车去找过石灰。不过，我当时听到的时候，她已经喜欢石灰有一两年了，直到后来这个论坛没落，我还是没有听说姑娘跟石灰成了。姑娘她是个话唠，石灰被她一直念着，感觉像是她怕这种感情的不确定所以需要时刻的念叨提醒自己这种存在感。当然这些只是自己猜测罢了。还忘记说了，那个论坛的名字叫蔓延。 再说一个小情节，是自己小学六年级的时候。老妈每天都会给我一块钱，当时我一点都不舍得去买学校外面各种好吃的零食，我会好好存起来。这样每一周我就会存到七块钱，到了第二周的星期一，我就会很早的去上学，在校门外的右边第二个巷子路口的超市里买走一块收银台第三个零食小架上摆的德芙巧克力。继而在早读之后，我会假装路过她的桌子将巧克力放在桌子右上角，然后小跑着出教室去上厕所。那时候的女孩比我们高，比我们成熟，我一直在她面前都有自卑的感觉，以至于到了现在我面对自己喜欢的女生都会产生这样的心理。但是我一直对表白这种事情从来不会畏惧，六年级上学期的一个晚上，我表白成功。激动得睡不着，甚至害怕明儿去见她。六年级下学期毕业后三天，她上了飞机去了汕头，跟我说了三年之约，初中毕业，等她回来再在一起。期间平平淡淡接近一年的时间，我们大多的对话都是通过短信或者QQ，我害怕；我们没有牵过手，我们没有拥抱过，我们没有一次约会，我们有唯一的合照就是毕业照，我站在最后一排的最左边，她站在第二排的最右边，我面无表情的看着镜头，她笑起来的酒窝很可爱。 其实这段感情自己很少去回忆的，小学的时候过家家的怎么叫恋爱。可是，有时候我觉得那个时候男孩单纯的欢喜与渴望，简单的心动可轻易感知，纯真的爱恋无所奢求，着实可贵，男孩曾经喜欢过她，她一直就坐在他的左后方。 前面说了些自己的故事，平常自己没有那么多耐心和心思去写。有一次自己乱想就偶然发现“噢，怎么突然跟你那么熟了”，和你相知相遇到相识我觉得一点刻意都没有，所以才会发出那种感叹，但是自己却是欢喜不行，这种没有刻意为之得到的感情就像是突然找到了忘记没有打开的礼物盒，发现里面的东西自己喜欢的不行。 就是这种久别重逢的感觉，并非一见如故。","text":"给姑娘的信展信佳。 说着要给你写信的，这个事情应该是在期末考试前答应你的。当时的自己还觉得应该回了家没多久就可以提笔写信然后寄给你。无奈自己的性子，回到了家就有了脾性，贪玩懒惰浮躁很多不好的东西像打开一瓶被摇过后的碳酸饮料来不及反省就一下子全涌了出来。 嗯。跟你写信想展现的可不是这样在家堕落的自己。还记得我有次微信跟你描述我在家里的样子吗？“我在家里最喜欢的地方就是自己电脑 因为在家里有熬夜的习惯 没什么事情 但还是习惯熬夜到深夜 有时候爸妈睡着了 家里安静到仿佛可以听见明早初阳穿过薄云的破空声 自个端上一杯热饮 坐在电脑椅上打转 心里很静 夜里很暖”。现在的我只留了客厅的壁灯，窝在沙发上用笔记本敲字，房间很安静，只能听到自己敲键盘的声音，或窗外深夜里偶有的汽车鸣笛。回来也有些日子了，但今儿能这样静下来却是头一回。我自己没有先用笔纸写给你的信，莫怪便是。 姑娘啊，姑娘。这个名字其实让我最开始想起的是我初三毕业那会儿，在一个论坛里写了一部短篇小说，也就3000字左右。然后结识了一群喜欢文艺的人儿，年龄有大有小，但人都挺好。里面有个北京女孩，单单，喜欢被人叫姑娘。因为是副版主，当时我第一次在网络上发东西，没有一点排版经验，她加了我Q，得我允许后帮我调整，后来在群里经常互动，说话挺小女生的那种可爱，但文字细腻动人。因为年龄相差不大，聊天没有代沟，自然也熟络了起来。我知道了很多她的事情，她一直喜欢一个叫石灰的大叔，也是论坛里的，她日志里的所有碎碎念全是关于他的，也听说过她也自己坐火车去找过石灰。不过，我当时听到的时候，她已经喜欢石灰有一两年了，直到后来这个论坛没落，我还是没有听说姑娘跟石灰成了。姑娘她是个话唠，石灰被她一直念着，感觉像是她怕这种感情的不确定所以需要时刻的念叨提醒自己这种存在感。当然这些只是自己猜测罢了。还忘记说了，那个论坛的名字叫蔓延。 再说一个小情节，是自己小学六年级的时候。老妈每天都会给我一块钱，当时我一点都不舍得去买学校外面各种好吃的零食，我会好好存起来。这样每一周我就会存到七块钱，到了第二周的星期一，我就会很早的去上学，在校门外的右边第二个巷子路口的超市里买走一块收银台第三个零食小架上摆的德芙巧克力。继而在早读之后，我会假装路过她的桌子将巧克力放在桌子右上角，然后小跑着出教室去上厕所。那时候的女孩比我们高，比我们成熟，我一直在她面前都有自卑的感觉，以至于到了现在我面对自己喜欢的女生都会产生这样的心理。但是我一直对表白这种事情从来不会畏惧，六年级上学期的一个晚上，我表白成功。激动得睡不着，甚至害怕明儿去见她。六年级下学期毕业后三天，她上了飞机去了汕头，跟我说了三年之约，初中毕业，等她回来再在一起。期间平平淡淡接近一年的时间，我们大多的对话都是通过短信或者QQ，我害怕；我们没有牵过手，我们没有拥抱过，我们没有一次约会，我们有唯一的合照就是毕业照，我站在最后一排的最左边，她站在第二排的最右边，我面无表情的看着镜头，她笑起来的酒窝很可爱。 其实这段感情自己很少去回忆的，小学的时候过家家的怎么叫恋爱。可是，有时候我觉得那个时候男孩单纯的欢喜与渴望，简单的心动可轻易感知，纯真的爱恋无所奢求，着实可贵，男孩曾经喜欢过她，她一直就坐在他的左后方。 前面说了些自己的故事，平常自己没有那么多耐心和心思去写。有一次自己乱想就偶然发现“噢，怎么突然跟你那么熟了”，和你相知相遇到相识我觉得一点刻意都没有，所以才会发出那种感叹，但是自己却是欢喜不行，这种没有刻意为之得到的感情就像是突然找到了忘记没有打开的礼物盒，发现里面的东西自己喜欢的不行。 就是这种久别重逢的感觉，并非一见如故。 给宽宽一：自己收到你发给我信息的时候，我还没有睡觉，当然也没有像你说的那么敬业地在看他们发给我的竞聘报告。是刚好跟室友看完了跑男，周主席微信跟我聊科联的一二三。几个小时之前，是在跟排球队的一起吃饭喝酒，在KTV的时候是把他们的竞聘报告都看了一遍。自己熬不起夜，陪他们到23点后就起身回宿舍，回来的路上偶遇自己的网球师父——他是光电跟我同届，大一第一次上体育课认识就一直联系着。 果然自己讲故事的能力真的差太多。前面的只是一些关于自己的琐事，突然发现一些关系随其自然发展起来反而比刻意经营要长久和舒适。我的大一一年，有两位我很想一直长久下去的朋友，到现在一个相见都觉尴尬不如陌路，另一个打个照面就招呼彼此都明白这个关系的温度早已到达零下。不过他们两个也足够在以后会让我记着一阵子了，自己总有作的成分在里面，明知道他们就类似已经插在自己心上的刀子，自己却还要每每回忆一点一点的推进它。我把这个称为人的贱性。也不明白这样去自找伤害到底是急于想要获得什么，不过还好，自己之于很多事情一旦想不透彻就会在暂且抛在脑后，去找些自己感兴趣的事情消磨。 一个他告诉我，从来没有遇见过和我一样看不清自己的人还是说像我一样的人都一样背着壳不让人看见，我们自以为善于为伪装容易歆羨，喜欢新鲜还怕孤独，享受寂寞又追求爱情，在热烈的后一秒是哭得不知所措，总是做很多觉得值得去付出的事然后又莫名的忏悔，自省的分度永远高于践行的精度，光鲜外表腐烂内心，爱面子爱到面红耳赤，把模仿吸收变成本能，把一个人活生生拆分成很多很多分别展示给对应的同类。他一下说中自己的软肋，你能想象当时自己有多语塞。直到最后眼看关系破裂却也无能为力，自己也只能告诉自己义无反顾地去信任，就要承受无条件的伤害。这些看上去真的像是弱者给自己找的一个又一个好听的借口。 有些人在你面前时，你很难说一声谢谢。然而他们离开之后，你却有千言万语想说给自己听，或者也希望，有一天他能够看见。突然又矫情了。 二：宽宽明白很多，懂得很多道理，其实也没必要我在这里老生常谈，你能他人一提就明白。最开始认识你的时候，从来没有质疑过你的能力，很多事情交给你放心你一定是可以办成，佩服你的强大。不过越强大的人他内心的柔弱就会比他人更加敏感，攒着越紧反而愈加害怕。初见就欢喜你，是心觉你的气场与我高中那位才女特别相似，她有那种独特的决心与气魄，跟她为班级写诗朗诵，听她讲韩寒，分享某部电影的自我理解，自己常常暗自佩服，内心紧张到及其希望对方认可。不过我也看到过她在自己面前哭得像个孩子。我也不明白，很多时候都会拿你与她类比，盖莫自己总很难在彼此对峙中流畅顺利的交谈，往往陷入语塞，都是通过笔纸亦或网络工具才能将自己的思路与想法诠释清楚吧。所以你也看到了三哥他不明白要如何用词句正确表达的时候了吧。 我们也明白对你的高期望这样的病态，浑然忘记了你也是一个姑娘，也是一个学妹，对你的能力与不明白该教给你什么这样的茫然，对你也是一件不公平的事情。但是许多事情跟能力没有关系，只跟阅历有关，所有该经历的东西终究会亲自经历，遇到的苦恼麻烦一个都不会少。姑娘都会有任性，索求，认可，信任，所以我依旧记得你因我试探的短信冲我们吼的那晚。不过恰好也让我们明白了，你其实也是一个小女生。 听闻你在红岩那边不顺，又不好厚颜无耻再回头去竞选项管。其实啊这个世界上你要做一件事情，会有人泼冷水。你做成了一件事情，会有人唱反调。你做好了一件事情，会有人说你靠运气。碌碌无为者最安全，无所事事者爱嘲笑。前面风景正好，要做的，就是埋头赶路，把嘲笑和质疑丢在风里。 好像在生日写这些有点奇怪，不过我仅仅是想宽宽能够得到你理应的东西，更希望宽宽能够发更大的光，介意了太多，还不如撒开了手了去做。 三：十九岁的宽宽，十九岁的小排球，生日快乐。 虽然三哥很多时候没有那么主动的表现关心，但是你做的每件大的事情，偶尔的小心情，他都会关注而且记得。并且希望宽宽能够更加乐观，生活确实有很多无奈，和不敬人意。 这个世界没有我们想象得那么美好，但也没有他们说得那么糟糕。 最后这句话我自己很喜欢，赠与你： 天下唯庸人无咎无誉，不要怕失败。","categories":[{"name":"发骚","slug":"发骚","permalink":"http://imxie.cc/categories/发骚/"}],"tags":[{"name":"发骚","slug":"发骚","permalink":"http://imxie.cc/tags/发骚/"}],"keywords":[{"name":"发骚","slug":"发骚","permalink":"http://imxie.cc/categories/发骚/"}]},{"title":"The End Of 2014","slug":"2014年终","date":"2014-12-30T16:28:50.000Z","updated":"2017-08-11T03:02:07.000Z","comments":true,"path":"2014/12/31/2014年终/","link":"","permalink":"http://imxie.cc/2014/12/31/2014年终/","excerpt":"&lt;/可是我不明白自己——2014年终&gt; 不管用什么语言，我们人生中都会有解释起来太困难的事。 十八岁是一个节点，以前都一直会认为时间都走很慢，一直都盼着自己快点长大；十八岁之后，觉得时间就像握在手里的沙，眼睁睁看着流逝但是自己却无可奈何。现在我已经大二，并且已过半。昨年高三，明年大三，又到了该去思考自己的时候了。像高二的时候给自己写的那封信，觉得写给的对象还是太年轻，就是想着再拿出来看时，还是会唏嘘那个时候自己的理性自己的觉悟，但是现在的自己没有做到，也不明白现在的自己与当初那个少年有了怎样的进步，怎样的成长，或者我又变成了怎样的人，是默默朝着当时希望的方向前进还是变成了以前一直憎恶的那种人。 我觉得自己很简单，有些事情我就喜欢感情用事，我不愿意用理性去分析自己的感情，喜欢就是喜欢，不愿意就是不愿意。所以你在心里为我留了一块地，我就甘心为你建一栋房。我觉得这个年纪不该有的成熟与老练可以不用假装，但绝对不能幼稚。身边的坏人不多，大家保护欲太强，拿出真心去试一试，比一直隔着沟壑小心交涉害怕受伤，要好的多得多。 就像下半年，一直口头念叨的那句话，去奔赴，去爱，欣然接受伤害。正年轻，太阳底下，没什么坏事儿。","text":"&lt;/可是我不明白自己——2014年终&gt; 不管用什么语言，我们人生中都会有解释起来太困难的事。 十八岁是一个节点，以前都一直会认为时间都走很慢，一直都盼着自己快点长大；十八岁之后，觉得时间就像握在手里的沙，眼睁睁看着流逝但是自己却无可奈何。现在我已经大二，并且已过半。昨年高三，明年大三，又到了该去思考自己的时候了。像高二的时候给自己写的那封信，觉得写给的对象还是太年轻，就是想着再拿出来看时，还是会唏嘘那个时候自己的理性自己的觉悟，但是现在的自己没有做到，也不明白现在的自己与当初那个少年有了怎样的进步，怎样的成长，或者我又变成了怎样的人，是默默朝着当时希望的方向前进还是变成了以前一直憎恶的那种人。 我觉得自己很简单，有些事情我就喜欢感情用事，我不愿意用理性去分析自己的感情，喜欢就是喜欢，不愿意就是不愿意。所以你在心里为我留了一块地，我就甘心为你建一栋房。我觉得这个年纪不该有的成熟与老练可以不用假装，但绝对不能幼稚。身边的坏人不多，大家保护欲太强，拿出真心去试一试，比一直隔着沟壑小心交涉害怕受伤，要好的多得多。 就像下半年，一直口头念叨的那句话，去奔赴，去爱，欣然接受伤害。正年轻，太阳底下，没什么坏事儿。 &lt; /1&gt; 与好友相处的时光是特别放松和愉悦的，年头结束考试之后就赶回去，与他们喝酒。也不知道是怎样兴起，跟高中那几个举杯成了每个假期必做的事情。“韩国自助烧烤 两斤四两梅子酒 三瓶勇闯加冰 喝道夜深后 在无人的高中教学楼里 玩起捉迷藏”，男人至死都是少年，就像厄尔曼写的那篇《青春》我记忆最牢就是“无论年届花甲，抑或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰“。 其实自己一直不明白如何去维系一段感情，自己的性格就是不爱麻烦，许多事情自己能够解决一定会自己去做了。没有事情的时候绝对不会随意找你，但是你的动态你的近况我这边都会有了解。我喜欢的也就是这样，各自做着自己的事情，互不打扰，偶尔想起叙叙家常，随意聊聊说说身边的事，平淡且细腻。其实许多人是受不了这样的平淡，还是会在我这样表面和行动上淡如水，心里却想你念你百次的方式中隔阂，渐渐淡出了我的生活，最开始的时候自己特别难过，想不明白人情的冷暖，感觉社会的快节奏把太多事情都点了快进，一些感情我还来不及去感受，它就变成了我存在冰箱里最后一瓶牛奶，等到想喝的时候却发现它已经变了质。 像交换写了接近一年日记的人，本以为自己会是你生命中的一二三，却还是败给了什么，落成你人生中的路人甲乙丙；像与你彻夜聊天，并排喝酒谈人生谈理想谈生活中的柴米油盐，最后一个私心一个无意，断了联系，一句话也不愿意再彼此倾诉了；像大多数的人真的就只是淌过你这条河流的匆匆行人。以上也别那么轻易对号入座，像很多话我说出来，到底也只是说给自己听的。 生性乐观的人，没有太多的烦心事，自认为是由于把太多负面情绪都选择性遗忘了吧，把许多事情都去除感情只平白记忆，这样的记录能让自己不受影响地回忆起彼时种种。难过的事情自然是有，但总觉得生活中开心的事情中要占更多，以前要好的人，现在如若路人，这个确实特别心塞，可是自顾的悲伤难受，对方不会知道，更不会去体谅。认清这个现实的时候，我发现身边依旧有自己爱着的共同创造了好多回忆的小分队，有机缘巧合志趣相投同舟共济的象馆另外两位家长以及现在二十六个小象，还有互相构建彼此生活的一二三。 这并列的珍贵的感情，让我不能悲伤的坐在你的身旁。 到了冬天身边脱单人也多，敢等待敢付出就是不敢及时地说爱的人也多。落下的只是自己的一厢情愿，更多则是自己的不甘心与难以启齿的委屈。 如若认清下自己一味付出的徒劳只是道德式的自我感动，很多事情也就变得没有那么不明取舍了。你拿起的只是一捧逐渐从指间流失的沙，还不如一把向风抛了打自己一脸的痛要来得洒脱。 义无反顾地爱，就要去承受无可避免的伤害。 &lt; /2&gt; 这年其实做了很多有意义的事情。 Eason的一场演唱会。对于自己这种不追星不痴迷的人来说，这种事情去尝试一次其实蛮好，气氛真的很容易带动人，自己其实也不明白不自禁地就跟着大声歌唱是为了什么，但是好像很多事情是不需要去问的，因为本身就是没有原因。 五一的时候去川外跟老友去骑行，奇遇救了一个摔倒在山路边的骑友，后来乱了行程就返程回了川外，改了活动玩着依旧开心。 养成了每月都要去涂山寺拜佛的习惯，我不信佛，但是我信一个人跟我说的话，想想也不是什么坏的习惯，所以也就不愿意去改了。 大学军训，自己打了真枪剃了寸发。 初步涉猎魔术这个圈子。明白任何东西想要做好，并不是自己想的那么简单，需要花费你大量的时间与精力。魔术的背后，更是艺术，关于一个人的气质与表演的综合。这方面，自己并没有做好。 一场旅行。我愿不远万里，只为与你把酒言欢。 大二上是关于部门与组织。熬过夜失过眠一心思的做着事，期间也有很多误解与纠纷，不过最后都相安无事，顺顺利利。 &lt; /3&gt; 岂能尽如人意，但求无愧于心。——刘伯温 自己总结的2014年，发现大多都是讲的自己的人情世故与自我认知。盖莫是这一年在被点了快进的时候，更加放大日常生活中关乎交往的方面，同时遇到相应的问题也变得更多，在加速的过程中，对体会感情中的细腻会变得迟钝，后知后觉，所以最后自己才会如此感慨，人与人之间的关系，有时候可以厚如城墙，有时候也可以薄如宣纸。 其实很多事情不去计较就不会意识到得到有多高兴失去有多难过，只要用了真心那一定不会有任何差错。 &lt; /4&gt; 日子终归会继续的，2014年已经过去。想用这一句祝福自己和朋友的2015年。 平安喜乐，万事胜意。","categories":[{"name":"发骚","slug":"发骚","permalink":"http://imxie.cc/categories/发骚/"}],"tags":[{"name":"发骚","slug":"发骚","permalink":"http://imxie.cc/tags/发骚/"}],"keywords":[{"name":"发骚","slug":"发骚","permalink":"http://imxie.cc/categories/发骚/"}]}]}